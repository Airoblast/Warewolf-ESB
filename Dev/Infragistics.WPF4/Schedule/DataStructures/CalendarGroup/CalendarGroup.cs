using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using System.Windows.Markup;
using System.Diagnostics;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.ComponentModel;
using Infragistics.Collections;

namespace Infragistics.Controls.Schedules
{
	/// <summary>
	/// Represents a group of one or more <see cref="ResourceCalendar"/> instances
	/// </summary>
	[ContentProperty("Calendars")]
	public class CalendarGroup : CalendarGroupBase
		, ISupportPropertyChangeNotifications
	{
		#region Member Variables

		// members backing public properties
		private CalendarGroupCalendarCollection _calendars;
		private CalendarGroupCalendarCollection _visibleCalendarsSource;
		private ReadOnlyNotifyCollection<ResourceCalendar> _visibleCalendars;
		private string _initialCalendarIds;
		private string _initialSelectedCalendarId;
		private ResourceCalendar _selectedCalendar;

		private PropertyChangeListenerList _propChangeListeners;
		private List<CalendarIdItem> _calendarIdList;
		private bool _updatingCalendars;

		private InternalFlags _flags;
		private bool _isAutoGenerated;

		private Snapshot _snapshot;		// AS 10/5/10 TFS55791

		#endregion //Member Variables

		#region Constructor
		/// <summary>
		/// Initializes a new <see cref="CalendarGroup"/>
		/// </summary>
		public CalendarGroup()
		{
			// since this object exists for the purposes of exposing a calendars collection there is no reason to 
			// lazily allocate this
			_calendars = new CalendarGroupCalendarCollection(this, false);

			_propChangeListeners = new PropertyChangeListenerList();
			_propChangeListeners.Add(new PropertyChangeListener<CalendarGroup>(this, OnSubObjectPropertyChanged), false);

			// we need to get a notification when a calendar is made visible or hidden so we can update 
			// the visible calendars
			_calendars.PropChangeListeners.Add(_propChangeListeners, false);

			_snapshot = new Snapshot(this); // AS 10/5/10 TFS55791
		}

		internal CalendarGroup(bool isAutoGenerated) : this()
		{
			_isAutoGenerated = isAutoGenerated;
		}
		#endregion //Constructor

		#region Base class overrides

		#region Contains

		/// <summary>
		/// Returns true if the calendar is in the group.
		/// </summary>
		/// <param name="calendar">The calendar to check.</param>
		/// <returns></returns>
		public override bool Contains(ResourceCalendar calendar)
		{
			return _calendars.Contains(calendar);
		}

		#endregion //Contains

		#region OnPropertyChanged
		/// <summary>
		/// Invoked when a property has been changed.
		/// </summary>
		/// <param name="propertyName">The name of the property being changed</param>
		protected override void OnPropertyChanged(string propertyName)
		{
			// pass along change notifications to any listeners (which includes this object 
			// as it added a listener)
			_propChangeListeners.OnPropertyValueChanged(this, propertyName, null);

			base.OnPropertyChanged(propertyName);
		}
		#endregion // OnPropertyChanged 

		#endregion // Base class overrides

		#region Properties

		#region Public Properties

		#region Calendars
		/// <summary>
		/// Returns a collection of <see cref="ResourceCalendar"/> instances
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b> The <see cref="InitialCalendarIds"/> should be used at design time to define the 
		/// contents of the collection.</p>
		/// </remarks>
		[Browsable(false)] // hide the property at design time
		public ObservableCollection<ResourceCalendar> Calendars
		{
			get { return _calendars; }
		}
		#endregion //Calendars

		#region InitialCalendarIds
		/// <summary>
		/// Returns or sets a color delimited list of resource and calendar id combinations that are used to define the contents of the collection at design time.
		/// </summary>
		/// <remarks>
		/// <p>A ResourceCalendar must be identified as a combination of the <see cref="Resource.Id"/> of its <see cref="ResourceCalendar.OwningResource"/> 
		/// and its <see cref="ResourceCalendar.Id"/> such that the calendar id follows the resource id and is enclosed in [] (e.g. resourceId[calendarId]). 
		/// If multiple ids are provided then they must be comma delimited (e.g. resourceId1[calendarId1], resourceId1[calendarId2], resourceId2[calendarId1]. 
		/// If the [calendarId] is omitted then the <see cref="Resource.PrimaryCalendar"/> will be assumed.</p>
		/// </remarks>
		public string InitialCalendarIds
		{
			get { return _initialCalendarIds; }
			set 
			{
				if (value != _initialCalendarIds)
				{
					_initialCalendarIds = value;

					// parse the list and when we are next associated with a 
					// resources collection we will update the calendars 
					// based on these ids. if we have already been updated 
					// then nothing will happen with the current calendars 
					// collection
					_calendarIdList = ParseCalendarIds(value);

					this.RaisePropertyChangedEvent("InitialCalendarIds");
				}
			}
		}
		#endregion // InitialCalendarIds

		#region InitialSelectedCalendarId
		/// <summary>
		/// The resource and calendar id combination used at design time to indicate the calendar that should be selected at runtime.
		/// </summary>
		/// <remarks>
		/// <p>A ResourceCalendar must be identified as a combination of the <see cref="Resource.Id"/> of its <see cref="ResourceCalendar.OwningResource"/> 
		/// and its <see cref="ResourceCalendar.Id"/> such that the calendar id follows the resource id and is enclosed in [] (e.g. resourceId[calendarId]). 
		/// If the [calendarId] is omitted then the <see cref="Resource.PrimaryCalendar"/> will be assumed.</p>
		/// </remarks>
		public string InitialSelectedCalendarId
		{
			get { return _initialSelectedCalendarId; }
			set
			{
				if (value != _initialSelectedCalendarId)
				{
					_initialSelectedCalendarId = value;

					this.RaisePropertyChangedEvent("InitialSelectedCalendarId");
				}
			}
		} 
		#endregion // InitialSelectedCalendarId

		#region SelectedCalendar
		/// <summary>
		/// Used at runtime to control which calendar is selected within the ui.
		/// </summary>
		internal override ResourceCalendar SelectedCalendarInternal
		{
			get { return _selectedCalendar; }
			set
			{
				if (value != _selectedCalendar)
				{
					Debug.Assert(null == value || value.OwningResource != null, "The selected calendar does not have a resource associated with it?");

					_selectedCalendar = value;

					// AS 10/5/10 TFS55791
					_snapshot.OnSelectionChanged();

					this.OnPropertyChanged("SelectedCalendar");
				}
			}
		} 
		#endregion // SelectedCalendar

		#region VisibleCalendars
		/// <summary>
		/// Returns a read-only collection that contains only the items in the <see cref="Calendars"/> collection whose <see cref="ResourceCalendar.IsVisibleResolved"/> is true.
		/// </summary>
		[Browsable(false)] // hide the property at design time
		internal override IList<ResourceCalendar> VisibleCalendarsInternal
		{
			get
			{
				if (this._visibleCalendars == null)
					this.InitializeVisibleCalendars();

				return _visibleCalendars;
			}
		}
		#endregion // VisibleCalendars

		#endregion // Public Properties

		#region Internal Properties

		#region IsAutoGenerated

		internal bool IsAutoGenerated { get { return _isAutoGenerated; } }

		#endregion //IsAutoGenerated

		#endregion //Internal Properties	
        
		#endregion //Properties

		#region Methods

		#region Public Methods
		/// <summary>
		/// Returns a string that contains the id for the calendars currently in the <see cref="Calendars"/> collection in the format expected by the <see cref="InitialCalendarIds"/> property.
		/// </summary>
		/// <returns>A string in the format expected by the <see cref="InitialCalendarIds"/> based on the ResourceCalendar instances currently in the Calendars collection.</returns>
		public string GetInitialCalendarIds()
		{
			return GetCalendarIds(this.Calendars);
		} 
		#endregion // Public Methods

		#region Private Methods

		#region AddCalendarId

		private static readonly char[] CharsToEscape = new char[] { ',', '[', ']' };

		/// <summary>
		/// Helper method for building an InitialCalendarIds string
		/// </summary>
		/// <param name="sb">The string build to add to</param>
		/// <param name="calendar">The calendar being added</param>
		private static void AddCalendarId(StringBuilder sb, ResourceCalendar calendar)
		{
			Resource resource = calendar.OwningResource;

			if (resource == null)
				return;

			if (sb.Length > 0)
				sb.Append(", ");

			AddEscapedText(resource.Id, CharsToEscape, sb);

			// if the calendar is the primary then don't include the id
			if (resource.PrimaryCalendar != calendar)
			{
				sb.Append('[');
				AddEscapedText(calendar.Id, CharsToEscape, sb);
				sb.Append(']');
			}
		}
		#endregion // AddCalendarId

		#region AddEscapedText
		/// <summary>
		/// Helper method to escape (by preceding with a /) a character in the specified list
		/// </summary>
		/// <param name="text">The test to enumerate/add</param>
		/// <param name="charactersToEscape">The characters that should be escaped</param>
		/// <param name="sb">The string builder to update with the text</param>
		private static void AddEscapedText(string text, char[] charactersToEscape, StringBuilder sb)
		{
			if (null != text)
			{
				foreach (char ch in text)
				{
					if (Array.IndexOf(charactersToEscape, ch) >= 0)
						sb.Append('\\');

					sb.Append(ch);
				}
			}
		}
		#endregion // AddEscapedText

		#region GetCalendarId
		private static string GetCalendarId(ResourceCalendar calendar)
		{
			string id = null;

			if (calendar != null)
			{
				StringBuilder sb = new StringBuilder();
				AddCalendarId(sb, calendar);
				id = sb.ToString();
			}

			return id;
		}
		#endregion // GetCalendarId

		#region GetCalendarIds
		/// <summary>
		/// Helper method for building an InitialCalendarIds string based on the specified list of calendars
		/// </summary>
		/// <param name="calendars">The list of calendars to use when generating the string</param>
		/// <returns></returns>
		private static string GetCalendarIds(IList<ResourceCalendar> calendars)
		{
			StringBuilder sb = new StringBuilder();

			for (int i = 0, count = calendars.Count; i < count; i++)
			{
				AddCalendarId(sb, calendars[i]);
			}

			return sb.ToString();
		}
		#endregion // GetCalendarIds

		#region GetFlag
		/// <summary>
		/// Returns true if any of the specified bits are true.
		/// </summary>
		/// <param name="flag">Flag(s) to evaluate</param>
		/// <returns></returns>
		private bool GetFlag(InternalFlags flag)
		{
			return (_flags & flag) != 0;
		}
		#endregion // GetFlag

		#region InitializeVisibleCalendars
		/// <summary>
		/// Populates the VisibleCalendars based on the contents of the Calendars collection
		/// </summary>
		private void InitializeVisibleCalendars()
		{
			if (_visibleCalendarsSource == null)
			{
				Debug.Assert(_visibleCalendars == null);
				_visibleCalendarsSource = new CalendarGroupCalendarCollection(this, true);
				_visibleCalendars = new ReadOnlyNotifyCollection<ResourceCalendar>(_visibleCalendarsSource);
				
				// we could add a listener to the read-only collection but we should probably only 
				// add a listener to the source collection in case we ever change the 
				// ReadOnlyNotifyCollection<ResourceCalendar> to pass itself along for change 
				// notifications
				//ScheduleUtilities.AddListener(_visibleCalendars, _propChangeListeners, false);
				_visibleCalendarsSource.PropChangeListeners.Add(_propChangeListeners, false);
			}

			if (!this.GetFlag(InternalFlags.VisibleCalendars))
				return;

			this.SetFlag(InternalFlags.VisibleCalendars, false);

			List<ResourceCalendar> visibleCalendars = new List<ResourceCalendar>();

			for (int i = 0, count = _calendars.Count; i < count; i++)
			{
				ResourceCalendar calendar = _calendars[i];

				if (calendar.IsVisibleResolved)
					visibleCalendars.Add(calendar);
			}

            // AS 1/20/11 TFS62537
            //if (!ScheduleUtilities.AreEqual(visibleCalendars, _visibleCalendarsSource, null))
			//	_visibleCalendarsSource.ReInitialize(visibleCalendars);
            ScheduleUtilities.Reinitialize(_visibleCalendarsSource, visibleCalendars);
		}
		#endregion // InitializeVisibleCalendars

		#region OnSubObjectPropertyChanged

		private static void OnSubObjectPropertyChanged(CalendarGroup group, object sender, string propName, object extraInfo)
		{
			if (sender is ResourceCalendar)
			{
				// a calendar is hidden or made visible
				if (string.IsNullOrEmpty(propName) || propName == "IsVisibleResolved")
					group.SetFlag(InternalFlags.VisibleCalendars, true);
			}
			else if (sender == group._calendars)
			{
				var collectionArgs = extraInfo as NotifyCollectionChangedEventArgs;

				// AS 10/5/10 TFS55791
				if ( null != collectionArgs )
					group._snapshot.OnCollectionChanged(collectionArgs);

				// the main calendars collection is modified
				group.SetFlag(InternalFlags.VisibleCalendars, true);
			}
		}

		#endregion //OnSubObjectPropertyChanged

		#region ParseCalendarIds

		/// <summary>
		/// Helper routine for splitting an InitialCalendarIds
		/// </summary>
		/// <param name="calendarIds">InitialCalendarIds string to parse</param>
		/// <returns></returns>
		private static List<CalendarIdItem> ParseCalendarIds(string calendarIds)
		{
			List<CalendarIdItem> ids = new List<CalendarIdItem>();

			if (!string.IsNullOrEmpty(calendarIds))
			{
				Regex split = new Regex(@"(?<!\\),"); // split on unescaped commas
				string[] items = split.Split(calendarIds);

				
				Regex idSplit = new Regex(@"(?<resource>(\\(?>[\[,])|[^[,])+)(\[(?<calendar>(\\(?>[\]])|[^]])*)\])?");

				Regex escape = new Regex(@"\\(?=[\[\],])");

				for (int i = 0; i < items.Length; i++)
				{
					string item = items[i];

					if (item == null)
						continue;

					item = item.Trim();

					if (item.Length == 0)
						continue;

					Match match = idSplit.Match(item);

					string resource = match.Groups["resource"].Value.Trim();
					string calendar = match.Groups["calendar"].Value.Trim();

					
					calendar = escape.Replace(calendar, "");
					resource = escape.Replace(resource, "");

					var id = new CalendarIdItem { CalendarId = calendar, ResourceId = resource };
					ids.Add(id);
				}
			}

			return ids;
		}
		#endregion // ParseCalendarIds

		#region SetFlag
		private void SetFlag(InternalFlags flag, bool set)
		{
			if (set)
				_flags |= flag;
			else
				_flags &= ~flag;
		}
		#endregion // SetFlag

		#region UpdateCalendarsFromIds
		/// <summary>
		/// Helper method for reinitializing the Calendars collection based on the CalendarId's
		/// </summary>
		private void UpdateCalendarsFromIds(ResourceCollection resources)
		{
			List<ResourceCalendar> calendars = new List<ResourceCalendar>();
			ResourceCalendar selectedCalendar = null;

			if (null != _calendarIdList)
			{
				foreach (CalendarIdItem item in _calendarIdList)
				{
					ResourceCalendar calendar = item.GetCalendar(resources);

					if (null != calendar)
						calendars.Add(calendar);
				}

				var selectedItem = ParseCalendarIds(_initialSelectedCalendarId).FirstOrDefault();

				if (null != selectedItem)
				{
					selectedCalendar = selectedItem.GetCalendar(resources);

					// do not use it if the parsed calendars doesn't contain it
					if (null != selectedCalendar && !calendars.Contains(selectedCalendar))
						selectedCalendar = null;
				}

				// select the first by default
				if (selectedCalendar == null && calendars.Count > 0)
					selectedCalendar = calendars.FirstOrDefault((ResourceCalendar c) => { return c.IsVisibleResolved; });
			}

			// need a flag to know not to process this change
			bool wasUpdating = _updatingCalendars;
			_updatingCalendars = true;

			try
			{
                // AS 1/20/11 TFS62537
                //_calendars.ReInitialize(calendars);
                ScheduleUtilities.Reinitialize(_calendars, calendars);

				this.InitializeVisibleCalendars();

				this.SelectedCalendar = selectedCalendar;
			}
			finally
			{
				_updatingCalendars = wasUpdating;
			}
		} 
		#endregion // UpdateCalendarsFromIds

		#region VerifySelection
		private void VerifySelection()
		{
			ResourceCalendar newSelected = _selectedCalendar;

			// if there are no visible calendars then nothing is selected
			if (this.VisibleCalendars.Count == 0)
				newSelected = null;
			else if (newSelected == null || !_calendars.Contains(newSelected)) // if nothing as been specified as the selected item then select the first
				newSelected = this.VisibleCalendars[0];
			else if (!newSelected.IsVisibleResolved)
			{
				// if the currently selected calendar is not visible then select the adjacent one
				newSelected = ScheduleUtilities.FindNearestAfterOrDefault(_calendars, _calendars.IndexOf(newSelected), (ResourceCalendar c) => { return c.IsVisibleResolved; });
			}

			this.SelectedCalendar = newSelected;
		}
		#endregion // VerifySelection

		#endregion // Private Methods

		#region Internal Methods

		#region OnResourcesChanged
		/// <summary>
		/// Invoked when the Resources associated with the containing CalendarGroupCollection has been changed.
		/// </summary>
		/// <param name="resources">The source resources collection that provides the calendars</param>
		/// <param name="verifyOnly">True if the group should only ensure the calendars are still used by the resources collection and false if the group can reinitialize the calendars colleciton from the serialized calendar ids</param>
		internal void OnResourcesChanged(ResourceCollection resources, bool verifyOnly)
		{
			// AS 10/5/10 TFS55791
			// Refactored the impl to be in a helper method and while processing we
			// keep a flag so we know that any changes that occur to calendars are 
			// a result of our changes.
			//
			bool wasProcessing = this.GetFlag(InternalFlags.ProcessingResourcesChange);
			this.SetFlag(InternalFlags.ProcessingResourcesChange, true);

			try
			{
				// AS 10/5/10 TFS55791
				// Keep a flag that let's us know whether the snapshot and contents
				// are in sync. I'm setting this before processing so the group can 
				// know in case something like the SelectedCalendar changes and we 
				// call into the snapshot. Note for now we are considering an empty 
				// resources collection (as happens in this issue) to be in a dirty 
				// state. 
				//
				bool isResourcesSynchronized = resources != null && resources.Count > 0;
				this.SetFlag(InternalFlags.IsSynchronizedWithSnapshot, isResourcesSynchronized);

				this.OnResourcesChangedImpl(resources, verifyOnly);

				// AS 10/5/10 TFS55791
				// If the resources are not dirty then take a snapshot. This stores 
				// the id of the calendar and its owning resource so we can locate 
				// it later when we verify again.
				//
				if ( isResourcesSynchronized )
				{
					_snapshot.PerformSnapshot();
				}
			}
			finally
			{
				this.SetFlag(InternalFlags.ProcessingResourcesChange, wasProcessing);
			}
		}

		// AS 10/5/10 TFS55791
		// Moved the bulk of the implementation of the OnResourcesChanged here.
		//
		private void OnResourcesChangedImpl( ResourceCollection resources, bool verifyOnly )
		{
			if (resources == null)
				this.UpdateCalendarsFromIds(null);
			else if (!verifyOnly && _calendarIdList != null)
			{
				// if we're not just verifying the collection then reinitialize if we have an initial list
				this.UpdateCalendarsFromIds(resources);
			}
			else
			{
				// AS 10/5/10 TFS55791
				// Since there will be situations where the resources can be removed 
				// and asynchronously repopulated we need to always just reinitialize
				// from the last snapshot that we took.
				//
				// verify that the calendars we have are in the collections
				//for ( int i = this.Calendars.Count - 1; i >= 0; i-- )
				//{
				//    ResourceCalendar cal = _calendars[i];
				//    Resource res = cal.OwningResource;
				//
				//    bool removeCalendar = false;
				//
				//    if ( res == null || !resources.Contains(res) )
				//        removeCalendar = true;
				//    else if ( res.PrimaryCalendar != cal && !res.Calendars.Contains(cal) )
				//        removeCalendar = true;
				//
				//    if ( removeCalendar )
				//        _calendars.RemoveAt(i);
				//}
				Debug.Assert(null != _snapshot);

				if ( resources.Count == 0 )
					this.Calendars.Clear();
				else
				{
					_snapshot.UpdateGroup(resources);
				}

				this.InitializeVisibleCalendars();
				this.VerifySelection();
			}
		}
		#endregion // OnResourcesChanged

		#endregion // Internal Methods

		#endregion // Methods

		#region ISupportPropertyChangeNotifications Implementation

		void ITypedSupportPropertyChangeNotifications<object, string>.AddListener(ITypedPropertyChangeListener<object, string> listener, bool useWeakReference)
		{
			_propChangeListeners.Add(listener, useWeakReference);
		}

		void ITypedSupportPropertyChangeNotifications<object, string>.RemoveListener(ITypedPropertyChangeListener<object, string> listener)
		{
			_propChangeListeners.Remove(listener);
		}

		#endregion // ISupportPropertyChangeNotifications Implementation

		#region CalendarIdItem class
		internal class CalendarIdItem
		{
			public string ResourceId;
			public string CalendarId;
			public WeakReference Calendar; // AS 10/5/10 TFS55791

			#region Create
			// AS 10/5/10 TFS55791
			internal static CalendarIdItem Create( ResourceCalendar calendar )
			{
				CalendarIdItem item;

				if ( calendar != null )
				{
					item = new CalendarIdItem { CalendarId = calendar.Id, ResourceId = calendar.OwningResourceId, Calendar = new WeakReference(calendar) };
				}
				else
					item = null;

				return item;
			} 
			#endregion // Create

			#region GetCalendar
			internal ResourceCalendar GetCalendar(ResourceCollection resources)
			{
				Resource r = resources != null ? resources.GetResourceFromId(this.ResourceId) : null;
				ResourceCalendar calendar = null;

				if (null != r)
				{
					calendar = string.IsNullOrWhiteSpace(this.CalendarId) ? r.PrimaryCalendar : r.GetCalendar(this.CalendarId);
				}

				return calendar;
			} 
			#endregion // GetCalendar
		} 
		#endregion // CalendarIdItem class

		#region InternalFlags enum
		[Flags]
		private enum InternalFlags : byte
		{
			/// <summary>
			/// The visible calendars needs to be verified
			/// </summary>
			VisibleCalendars = 0x1,

			// AS 10/5/10 TFS55791
			/// <summary>
			/// In OnResourcesChanged
			/// </summary>
			ProcessingResourcesChange = 0x2,

			/// <summary>
			/// Set when the current state of the group within the OnResourcesChanged is in sync with the snapshot
			/// </summary>
			IsSynchronizedWithSnapshot = 0x4,
		}
		#endregion // InternalFlags enum

		// AS 10/5/10 TFS55791
		#region Snapshot class
		private class Snapshot
		{
			#region Member Variables

			private CalendarGroup _group;
			private CalendarIdItem _selectedItem;
			private List<CalendarIdItem> _calendarItems;

			#endregion // Member Variables

			#region Constructor
			internal Snapshot( CalendarGroup group )
			{
				_group = group;
				_calendarItems = new List<CalendarIdItem>();
			}
			#endregion // Constructor

			#region Methods

			#region IndexOf
			private int IndexOf( ResourceCalendar calendar )
			{
				if ( null != calendar )
				{
					for ( int i = 0, count = _calendarItems.Count; i < count; i++ )
					{
						if ( ScheduleUtilities.GetWeakReferenceTargetSafe(_calendarItems[i].Calendar) == calendar )
						{
							return i;
						}
					}
				}

				return -1;
			}
			#endregion // IndexOf

			#region OnCollectionChanged
			internal void OnCollectionChanged( NotifyCollectionChangedEventArgs collectionArgs )
			{
				// ignore changes while synchronizing...
				if ( _group.GetFlag(InternalFlags.ProcessingResourcesChange) )
					return;

				// if the developer modifies the collection while the group is out 
				// of sync (i.e. it has no calendars but we have a snapshot from when 
				// we did) then clear the snapshot and just store the information 
				// based on what they are adding/removing. in theory we could try 
				// to add if they added, etc. but that might be inconsistent since 
				// they wouldn't be able to remove what we had in the snapshot and 
				// we wouldn't be able to know exactly where to insert since there 
				// are no calendars so we would have to insert at the front/back 
				// always. i think its cleaner to just use what they provide.
				if ( !_group.GetFlag(InternalFlags.IsSynchronizedWithSnapshot) )
				{
					this.PerformSnapshot();
					return;
				}

				switch ( collectionArgs.Action )
				{
					default:
					case NotifyCollectionChangedAction.Reset:
						this.PerformSnapshot();
						break;

					case NotifyCollectionChangedAction.Add:
						{
							int index = Math.Min(_calendarItems.Count, collectionArgs.NewStartingIndex);

							foreach ( ResourceCalendar calendar in collectionArgs.NewItems )
							{
								_calendarItems.Insert(index++, CalendarIdItem.Create(calendar));
							}
							break;
						}
					case NotifyCollectionChangedAction.Remove:
						{
							Debug.Assert(_group.Calendars.Count + collectionArgs.OldItems.Count == _calendarItems.Count, "Out of sync?");
							_calendarItems.RemoveRange(collectionArgs.OldStartingIndex, collectionArgs.OldItems.Count);
							break;
						}
					case NotifyCollectionChangedAction.Replace:
						{
							for ( int i = 0, count = collectionArgs.OldItems.Count; i < count; i++ )
							{
								_calendarItems[i + collectionArgs.OldStartingIndex] = CalendarIdItem.Create(collectionArgs.NewItems[i] as ResourceCalendar);
							}
							break;
						}
				}
			}
			#endregion // OnCollectionChanged

			#region OnIdChanged
			internal void OnIdChanged( ResourceCalendar calendar )
			{
				int index = this.IndexOf(calendar);

				if ( index >= 0 )
				{
					var item = _calendarItems[index];

					item.CalendarId = calendar.Id;
					item.ResourceId = calendar.OwningResourceId;
				}
			}
			#endregion // OnIdChanged

			#region OnSelectionChanged
			internal void OnSelectionChanged()
			{
				int index = this.IndexOf(_group.SelectedCalendar);

				if ( index < 0 )
				{
					if ( _group.SelectedCalendar == null )
					{
						// do not clear the selected item if we are processing the resource changes
						if ( !_group.GetFlag(InternalFlags.IsSynchronizedWithSnapshot) )
							return;

						_selectedItem = null;
					}
					else
					{
						// just store the info even though its not in the collection?
						_selectedItem = CalendarIdItem.Create(_group.SelectedCalendar);
					}
				}
				else
				{
					_selectedItem = _calendarItems[index];
				}
			} 
			#endregion // OnSelectionChanged

			#region PerformSnapshot
			internal void PerformSnapshot()
			{
				var selected = _group.SelectedCalendar;
				_selectedItem = null;
				_calendarItems.Clear();

				foreach ( var calendar in _group.Calendars )
				{
					var item = CalendarIdItem.Create(calendar);

					if ( calendar == selected )
						_selectedItem = item;

					_calendarItems.Add(item);
				}
			}
			#endregion // PerformSnapshot

			#region UpdateGroup
			internal void UpdateGroup( ResourceCollection resources )
			{
				List<ResourceCalendar> calendars = new List<ResourceCalendar>();

				for ( int i = 0, count = _calendarItems.Count; i < count; i++ )
				{
					var item = _calendarItems[i];
					var calendar = item.GetCalendar(resources);

					if ( calendar != null )
					{
						calendars.Add(calendar);
					}
					else
					{
						_calendarItems.RemoveAt(i);
						i--;
						count--;
					}
				}

                // AS 1/20/11 TFS62537
                // Reinitialize will raise a change notification even if the new collection is the same.
                // Added helper method to take care of this.
                //
                //_group._calendars.ReInitialize(calendars);
                ScheduleUtilities.Reinitialize(_group._calendars, calendars);

				if ( null != _selectedItem )
					_group.SelectedCalendar = _selectedItem.GetCalendar(resources) ?? _group.SelectedCalendar;
			}
			#endregion // UpdateGroup

			#endregion // Methods
		}
		#endregion // Snapshot class
	}
}

#region Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved
/* ---------------------------------------------------------------------*
*                           Infragistics, Inc.                          *
*              Copyright (c) 2001-2012 All Rights reserved               *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* THE SOURCE CODE CONTAINED HEREIN AND IN RELATED FILES IS PROVIDED     *
* TO THE REGISTERED DEVELOPER FOR THE PURPOSES OF EDUCATION AND         *
* TROUBLESHOOTING. UNDER NO CIRCUMSTANCES MAY ANY PORTION OF THE SOURCE *
* CODE BE DISTRIBUTED, DISCLOSED OR OTHERWISE MADE AVAILABLE TO ANY     *
* THIRD PARTY WITHOUT THE EXPRESS WRITTEN CONSENT OF INFRAGISTICS, INC. *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY INFRAGISTICS PRODUCT.    *
*                                                                       *
* THE REGISTERED DEVELOPER ACKNOWLEDGES THAT THIS SOURCE CODE           *
* CONTAINS VALUABLE AND PROPRIETARY TRADE SECRETS OF INFRAGISTICS,      *
* INC.  THE REGISTERED DEVELOPER AGREES TO EXPEND EVERY EFFORT TO       *
* INSURE ITS CONFIDENTIALITY.                                           *
*                                                                       *
* THE END USER LICENSE AGREEMENT (EULA) ACCOMPANYING THE PRODUCT        *
* PERMITS THE REGISTERED DEVELOPER TO REDISTRIBUTE THE PRODUCT IN       *
* EXECUTABLE FORM ONLY IN SUPPORT OF APPLICATIONS WRITTEN USING         *
* THE PRODUCT.  IT DOES NOT PROVIDE ANY RIGHTS REGARDING THE            *
* SOURCE CODE CONTAINED HEREIN.                                         *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* --------------------------------------------------------------------- *
*/
#endregion Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved