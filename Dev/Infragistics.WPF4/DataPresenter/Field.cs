using System;
using System.Data;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Documents;
using System.Windows.Shapes;
using System.Windows.Navigation;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Automation;
using System.Windows.Automation.Provider;
using System.Windows.Threading;
using System.Diagnostics;
//using System.Windows.Events;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Text;
using Infragistics.Shared;
using Infragistics.Windows.Selection;
using Infragistics.Windows.Helpers;
using Infragistics.Windows.DataPresenter;
using Infragistics.Windows.Editors;
using Infragistics.Windows.Controls;
using Infragistics.Windows.Internal;
using Infragistics.Windows.DataPresenter.Events;
using Infragistics.Windows.DataPresenter.Internal;
using Infragistics.Controls.Layouts.Primitives;

using Infragistics.Windows.DataPresenter.Calculations;


namespace Infragistics.Windows.DataPresenter
{
    #region Field class

    /// <summary>
    /// Used in a <see cref="FieldLayout"/>'s <see cref="FieldLayout.Fields"/> collection to define the layout of a single field 
    /// </summary>
	/// <remarks>
	/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
	/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
	/// </remarks>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
    /// <seealso cref="FieldLayout"/>
    /// <seealso cref="FieldLayoutSettings"/>
    /// <seealso cref="FieldSettings"/>
    /// <seealso cref="FieldLayout.Fields"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayouts"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldSettings"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.DefaultFieldLayout"/>
    /// <seealso cref="UnboundField"/>
    public class Field : DependencyObjectNotifier, ISelectableItem
    {
        #region Private Members

		internal static Type DEFAULT_DATA_TYPE = typeof( object );

        private FieldLayout _owner;
        private bool _isPrimary = false;
        private bool _autoGenerated;
        private bool _dataTypeExplicitySet;
        private bool _nameExplicitySet;

        // JJD 7/25/08 - BR35098 
        // Don't need _labelExplicitySet flag anymore since we are coercing the value.
        // Instead cache the default label value for use in the coerce
        //private bool _labelExplicitySet;
        // JJD 5/20/09 - TFS17823
        // Initialize the defaultLabel to something that can't be set by the user
        //private object _defaultLabel;
        private object _defaultLabel = DefaultValueMarker.Instance;

		private bool _selected;
        private FieldGridPosition _cellPosition = new FieldGridPosition();
        private FieldSettings _settings;
		// AS 4/12/11 TFS62951
		//private LabelPresenter _lastFieldLabel;
        private bool _isGroupBy;
        private bool _isExpandableByDefault;
        private SortStatus _sortStatus = SortStatus.NotSorted;
		private Type _cachedDataType = DEFAULT_DATA_TYPE;
        // JJD 4/17/08 - optimization
        // cache the underlying data type as well
		private Type _cachedDataTypeUnderlying = DEFAULT_DATA_TYPE;

        private Nullable<bool> _cachedIsExpandable = new Nullable<bool>();
        private string _cachedName = string.Empty;
        private int _index;
		private int _layoutVersion;
		private bool _isScrollTip = false;
		private Stack<LabelPresenter> _cachedLabelPresenters;
		private Stack<CellValuePresenter> _cachedCellValuePresenters;

		private static Hashtable sampleData = null;

		// AS 5/1/07 Performance
		private int _templateCellIndex = -1;

		// JJD 5/3/07 - Optimization
		// Cache a key so that multiple field's can share a cell element in the template record
		private CellElementKey _cellElementKey;

        // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
        // We want to do caching similar to that of the CVP. Basically we want to only hydrate 
        // 1 element in the template record for each set of label property values.
        //
        private LabelElementKey _labelElementKey;
        private FilterCellElementKey _filterCellElementKey;
        
        // JJD 3/5/08 - Added
        private IValueConverter _converter;
        private object _converterParameter; // JJD 4/27/11 - TFS73888 - added

        // JJD 5/29/09 - TFS18063 - added
        private CultureInfo _converterCulture;
        
        // JJD 4/26/10 - TFS30833 
        private CultureInfo _converterCultureResolved;

		
		
		
		
		
		
		private FieldResizeInfo _explicitResizeInfo;

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		private bool _isFilterRecordCacheDirty = true;
		private Visibility _cachedDefaultFilterOperatorVisibility;
		private ComparisonOperator _cachedDefaultFilterOperatorDefaultValue;
		private FilterOperandUIType _cachedDefaultFilterOperandUIType;
		private ComparisonOperatorFlags _cachedDefaultFilterOperatorDropDownItems;

        // AS 12/11/08 TFS11518
        private int _labelLineCount;

        // AS 12/9/08 NA 2009 Vol 1 - Fixed Fields
        private FieldLayoutItem _cellLayoutItem;
        private FieldLayoutItem _labelLayoutItem;
        private GridBagConstraint _layoutConstraint;
        private CPGridBagLayoutManager _cachedCPLayoutManager;
        private FieldFlags _fieldFlags;

		// AS 4/27/09 TFS17122
		private int _navigationIndex;
		
		// JJD 6/30/11 - TFS80466
 		// Cache whether there are style selectors specified at any level, Field, FieldLayout or DataPresenter.
		private bool _hasCellValuePresenterStyleSelector;
		private bool _hasEditorStyleSelector;

        // JJD 5/29/09 - TFS18063
        // Cache the EditAsType
        private Type _cachedEditAsTypeResolved;
        private Type _cachedEditAsTypeResolvedUnderlying;

		// JJD 7/15/10 - TFS35815 - added
		private NonSpecificNotificationBehavior _cachedNonSpecificNotificationBehavior = NonSpecificNotificationBehavior.Default;

		// SSP 5/29/09 - TFS17233 - Optimization
		// Added caching for GroupByEvaluatorResolved. Also added _cachedCellTextConverterInfo
		// which is used to temporarily cache the cell text converter while performing an 
		// operation, like sorting, that will invole converting values of multiple cells of 
		// a field to text.
		// 
		private IGroupByEvaluator _cachedGroupByEvaluator;
		internal CellTextConverterInfo _cachedCellTextConverterInfo;

		// SSP 6/23/09 - NAS9.2 Field Chooser
		// This is used by the field chooser to force a field to be visible even if it's
		// a group-by field and CellVisibilityWhenGrouped is set to a value other than Visible.
		// 
		private bool _ignoreFieldVisibilityOverrides;

		// AS 6/26/09 NA 2009.2 Field Sizing
		private FieldLength? _cachedWidth;
		private FieldLength? _cachedHeight;

		// AS 7/1/09 NA 2009.2 Field Sizing
		// We need a flag on the field so we know whether its initial auto size has ever been 
		// processed. This is needed because the field may have been initially collapsed or 
		// it may get added after the field layout has already processed its initial set of fields.
		//
		internal bool _hasPendingInitialAutoSize = true;

		// JM 07-29-09 TFS 19241
		private bool			_isPropertyDescriptorInitialized;

		// AS 7/31/09 NA 2009.2 Field Sizing
		private int _autoSizeVersion = 1;

		// AS 9/29/09 Optimization
		private FixedFieldLocation _cachedFixedLocation;

        // SSP 6/7/10 - Optimizations - TFS34031
        // Cache resolved property value.
        // 
        private bool? _cachedDataValueChangedNotificationsActiveResolved;
        private int? _cachedDataValueChangedHistoryLimitResolved;
        private int _cachedSupportDataErrorInfoResolved = -1;

		// JJD 3/13/11 - TFS67970 - Optimization
		// Cache the resolved changed scope value
		private DataValueChangedScope? _cachedDataValueChangedScopeResolved;

		// JJD 3/9/11 - TFS67970 - Optimization - cache the binding
		private Binding _cellContentAlignmentBinding;

		// JJD 3/9/11 - TFS67970 - Optimization - cache the binding
		private Binding _visibilityBinding;

		// JJD 6/27/11 - TFS36572 - added
		private int _propertyDescriptorVersion;

		// AS 11/29/10 TFS60418
		// Maintain a separate version so we know when just this field has been dirtied.
		//
		private int _layoutItemVersion;

		// AS 8/25/11 TFS84612
		private CellContentAlignment? _cachedCellContentAlignmentResolved;

		#endregion //Private Members

        #region Constants

        internal const double AbsoluteMinimumExtent = 6;

		internal const CellClickAction DefaultCellClickAction = CellClickAction.EnterEditModeIfAllowed;
		internal const LabelClickAction DefaultLabelClickAction = LabelClickAction.SortByMultipleFields;

        #endregion //Constants	
     
        #region Constructors

        /// <summary>
		/// Initializes a new instance of the <see cref="Field"/> class
        /// </summary>
        public Field()
        {
			this.Initialize( );
        }

        // JJD 5/20/09 - added overload
        /// <summary>
		/// Initializes a new instance of the <see cref="Field"/> class
        /// </summary>
        /// <param name="name">The name of the field.</param>
        public Field(string name) : this()
        {
            this.Name = name;
        }

        // JJD 5/20/09 - added overload
        /// <summary>
		/// Initializes a new instance of the <see cref="Field"/> class
        /// </summary>
        /// <param name="name">The name of the field.</param>
        /// <param name="dataType">The type of data the field contains</param>
        public Field(string name, Type dataType) : this(name)
        {
            this.DataType = dataType;
        }

        // JJD 5/20/09 - added overload
        /// <summary>
		/// Initializes a new instance of the <see cref="Field"/> class
        /// </summary>
        /// <param name="name">The name of the field.</param>
        /// <param name="label">The label to use to represent the field in the UI.</param>
        public Field(string name, object label) : this(name)
        {
            this.Label = label;
        }

        // JJD 5/20/09 - added overload
        /// <summary>
		/// Initializes a new instance of the <see cref="Field"/> class
        /// </summary>
        /// <param name="name">The name of the field.</param>
        /// <param name="dataType">The type of data the field contains</param>
        /// <param name="label">The label to use to represent the field in the UI.</param>
        public Field(string name, Type dataType, object label) : this(name, dataType)
        {
            this.Label = label;
        }

        internal Field(Type dataType, string name, object label)
        {
            this._autoGenerated = true;
            this.DataType = dataType;
            this.Name = name;

            // JJD 7/25/08 - BR35098
            // Call the InitializeDefaultLabel method instead of setting the property explicitly
            //this.Label = label; 
            this.InitializeDefaultLabel(label);

            // reset the flags that were set to true by setting the properties above
            this._dataTypeExplicitySet = false;

            // JJD 7/25/08 - BR35098 
            // Don't need _labelExplicitySet flag anymore since we are coercing the value.
            //this._labelExplicitySet = false;

            this._nameExplicitySet = false;

			// AS 9/29/09 Optimization
			_cachedFixedLocation = this.FixedLocation;

			this.Initialize( );
        }

		private void Initialize( )
		{
            // JJD 4/17/08 - Optimization
            // Call CacheDataType method to cache both the type and the underlying type
			//this._cachedDataType = this.GetValue( DataTypeProperty ) as Type;
			this.CacheDataType( this.GetValue( DataTypeProperty ) as Type);
        }

        #endregion //Constructors

        #region Base class overrides

            #region OnPropertyChanged

        /// <summary>
        /// Called when a property has been changed
        /// </summary>
        protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
        {
            // JJD 2/7/08 - BR30444
            // Cache the AllowLabelVirtualization if the Label property is being set
            bool? oldAllowLabelVirtualization = null;
            if (this._owner != null &&
                e.Property == LabelProperty )
                oldAllowLabelVirtualization = this.AllowLabelVirtualizationResolved;

            base.OnPropertyChanged(e);

			DependencyProperty property = e.Property;

            if (property == DataTypeProperty)
            {
                this._dataTypeExplicitySet = true;

                // JJD 4/17/08 - Optimization
                // Call CacheDataType method to cache both the type and the underlying type
                //this._cachedDataType = (Type)this.GetValue(Field.DataTypeProperty);
                this.CacheDataType((Type)this.GetValue(Field.DataTypeProperty));

                // JJD 6/03/10 - Optimization
                // save the old resolved IsExpnadable state
                bool oldIsExpandable = this.IsExpandableResolved;

                // JJD 6/03/10 - TFS33273
                // We always need to initialize _isExpandableByDefault
                //if (!this._cachedIsExpandable.HasValue)
                {
                    // JJD 4/17/08
                    // check underlying data type instead
                    if (this._cachedDataTypeUnderlying == null || this._cachedDataTypeUnderlying == typeof(string))
                        this._isExpandableByDefault = false;
                    else
                        this._isExpandableByDefault = typeof(IEnumerable).IsAssignableFrom(this._cachedDataTypeUnderlying);

                    // JJD 6/03/10 - Optimization
                    // Only process a state change if the state has in fact changed
                    //if (this._owner != null)
                    if (this._owner != null && oldIsExpandable != this.IsExpandableResolved)
                    {
                        this._owner.Fields.OnIsExpandableFieldInvalidated(this);

                        // JJD 2/7/08 - BR30444
                        // Make sure the styles get regenerated
						
						
                        //this.ProcessFieldSettingsChange("IsExpandable");
						this.ProcessIsExpandableChanged( );
                    }
                }

				// SSP 12/11/08 - NAS9.1 Record Filtering
				// DataType affects EditAsTypeResolved which in turn is used to resolve some of the filter record
				// related properties. We need verify cached values and raise appropriate property change notifications
				// for the affected properties.
				// 
				this.DirtyRecordFilterRelatedCache( true );
            }
            else if (property == LabelProperty)
            {
                // JJD 7/25/08 - BR35098 
                // Don't need _labelExplicitySet flag anymore since we are coercing the value.
                //this._labelExplicitySet = true;

                // JJD 2/7/08 - BR30444
                // If the AllowLabelVirtualization changed release the TemplateDataRecordCache
                if (this._owner != null &&
                    oldAllowLabelVirtualization.HasValue &&
                    oldAllowLabelVirtualization.Value != this.AllowLabelVirtualizationResolved &&
                    this._owner.TemplateDataRecordCache != null)
                {
                    // AS 2/10/09
                    // Releasing the cache alone is not enough since the virt panel 
                    // won't know about the release.
                    //
                    //this._owner.TemplateDataRecordCache.ReleaseCache();
					// AS 7/7/09 TFS19145
					// We don't need new record templates as a result of this change - just need to 
					// update the cell info/field lists.
					//
                    //this._owner.TemplateVersion++;
					_owner.BumpTemplateVersion(false);
                }

            }
            else if (property == IsExpandableProperty)
            {
                this._cachedIsExpandable = (Nullable<bool>)e.NewValue;
                if (this._owner != null)
                    this._owner.Fields.OnIsExpandableFieldInvalidated(this);

                // JJD 2/7/08 - BR30444
                // Make sure the styles get regenerated
				
				
                
				this.ProcessIsExpandableChanged( );
            }
            
#region Infragistics Source Cleanup (Region)





















#endregion // Infragistics Source Cleanup (Region)

            else if (property == VisibilityProperty)
            {
                // JJD 2/26/07 
                // Call the invalidate of the dp so the panels get refreshed
                if (this._owner != null && this._owner.DataPresenter != null)
                {
                    // JJD 12/11/08 - TFS11474
                    // Keep track of the # of expandable field that are not collapsed
                    this._owner.Fields.OnIsExpandableFieldInvalidated(this);

                    // SSP 7/17/07 BR22919
                    // Don't clear the group-by fields.
                    // 
                    //this._owner.DataPresenter.InvalidateGeneratedStyles(true, this.IsGroupBy);

                    // JJD 7/21/08 - BR34098 - Optimization
                    // Invalidate the generated styles asynchronously so that if alot of
                    // changes are made in a tight loop that only one invalidation will take place
                    //this._owner.DataPresenter.InvalidateGeneratedStyles(true, false);

                    // JJD 10/30/08 - TFS7858
                    // Call the fieldlayout's PostDelayedInvalidation instead so we only invalidate
                    // the styles if we aren't in the the middle of initializing all the fields 
                    //this._owner.DataPresenter.InvalidateGeneratedStylesAsync();
					// AS 7/7/09 TFS19145
                    //this._owner.PostDelayedInvalidation();
					_owner.OnFieldVisibilityChanged(this);
                }
                //this._owner.InvalidateGeneratedStyles(true);

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                this.BumpLayoutItemVersion();

                // JJD 5/1/07
                // Raise the notification for VisibilityResolved
                this.RaisePropertyChangedEvent("VisibilityResolved");
            }
			// SSP 6/4/08 NAS 8.1 - Summaries Functionality
			// Refresh summary result text when string format changes.
			// 
			else if ( SummaryStringFormatsProperty == property )
			{
				SummaryDefinitionCollection summaries = null != _owner ? _owner.SummaryDefinitionsIfAllocated : null;
				if ( null != summaries )
					summaries.BumpDataVersion( );					
			}



            this.RaisePropertyChangedEvent(property.Name);
        }

            #endregion //OnPropertyChanged

			#region ToString

		/// <summary>
		/// Returns a string representation of the object
		/// </summary>
		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();

			sb.Append("Field: ");
			sb.Append(this.Name);

			return sb.ToString();
		}

			#endregion //ToString	

        #endregion //Base class overrides	

        #region Properties

            #region Public Properties

				#region ActualPosition

		// SSP 1/6/09 TFS11860
		// Added FieldPosition structure.
		// 
		/// <summary>
		/// Gets or sets the actual position of the field in the arrangement of fields in the field layout.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>ActualPosition</b> property returns the resolved position of the field in the field
		/// layout. This value can be different from the field's <see cref="Field.Column"/>, <see cref="Field.Row"/>,
		/// <see cref="Field.ColumnSpan"/> and <see cref="Field.RowSpan"/> property values because of either
		/// auto-arrangement or user's re-arranging of fields.
		/// </para>
		/// <para class="body">
		/// You can set this property to change the position of the field in the arrangement of fields.
		/// The difference between this property and the <see cref="Column"/>, <see cref="Row"/>,
		/// <see cref="ColumnSpan"/> and <see cref="RowSpan"/> properties is that these properties 
		/// specify the initial or default position information of the field whereas <i>ActualPosition</i>
		/// specifies the actual or current position information of the field. <b>Note</b> that you
		/// can use the FieldLayout's <see cref="FieldLayout.EnsureUniqueFieldPositions"/> method to
		/// make sure none of the fields overlap after setting ActualPosition on one or more fields.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that if the data presenter hasn't auto-arranged fields yet (because for example the 
		/// data presenter hasn't been displayed yet), this property will return a default value based on
		/// its Column, Row, ColumnSpan and RowSpan property settings.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldLayout.EnsureUniqueFieldPositions"/>
		// JJD 12/8/11 - TFS32078
		// Add attributes to prevent the ActualPosition property from showing up in the toolbod
		// and from being serialized at design time
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		public FieldPosition ActualPosition
		{
			get
			{
				FieldLayout fieldLayout = _owner;

				// SSP 6/26/09 - NAS9.2 Field Chooser
				// Commneted out the original code and added the new code. It's essentially the
				// same except that the GridPosition is used as a fallback value if the field
				// layout info doesn't have the information for the field.
				// 
				// --------------------------------------------------------------------------------

				ItemLayoutInfo info;
				if ( null != fieldLayout )
				{
					LayoutInfo layoutInfo = fieldLayout.GetFieldLayoutInfo( true, false );
					info = null != layoutInfo ? layoutInfo[this] : null;

					if ( null != info )
						return new FieldPosition( info.Column, info.Row, info.ColumnSpan, info.RowSpan );
				}


				FieldGridPosition gridPos = this.GridPosition;
				if ( null != gridPos && ! gridPos.IsEmpty )
					return new FieldPosition( gridPos.Column, gridPos.Row, gridPos.ColumnSpan, gridPos.RowSpan );

//#if EXPRESS
//                FieldGridPosition gridPos = this.GridPosition;
//                if ( null != gridPos )
//                    return new FieldPosition( gridPos.Column, gridPos.Row, gridPos.ColumnSpan, gridPos.RowSpan );
//#else // EXPRESS
//                ItemLayoutInfo info;
//                if ( null != fieldLayout )
//                {
//                    info = null != fieldLayout._dragFieldLayoutInfo ? fieldLayout._dragFieldLayoutInfo[this] : null;
//                    if ( null == info )
//                        info = null != fieldLayout._autoGeneratedPositions ? fieldLayout._autoGeneratedPositions[this] : null;

//                    if ( null != info )
//                        return new FieldPosition( info.Column, info.Row, info.ColumnSpan, info.RowSpan );
//                }
//#endif // EXPRESS
				// --------------------------------------------------------------------------------

				return new FieldPosition( this.Column, this.Row, this.ColumnSpan, this.RowSpan );
			}
			// SSP 9/2/09 TFS17893
			// Added the setter to this property so one can change the position of a 
			// field after it has been moved.
			// 
			set
			{
				this.SetActualPosition( value, false );
			}
		}

				#endregion // ActualPosition

                #region AllowCellVirtualizationResolved

		/// <summary>
		/// Determines if the cell uielement creation will be deferred until the cell is brought into view (read-only).
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b> even if this property is resolved to true it is possible that it will be ignored in certain conditions where the cells cannot be virtually allocated.</p>
		/// </remarks>
		/// <seealso cref="FieldSettings.AllowCellVirtualization"/>
        /// <seealso cref="FieldSettings.AllowCellVirtualizationProperty"/>
		/// <seealso cref="FieldSettings"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
 		[Bindable(true)]
		[ReadOnly(true)]
		public bool AllowCellVirtualizationResolved
        {
            get
            {
				return this.GetAllowCellVirtualizationResolved(null);
            }
        }

                #endregion //AllowCellVirtualizationResolved

                // JJD 2/7/08 - BR30444 - added
                #region AllowLabelVirtualizationResolved

		/// <summary>
		/// Determines if the LabelPresenter creation will be deferred until the label is brought into view (read-only).
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b> even if this property is resolved to true it is possible that it will be ignored in certain conditions where the labels cannot be virtually allocated.</p>
		/// </remarks>
		/// <seealso cref="FieldSettings.AllowLabelVirtualization"/>
        /// <seealso cref="FieldSettings.AllowLabelVirtualizationProperty"/>
		/// <seealso cref="FieldSettings"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
 		[Bindable(true)]
		[ReadOnly(true)]
		public bool AllowLabelVirtualizationResolved
        {
            get
            {
                DataPresenterBase layoutOwner = null;
                if (this._owner != null)
                    layoutOwner = this._owner.DataPresenter;

                // JJD 10/02/08
                // In reports we don't need to virtualize cells
                if (layoutOwner != null && layoutOwner.IsReportControl)
                    return false;

                bool? allowLabelVirtualization = null;

                if (this._settings != null)
                    allowLabelVirtualization = this._settings.AllowLabelVirtualization;

                if (allowLabelVirtualization == null && this._owner != null)
                {
                    if (this._owner.HasFieldSettings)
                    {
                        // get the Field layout settings
                        allowLabelVirtualization = this._owner.FieldSettings.AllowLabelVirtualization;
                    }

                    if (allowLabelVirtualization == null && layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        // get the DataPresenterBase setting
                        allowLabelVirtualization = layoutOwner.FieldSettings.AllowLabelVirtualization;
                    }
                }

                // if the value was set explicitly to false then return false
                if (allowLabelVirtualization.HasValue && allowLabelVirtualization.Value == false)
                    return false;

                
#region Infragistics Source Cleanup (Region)









#endregion // Infragistics Source Cleanup (Region)


				if (this._cachedLabel == null)
					// JM 10-30-08 TFS9834, TFS9835
					//return true;
					return false;

                
#region Infragistics Source Cleanup (Region)





#endregion // Infragistics Source Cleanup (Region)


				// JM 10-30-08 TFS9834, TFS9835
				if (this.HasSettings)
				{
					FieldSettings fieldSettings = this.Settings;

					if (fieldSettings.LabelPresenterStyle			!= null ||
						fieldSettings.LabelPresenterStyleSelector	!= null ||
						fieldSettings.CellContentAlignment			== CellContentAlignment.ValueOnly)
						return false;

				}

				// JJD 2/7/08 - BR30444 
				// If the label is a string then only return true if we aren't wrapping the text
				// JM 10-30-08 TFS9834, TFS9835
				//if (this._cachedLabel is string &&
				if (this._cachedLabel is string && string.IsNullOrEmpty((string)this._cachedLabel) == false &&
					this.LabelTextWrappingResolved == TextWrapping.NoWrap)
					return true;

                return false;
            }
        }

                #endregion //AllowLabelVirtualizationResolved

                #region AllowEditResolved

		/// <summary>
		/// Determines if the user can edit a cell (read-only).
		/// </summary>
		/// <remarks>This property is resolved to true it will be ignored if the <see cref="DataPresenterBase.DataSource"/> does not support editing.</remarks>
		/// <seealso cref="FieldSettings.AllowEdit"/>
        /// <seealso cref="FieldSettings.AllowEditProperty"/>
		/// <seealso cref="FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="FieldLayoutSettings.AllowDelete"/>
		/// <seealso cref="FieldSettings"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
 		[Bindable(true)]
		[ReadOnly(true)]
		public bool AllowEditResolved
        {
            get
            {
				// SSP 9/30/11 Calc
				// 
				if ( this.HasFormula )
					return false;

                Nullable<bool> allowEdit = new Nullable<bool>();
                
                if ( this._settings != null)
                    allowEdit = this._settings.AllowEdit;

                if (allowEdit.HasValue)
                    return allowEdit.Value;

                if (this._owner != null)
                {

                    DataPresenterBase layoutOwner = this._owner.DataPresenter;

                    if (this._owner.HasFieldSettings)
                    {
                        // get the Field layout settings
                        allowEdit = this._owner.FieldSettings.AllowEdit;

                        if (allowEdit.HasValue)
                            return allowEdit.Value;
                    }

                    // JJD 12/13/07
                    // If the fieldlayout wraps an enumerable object then return false
                    // because we don't wnat to allow editing by default regardless
                    // of the defalut settings on the control
                    if (this._owner.WrapsEnumerableObject)
                        return false;

                    if (null != layoutOwner && layoutOwner.HasFieldSettings)
                    {
                        // get the DataPresenterBase setting
                        allowEdit = layoutOwner.FieldSettings.AllowEdit;

                        if (allowEdit.HasValue)
                            return allowEdit.Value;
                    }
                }

                return true;
            }
        }

                #endregion //AllowEditResolved

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region AllowFixingResolved

        /// <summary>
		/// Returns the resolved value indicating whether a field's <see cref="Field.FixedLocation"/> may be changed and to which edge the field may be fixed.
		/// </summary>
        /// <seealso cref="FieldSettings.AllowFixing"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.AllowFieldFixing"/>
        /// <seealso cref="FieldLayoutSettings.FixedFieldUIType"/>
        /// <seealso cref="Field.FixedLocation"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
        public AllowFieldFixing AllowFixingResolved
        {
            get
            {
                AllowFieldFixing allowResize = AllowFieldFixing.Default;

                DataPresenterBase dp = this.DataPresenter;

                if (null != dp && dp.IsFixedFieldsSupportedResolved)
                {
                    if (this._settings != null)
                        allowResize = this._settings.AllowFixing;

                    if (AllowFieldFixing.Default == allowResize && this._owner != null)
                        allowResize = this._owner.GetDefaultAllowFieldFixing(this);
                }

                return AllowFieldFixing.Default == allowResize ? AllowFieldFixing.No : allowResize;
            }
        }

                #endregion //AllowFixingResolved

                #region AllowGroupByResolved

        /// <summary>
        /// Determines if the user can initiate a group by operation thru the UI for this <see cref="Field"/> (read-only).
        /// </summary>
        /// <seealso cref="FieldSettings.AllowGroupBy"/>
        /// <seealso cref="FieldSettings.AllowGroupByProperty"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyle"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyleSelector"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByArea"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaLocation"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaStyle"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
        //[Description("Determines if the user can initiate a group by operation thru the UI for this field (read-only).")]
		[Bindable(true)]
		[ReadOnly(true)]
		public bool AllowGroupByResolved
        {
            get
            {
				Nullable<bool> allowGroupBy = new Nullable<bool>( );

				if ( this._settings != null )
					allowGroupBy = this._settings.AllowGroupBy;

				// SSP 2/3/12 NAS12.1 External Sorting/Filtering/Grouping/Summaries
				// Refactored so we can disable grouping on unbound fields if group evaluation mode is
				// to use collection view.
				// 
				
				if ( ! allowGroupBy.HasValue && this._owner != null )
				{
					// JJD 8/19/09 - NA 2009 Vol 2 - Cross Band grouping
					
					// Pass null in as the default value so we will return true or false
					// based on the data type
					//return this._owner.GetDefaultAllowGroupBy(this);
					allowGroupBy = this._owner.GetDefaultAllowGroupBy( this, null );
				}

				if ( ! allowGroupBy.HasValue )
					allowGroupBy = true;

				// If we are using collection view to group records, disallow grouping on unbound fields.
				// 
				if ( allowGroupBy.Value && null != _owner && this.IsUnbound 
					&& GroupByEvaluationMode.UseCollectionView == _owner.GroupByEvaluationModeResolvedDefault )
				{
					allowGroupBy = false;
				}

				return allowGroupBy.Value;
				
#region Infragistics Source Cleanup (Region)












#endregion // Infragistics Source Cleanup (Region)

				
            }
        }

                #endregion //AllowGroupByResolved

				#region AllowHidingResolved

		
		

		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.AllowHiding"/> property.
		/// </summary>
		/// <seealso cref="FieldSettings.AllowHiding"/>
		/// <seealso cref="FieldChooser"/>
		public AllowFieldHiding AllowHidingResolved
		{
			get
			{
				AllowFieldHiding allowHiding = GetResolvedValue<AllowFieldHiding>( FieldSettings.AllowHidingProperty, AllowFieldHiding.Default, AllowFieldHiding.Default );

				if ( AllowFieldHiding.Default == allowHiding )
					allowHiding = null != _owner && _owner.IsFieldChooserUIEnabled
						? AllowFieldHiding.Always
						: AllowFieldHiding.ViaFieldChooserOnly;

				return allowHiding;
			}
		}

				#endregion // AllowHidingResolved

				#region AllowRecordFilteringResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.AllowRecordFiltering"/> property.
		/// </summary>
		/// <remarks>
		/// <b>AllowRecordFilteringResolved</b> returns the resolved value of the <see cref="FieldSettings.AllowRecordFiltering"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public bool AllowRecordFilteringResolved
		{
			get
			{
                // JJD 1/20/9 - NA 2009 vol 1 - Filtering in reports
                DataPresenterBase dp = this._owner != null ? this._owner.DataPresenter : null;
                if (dp != null && dp.IsReportControl )
                     return false;

				// SSP 2/21/12 NAS12.1 External Sorting/Filtering/Grouping/Summaries
				// If FilterEvaluationMode is to use collection view then disable filtering on unbound fields.
				// 
				if ( this.IsUnbound && null != _owner 
					&& FilterEvaluationMode.UseCollectionView == _owner.FilterEvaluationModeResolved )
					return false;

                bool? ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.AllowRecordFiltering;
					if ( ret.HasValue )
						return ret.Value;
				}

				if ( null != _owner )
				{
					// SSP 9/8/09 TFS21710
					// Moved the existing code into the new AllowRecordFilteringResolvedDefault method.
					// 
					return _owner.AllowRecordFilteringResolvedDefault;
				}

				// Resolve default to false.
				// 
				return false;
			}
		}

				#endregion // AllowRecordFilteringResolved

                #region AllowResizeResolved

        /// <summary>
		/// Determines if the user can resize a cell or label in a <see cref="Field"/>
		/// </summary>
        /// <seealso cref="FieldSettings.AllowResize"/>
        /// <seealso cref="FieldSettings.AllowResizeProperty"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldLayoutSettings.DataRecordSizingMode"/>
        /// <seealso cref="FieldLayoutSettings.ResizingMode"/>
		/// <remarks>
		/// <para>
		/// In <see cref="XamDataGrid"/> with <see cref="GridViewSettings.Orientation"/> set to Horizontal, this property governs row sizing. Otherwise it governs column resizing.
		/// </para>
		/// </remarks>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		//[Description("Determines if the user can resize a cell or label in a  field (read-only).")]
		[Bindable(true)]
		[ReadOnly(true)]
		public bool AllowResizeResolved
        {
            get
            {
                Nullable<bool> allowResize = new Nullable<bool>();
                
                if ( this._settings != null)
                    allowResize = this._settings.AllowResize;

                if (allowResize.HasValue)
                    return allowResize.Value;

                if (this._owner != null)
                {
                    return this._owner.GetDefaultAllowResize(this);
                }

                return true;
            }
        }

                #endregion //AllowResizeResolved

				#region AllowSummariesResolved

		
		
		/// <summary>
		/// Determines if the summary calculation selection UI is enabled for the user to select one or more
		/// summary calculations to perform on field values (read-only).
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>AllowSummariesResolved</b> returns the resolved value based on FieldSettings'
		/// <see cref="FieldSettings.AllowSummaries"/> property settings. <see cref="FieldSettings"/>
		/// object is exposed on <b>Field</b> (<see cref="DataPresenterBase.FieldSettings"/>), 
		/// FieldLayout (<see cref="FieldLayout.FieldSettings"/>) and Field (<see cref="Field.Settings"/>).
		/// </para>
		/// <para class="body">
		/// To actually set whether summaries are allowed, use the FieldSettings' 
		/// <see cref="FieldSettings.AllowSummaries"/> and <see cref="FieldSettings.SummaryUIType"/> properties.
		/// </para>
		/// <para class="body">
		/// To specify summary calculations to perform, use the FieldLayout's 
		/// <seealso cref="FieldLayout.SummaryDefinitions"/> property.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldSettings.AllowSummaries"/>
		/// <seealso cref="FieldSettings.SummaryUIType"/>
		/// <seealso cref="FieldLayout.SummaryDefinitions"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable( false )]
		//[Description("Determines if the summary calculation selection UI is enabled (read-only).")]
		[Bindable( true )]
		[ReadOnly( true )]
		public bool AllowSummariesResolved
		{
			get
			{
				// Disable summaries ui in carousel view.
				// 
				DataPresenterBase dp = this.DataPresenter;
				ViewBase view = null != dp ? dp.CurrentViewInternal : null;
				if ( null != view && ! view.IsSummaryRecordSupported )
					return false;

				if ( null != _settings )
				{
					bool? ret = _settings.AllowSummaries;
					if ( ret.HasValue )
						return ret.Value;
				}

				if ( null != _owner )
					return _owner.GetDefaultAllowSummaries( this );

				return true;
			}
		}

				#endregion // AllowSummariesResolved

				#region AutoGenerated

		/// <summary>
		/// Returns true if this <see cref="Field"/> was automatically generated (read-only).
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamData_Assigning_a_FieldLayout.html">Assigning a FieldLayout</a> topic in the Developer's Guide for an explanantion of the auot generation process.</p>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayout.AutoGenerateFieldsResolved"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		//[Description("Returns true if this field was automatically generated (read-only).")]
		[Bindable(true)]
		[ReadOnly(true)]
		public bool AutoGenerated { get { return this._autoGenerated; } }

				#endregion //AutoGenerated	

				#region CalculationSettings


		/// <summary>
		/// Identifies the <see cref="CalculationSettings"/> dependency property
		/// </summary>
		[InfragisticsFeature(FeatureName = "XamCalculationManager", Version = "11.2")]
		public static readonly DependencyProperty CalculationSettingsProperty = DependencyProperty.Register("CalculationSettings",
			typeof(FieldCalculationSettings), typeof(Field), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnCalculationSettingsChanged)));

		private static void OnCalculationSettingsChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			Field fld = target as Field;

			fld._calculationSettings = e.NewValue as FieldCalculationSettings;

		}

		private FieldCalculationSettings _calculationSettings;

		/// <summary>
		/// Get/sets the calculation settings related to this field. This information is used for exposing cell data to a XamCalculationManager's network.
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note: </b> this property will be ignored unless <see cref="DataPresenterBase"/>'s  <see cref="DataPresenterBase.CalculationAdapter"/> is set.</para>
		/// </remarks>
		/// <seealso cref="CalculationSettingsProperty"/>
		/// <seealso cref="DataPresenterBase.CalculationAdapter"/>
		/// <seealso cref="SummaryDefinition.CalculationSettings"/>
		//[Description("Get/sets the calculation settings related to this field.")]
		//[Category("Behavior")]
		[InfragisticsFeature(FeatureName = "XamCalculationManager", Version = "11.2")]
		public FieldCalculationSettings CalculationSettings
		{
			get
			{
				return _calculationSettings;
			}
			set
			{
				this.SetValue(Field.CalculationSettingsProperty, value);
			}
		}

				#endregion //CalculationSettings

                #region CellClickActionResolved

        /// <summary>
        /// Gets the resolved relative clickAction of the cell to its field (read-only)
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public CellClickAction CellClickActionResolved
        {
            get
            {
                CellClickAction clickAction = CellClickAction.Default;

                if (this._settings != null)
                    clickAction = this._settings.CellClickAction;

                if (clickAction != CellClickAction.Default)
                    return clickAction;

                if (this._owner != null)
                    return this._owner.GetDefaultCellClickAction(this);

				return Field.DefaultCellClickAction;
            }
        }

                #endregion //CellClickAction

                #region CellContentAlignmentResolved

        /// <summary>
        /// Gets the resolved relative position of the label to its field (read-only)
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public CellContentAlignment CellContentAlignmentResolved
        {
            get
            {
				// AS 8/25/11 TFS84612
				//CellContentAlignment position = CellContentAlignment.Default;
				//
				//if (this._settings != null)
				//    position = this._settings.CellContentAlignment;
				//
				//if (position != CellContentAlignment.Default)
				//    return position;
				//
				//if (this._owner != null)
				//    return this._owner.GetDefaultCellContentAlignment(this);
				//
				//return CellContentAlignment.LabelAboveValueStretch;
				if (_cachedCellContentAlignmentResolved == null)
				{
					CellContentAlignment position = CellContentAlignment.Default;

					if (this._settings != null)
						position = this._settings.CellContentAlignment;

					if (position == CellContentAlignment.Default)
					{
						if (this._owner != null)
							position = this._owner.GetDefaultCellContentAlignment(this);
						else
							position = CellContentAlignment.LabelAboveValueStretch;
					}

					_cachedCellContentAlignmentResolved = position;
				}

				return _cachedCellContentAlignmentResolved.Value;
            }
        }

                #endregion //CellContentAlignment

                #region CellHeightResolved

        /// <summary>
        /// The resolved height for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellHeightResolved
        {
            get
            {
				// AS 12/14/07 BR25223
				// Get the width from the template cell.
				//
				if (this._owner != null)
				{
					Size size = VirtualizingDataRecordCellPanel.GetTemplateItemSize(this, false);

					double maxHeight = this.CellMaxHeightResolved;

					// constrain the width to its max since that is what
					// the cell element itself would do
					if (double.IsNaN(maxHeight) == false &&
						size.Height > maxHeight)
					{
						size.Height = maxHeight;
					}

					return size.Height;
				}
					
				return this.CellHeightResolvedInternal;
			}
		}

		// AS 12/14/07 BR25223
		// Changed what was the public CellWidthResolved to an internal. We need to 
		// always get a value based on the CellWidth properties but customers want to 
		// know what the actual width is.
		//
		/// <summary>
		/// Returns a resolved value based on the <see cref="FieldSettings.CellWidth"/>
		/// </summary>
		internal double CellHeightResolvedInternal
		{
			get
			{
				double value = this.GetCellHeightResolvedHelper(false);
                if (!double.IsNaN(value))
                    return value;

                if (this._cellPosition.RowSpan > 1)
                    return double.NaN;

                FieldLayout fl = this.Owner;

				bool sizeToContent = true;

				if (fl != null)
				{
					// in horizonatl gridview the height is never sized to content
					if (fl.IsHorizontal)
						sizeToContent = false;
					else
						sizeToContent = fl.IsDataRecordSizedToContent;
				}

				if (sizeToContent == true)
					return double.NaN;

                value = this.GetLabelHeightResolvedHelper(false, false);
                if (!double.IsNaN(value))
                    return value;

				return this.DefaultCellHeight;
            }
        }

		internal double GetCellHeightResolvedHelper(bool provideDefault)
		{
			// SSP 8/29/08 BR35923
			// 
			// AS 7/30/09 NA 2009.2 Field Sizing
			//if ( null != _explicitResizeInfo && !double.IsNaN( _explicitResizeInfo.CellHeight ) )
			FieldSize size = this.GetResizeSize(false, false);

			if (size.HasExplicitSize)
			{
				ViewBase view = GridUtilities.GetView( this );
				Orientation logicalOrientation = null != view ? view.LogicalOrientation : Orientation.Vertical;

				// Explicit resize cell width is only applicable in vertical orientation.
				// 
                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                // We are using this when synchronized to store the shared record height
                // so we do want to use it in that case when in a vertical orientation.
                //
				//if ( Orientation.Horizontal == logicalOrientation )
				if ( Orientation.Horizontal == logicalOrientation ||
                    (this._owner != null && this._owner.DataRecordSizingModeResolved == DataRecordSizingMode.SizableSynchronized))
					// AS 7/30/09 NA 2009.2 Field Sizing
					//return _explicitResizeInfo.CellHeight;
					return size.Value;
			}

			// AS 6/24/09 NA 2009.2 Field Sizing
			FieldLength len = this.GetWidthOrHeight(false);

			if (len.IsAbsolute)
				return len.Value;

			// if we're in auto mode and we have an auto size...
			if (len.IsAnyAuto && size.HasAutoModeSize)
				return size.Value;

			double value = double.NaN;

            if (this._settings != null)
            {
                value = this._settings.CellHeight;

                if (!double.IsNaN(value))
                    return value;
            }

            FieldLayout fl = this.Owner;

            if (fl != null)
            {
                if (fl.HasFieldSettings)
                {
                    value = fl.FieldSettings.CellHeight;

                    if (!double.IsNaN(value))
                        return value;
                }

                DataPresenterBase layoutOwner = fl.DataPresenter;

                if (layoutOwner != null && layoutOwner.HasFieldSettings)
                {
                    value = layoutOwner.FieldSettings.CellHeight;

                    if (!double.IsNaN(value))
                        return value;
                }
            }

			if (provideDefault)
				return this.DefaultCellHeight;

            return double.NaN;
        }

                #endregion //CellHeightResolved

                #region CellMaxHeightResolved

        /// <summary>
        /// The resolved maximum height for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellMaxHeightResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.CellMaxHeight;

                    if (!double.IsNaN(value))
                        return value;
                }


                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.CellMaxHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.CellMaxHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }
    
                return double.PositiveInfinity;
            }
        }

                #endregion //CellMaxHeightResolved

                #region CellMaxWidthResolved

        /// <summary>
        /// The resolved maximum width for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellMaxWidthResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.CellMaxWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.CellMaxWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.CellMaxWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return double.PositiveInfinity;
            }
        }

                #endregion //CellMaxWidthResolved

                #region CellMinHeightResolved

        /// <summary>
        /// The resolved minimum height for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellMinHeightResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.CellMinHeight;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.CellMinHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.CellMinHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return 0.0d;
            }
        }

                    #endregion //CellMinHeightResolved

                #region CellMinWidthResolved

        /// <summary>
        /// The resolved minimum width for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellMinWidthResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.CellMinWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.CellMinWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.CellMinWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return 0.0d;
            }
        }

                #endregion //CellMinWidthResolved

                #region CellWidthResolved

        /// <summary>
        /// The resolved width for this field's cells in device-independent units (1/96th inch per unit)
        /// </summary>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double CellWidthResolved
		{
			get
			{
				// AS 12/14/07 BR25223
				// Get the width from the template cell.
				//
				if (this._owner != null)
				{
					Size size = VirtualizingDataRecordCellPanel.GetTemplateItemSize(this, false);

					double maxWidth = this.CellMaxWidthResolved;

					// constrain the width to its max since that is what
					// the cell element itself would do
					if (double.IsNaN(maxWidth) == false &&
						size.Width > maxWidth)
					{
						size.Width = maxWidth;
					}

					return size.Width;
				}
					
				return this.CellWidthResolvedInternal;
			}
		}

		// AS 12/14/07 BR25223
		// Changed what was the public CellWidthResolved to an internal. We need to 
		// always get a value based on the CellWidth properties but customers want to 
		// know what the actual width is.
		//
		/// <summary>
		/// Returns a resolved value based on the <see cref="FieldSettings.CellWidth"/>
		/// </summary>
		internal double CellWidthResolvedInternal
        {
            get
            {
                double value = this.GetCellWidthResolvedHelper(false);
                if (!double.IsNaN(value))
                    return value;

                if (this._cellPosition.ColumnSpan > 1)
                    return double.NaN;

                FieldLayout fl = this.Owner;

				bool sizeToContent = true;

				if (fl != null)
				{
					// in vertical layout the width is never sized to content
					if (!fl.IsHorizontal)
						sizeToContent = false;
					else
						sizeToContent = fl.IsDataRecordSizedToContent;
				}

				if (sizeToContent == true)
					return double.NaN;

                value = this.GetLabelWidthResolvedHelper(false, false);
                if (!double.IsNaN(value))
                    return value;

				return this.DefaultCellWidth;
            }
        }

		internal double GetCellWidthResolvedHelper(bool provideDefault)
		{
			// SSP 8/29/08 BR35923
			// Removed ExplicitResizeExtent and instead added ExplicitResizeInfo.
			// 
			// JM 08-04-08 Load/Save Customizations			
			//if ( double.IsNaN( this.ExplicitResizeExtent ) == false )
			//	return this.ExplicitResizeExtent;
			// AS 7/30/09 NA 2009.2 Field Sizing
			//if ( null != _explicitResizeInfo && !double.IsNaN( _explicitResizeInfo.CellWidth ) )
			FieldSize size = this.GetResizeSize(false, true);

			if (size.HasExplicitSize)
			{
				ViewBase view = GridUtilities.GetView( this );
				Orientation logicalOrientation = null != view ? view.LogicalOrientation : Orientation.Vertical;
				
				// Explicit resize cell width is only applicable in vertical orientation.
				// 
                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                // We are using this when synchronized to store the shared record height
                // so we do want to use it in that case when in a vertical orientation.
                //
                //if (Orientation.Vertical == logicalOrientation)
				if (Orientation.Vertical == logicalOrientation ||
					(this._owner != null && this._owner.DataRecordSizingModeResolved == DataRecordSizingMode.SizableSynchronized))
					// AS 7/30/09 NA 2009.2 Field Sizing
					//return _explicitResizeInfo.CellWidth;
					return size.Value;
			}

			// AS 6/24/09 NA 2009.2 Field Sizing
			FieldLength len = this.GetWidthOrHeight(true);

			if (len.IsAbsolute)
				return len.Value;

			// if we're in auto mode and we have an auto size...
			if (len.IsAnyAuto && size.HasAutoModeSize)
				return size.Value;

			double value = double.NaN;

            if (this._settings != null)
            {
                value = this._settings.CellWidth;

                if (!double.IsNaN(value))
                    return value;
            }

            FieldLayout fl = this.Owner;

            if (fl != null)
            {
                if (fl.HasFieldSettings)
                {
                    value = fl.FieldSettings.CellWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                DataPresenterBase layoutOwner = fl.DataPresenter;

                if (layoutOwner != null && layoutOwner.HasFieldSettings)
                {
                    value = layoutOwner.FieldSettings.CellWidth;

                    if (!double.IsNaN(value))
                        return value;
                }
            }

			if (provideDefault)
				return this.DefaultCellWidth;

            return double.NaN;
        }

                #endregion //CellWidthResolved

				// JM 10/09 10.1 Added - CardView.
				#region CollapseWhenEmptyResolved

		/// <summary>
		/// Returns/sets whether Views that support the collapsing of cells should collapse cells associated with this Field when the cells contain empty values (e.g. empty string/null for string, null for nullable types, and 0 for numeric types).
		/// </summary>
		/// <seealso cref="FieldSettings.CollapseWhenEmpty"/>
		/// <seealso cref="FieldSettings.CollapseWhenEmptyProperty"/>
		/// <seealso cref="FieldSettings"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		[InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_CardView, Version = FeatureInfo.Version_10_1)]
		public bool CollapseWhenEmptyResolved
		{
			get
			{
				return this.GetResolvedValue<bool?>(FieldSettings.CollapseWhenEmptyProperty, null, true).Value;
			}
		}

				#endregion //CollapseWhenEmptyResolved

                #region Column

        /// <summary>
        /// Identifies the <see cref="Column"/> dependency property
        /// </summary>
		public static readonly DependencyProperty ColumnProperty = DependencyProperty.Register("Column",
				// JJD 7/19/07 - BR24928
				// Added change method to regen styles on a row, column, rowspan, columnspan change 
//                typeof(int), typeof(Field), new FrameworkPropertyMetadata(0), new ValidateValueCallback(OnValidateRowColumnSetting));
               typeof(int), typeof(Field), new FrameworkPropertyMetadata(0, new PropertyChangedCallback(OnRowOrColumnChange)), new ValidateValueCallback(OnValidateRowColumnSetting));

        private static bool OnValidateRowColumnSetting(object value)
        {
            return (int)value >= 0;
        }

		// JJD 7/19/07 - BR24928
		// Added change method to regen styles on a row, column, rowspan, columnspan change 
        private static void OnRowOrColumnChange(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
			Field fld = target as Field;

			if (fld != null)
			{
				// JJD 7/19/07 - BR24928
				// Call the invalidate of the dp so the panels get refreshed
                if (fld._owner != null && fld._owner.DataPresenter != null && fld.VisibilityResolved != Visibility.Collapsed)
                {
                    // JJD 7/21/08 - BR34098 - Optimization
                    // Invalidate the generated styles asynchronously so that if alot of
                    // changes are made in a tight loop that only one invalidation will take place
                    //fld._owner.DataPresenter.InvalidateGeneratedStyles(true, false);

                    // JJD 10/30/08 - TFS7858
                    // Call the fieldlayout's PostDelayedInvalidation instead so we only invalidate
                    // the styles if we aren't in the the middle of initializing all the fields 
                    //fld._owner.DataPresenter.InvalidateGeneratedStylesAsync();
                    fld._owner.PostDelayedInvalidation();
                }

			}
        }

        /// <summary>
        /// The column in the grid in the <see cref="Owner"/>'s generated template and optionally its <see cref="FieldLayout.HeaderAreaTemplate"/> where this <see cref="Field"/>s cells and labels should be placed.
        /// </summary>
        /// <remarks>
        /// <para>
		/// This property is ignored if <see cref="AutoArrangeCells"/> does not resolve to 'Never'.
        /// </para>
        /// <para></para>
        /// <para>Note: In addition to the <see cref="Column"/> and <see cref="Row"/> properties, there are separate <see cref="ColumnSpan"/> and <see cref="RowSpan"/> properites. These settings determine that actual grid row and column for this Field's cells and labels.</para>
        /// </remarks>
        /// <seealso cref="ColumnProperty"/>
        /// <seealso cref="ColumnSpan"/>
        /// <seealso cref="RowSpan"/>
        /// <seealso cref="FieldLayout.HeaderAreaTemplate"/>
        /// <seealso cref="FieldSettings.CellContentAlignment"/>
        /// <seealso cref="CellContentAlignmentResolved"/>
        /// <seealso cref="Row"/>
		/// <seealso cref="ActualPosition"/>
        //[Description("The column in the grid where this field's cells and/or labels should be placed")]
		[Bindable(true)]
		public int Column
        {
            get
            {
                return (int)this.GetValue(Field.ColumnProperty);
            }
            set
            {
                this.SetValue(Field.ColumnProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="Column"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeColumn()
        {
            return this.Column > 0;
        }

		/// <summary>
		/// Resets the <see cref="Column"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetColumn()
		{
			this.ClearValue(ColumnProperty);
		}

                #endregion //Column

                #region ColumnSpan

        /// <summary>
        /// Identifies the <see cref="ColumnSpan"/> dependency property
        /// </summary>
        public static readonly DependencyProperty ColumnSpanProperty = DependencyProperty.Register("ColumnSpan",
			// JM 05-04-10 TFS24462 Remove ValidateValueCallback and add CoerceValueCallback
			// JJD 7/19/07 - BR24928
			// Added change method to regen styles on a row, column, rowspan, columnspan change 
			// Also changed default value to 1 and validate it isn't less thn 1 
			//typeof(int), typeof(Field), new FrameworkPropertyMetadata(-1));
                //typeof(int), typeof(Field), new FrameworkPropertyMetadata(1, new PropertyChangedCallback(OnRowOrColumnChange)), new ValidateValueCallback(ValidateRowColumnSpanSetting));
                typeof(int), typeof(Field), new FrameworkPropertyMetadata(1, new PropertyChangedCallback(OnRowOrColumnChange), new CoerceValueCallback(OnCoerceRowColumnSpan)));

		// JM 05-04-10 TFS24462 Remove ValidateValueCallback
		//// JJD 7/19/07 - BR24928
		//// Added validation method
		//private static bool ValidateRowColumnSpanSetting(object value)
		//{
		//    return (int)value >= 1;
		//}

		// JM 05-04-10 TFS24462 Add CoerceValueCallback
		private static object OnCoerceRowColumnSpan(DependencyObject target, object value)
		{
			return (int)value < 1 ? 1 : value;
		}

        /// <summary>
        /// Determines how many logical columns this <see cref="Field"/>'s cells span in the layout
        /// </summary>
        /// <remarks>
        /// <para>
		/// This property is ignored if <see cref="AutoArrangeCells"/> does not resolve to 'Never'.
        /// </para>
        /// <para></para>
		/// <para>Note: In addition to the <see cref="Column"/> and <see cref="Row"/> properties, there are separate <see cref="ColumnSpan"/> and <see cref="RowSpan"/> properites. These settings determine that actual grid row and column for this Field's cells and labels.</para>
		/// </remarks>
        /// <seealso cref="ColumnSpanProperty"/>
        /// <seealso cref="RowSpan"/>
        /// <seealso cref="Column"/>
        /// <seealso cref="FieldLayout.HeaderAreaTemplate"/>
        /// <seealso cref="FieldSettings.CellContentAlignment"/>
        /// <seealso cref="CellContentAlignmentResolved"/>
        /// <seealso cref="FieldLayoutSettings.AutoArrangePrimaryFieldReservation"/>
        /// <seealso cref="Row"/>
		/// <seealso cref="ActualPosition"/>
        //[Description("Determines how many logical columns this field's cells span in the layout")]
		[Bindable(true)]
		public int ColumnSpan
        {
            get
            {
                return (int)this.GetValue(Field.ColumnSpanProperty);
            }
            set
            {
                this.SetValue(Field.ColumnSpanProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="ColumnSpan"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeColumnSpan()
        {
            return this.ColumnSpan >= 0;
        }

		/// <summary>
		/// Resets the <see cref="ColumnSpan"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetColumnSpan()
		{
			this.ClearValue(ColumnSpanProperty);
		}

                #endregion //ColumnSpan

                // JJD 3/5/08 - Added
                #region Converter

        /// <summary>
        /// Identifies the <see cref="Converter"/> dependency property
        /// </summary>
        /// <seealso cref="Converter"/>
        /// <seealso cref="ConverterCulture"/>
        /// <seealso cref="ConverterParameter"/>
        /// <seealso cref="ConverterCultureProperty"/>
        /// <seealso cref="ConverterParameterProperty"/>
        public static readonly DependencyProperty ConverterProperty = DependencyProperty.Register("Converter",
            typeof(IValueConverter), typeof(Field), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnConverterChanged)));

        private static void OnConverterChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            Field fld = target as Field;

			if (fld != null)
			{
				fld._converter = e.NewValue as IValueConverter;
				
				// JJD 4/27/11 - TFS73888 
				// Call OnFieldConverterChanged so we can refresh the cell values asynchronously
				if (fld.DataPresenter != null)
					fld._owner.OnFieldConverterChanged(fld);
			}
        }

        /// <summary>
        /// Gets/sets a converter to use to convert the value of each cell represented by this Field
        /// </summary>
        /// <remarks>
        /// <para class="body">This object is used to convert a <see cref="Cell"/>'s <see cref="Cell.Value"/> from its 
        /// <see cref="DataType"/> to and from the <see cref="EditAsTypeResolved"/>. 
        /// The converted value can be accessed thru the cell's <see cref="Cell.ConvertedValue"/> property 
        /// or via the <see cref="DataRecord"/>'s <see cref="DataRecord.GetCellValue(Field, bool)"/> 
        /// and <see cref="DataRecord.SetCellValue(Field, object, bool)"/> methods.</para>
        /// <para class="body">To change this Field's EditAsType set its <see cref="Settings"/>.<see cref="FieldSettings.EditAsType"/> property.</para>
        /// <para class="note"><b>Note:</b> The converter's Convert and ConvertBack methods are called even if the Field's DataType matches its EditAsTypeResolved.</para>
        /// </remarks>
        /// <seealso cref="ConverterProperty"/>
        /// <seealso cref="ConverterCulture"/>
        /// <seealso cref="ConverterParameter"/>
        /// <seealso cref="Cell.ConvertedValue"/>
        /// <seealso cref="Cell.Value"/>
        /// <seealso cref="DataType"/>
        /// <seealso cref="EditAsTypeResolved"/>
        /// <seealso cref="FieldSettings.EditAsType"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataRecord.GetCellValue(Field, bool)"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataRecord.SetCellValue(Field, object, bool)"/>
        //[Description("Gets/sets a converter to use to convert the value of each cell represented by this Field")]
        //[Category("Data")]
        [Bindable(true)]
        public IValueConverter Converter
        {
            get
            {
                return this._converter;
            }
            set
            {
                this.SetValue(Field.ConverterProperty, value);
            }
        }

                #endregion //Converter

                // JJD 3/5/08 - Added
                #region ConverterCulture

        /// <summary>
        /// Identifies the <see cref="ConverterCulture"/> dependency property
        /// </summary>
        /// <seealso cref="ConverterCultureProperty"/>
        /// <seealso cref="Converter"/>
        /// <seealso cref="ConverterCulture"/>
        /// <seealso cref="ConverterParameter"/>
        /// <seealso cref="ConverterProperty"/>
        /// <seealso cref="ConverterParameterProperty"/>
        public static readonly DependencyProperty ConverterCultureProperty = DependencyProperty.Register("ConverterCulture",
            typeof(CultureInfo), typeof(Field), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnConverterCultureChanged)));

        // JJD 5/29/09 - TFS18063 - added
        private static void OnConverterCultureChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            Field fld = target as Field;

            if (fld != null)
            {
                fld._converterCulture = e.NewValue as CultureInfo;

                // JJD 4/26/10 - TFS30833
                // Access their ConverterCultureResolved property which will 
                // raise a PropertyCanged notificiation if appropriate
                if (fld.DataPresenter != null)
                {
                    CultureInfo ciResolved = fld.ConverterCultureResolved;

					// JJD 4/27/11 - TFS73888 
					// Call OnFieldConverterChanged so we can refresh the cell values asynchronously
					fld._owner.OnFieldConverterChanged(fld);
				}
            }
        }

        /// <summary>
        /// Gets/sets the culture to use with the Converter
        /// </summary>
        /// <seealso cref="ConverterCultureProperty"/>
        /// <seealso cref="Converter"/>
        /// <seealso cref="ConverterParameter"/>
        //[Description("Gets/sets the culture to use with the Converter")]
        //[Category("Data")]
        [Bindable(true)]
        [TypeConverter(typeof(CultureInfoIetfLanguageTagConverter))]
        public CultureInfo ConverterCulture
        {
            get
            {
                // JJD 5/29/09 - TFS18063 
                // Use the cached the converter culture
                //return (CultureInfo)this.GetValue(Field.ConverterCultureProperty);
                return this._converterCulture;
            }
            set
            {
                this.SetValue(Field.ConverterCultureProperty, value);
            }
        }

                #endregion //ConverterCulture

                // JJD 4/26/10 - TFS30833 - Made ConverterCultureResolved public
                #region ConverterCultureResolved

        /// <summary>
        /// Returns the resolved culture to use with the Converter
        /// </summary>
        /// <seealso cref="ConverterCultureProperty"/>
        [Browsable(false)]
        [ReadOnly(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public CultureInfo ConverterCultureResolved
        {
            get
            {
                // JJD 4/26/10 - TFS30833
                // use the new ConverterCultureResolvedImp helper
                CultureInfo ci = this.ConverterCultureResolvedImpl;

                if (ci != this._converterCultureResolved)
                {
                    CultureInfo oldValue = this._converterCultureResolved;

                    this._converterCultureResolved = ci;

                    // JJD 4/26/10 - TFS30833
                    // Raise the property changed event
                    if (oldValue != null)
                        this.RaisePropertyChangedEvent("ConverterCultureResolved");
                }

                return this._converterCultureResolved;
            }
        }

                #endregion //ConverterCultureResolved	

                // JJD 3/5/08 - Added
                #region ConverterParameter

        /// <summary>
        /// Identifies the <see cref="ConverterParameter"/> dependency property
        /// </summary>
        /// <seealso cref="ConverterParameterProperty"/>
        /// <seealso cref="ConverterParameter"/>
        /// <seealso cref="Converter"/>
        /// <seealso cref="ConverterCulture"/>
        /// <seealso cref="ConverterProperty"/>
        /// <seealso cref="ConverterCultureProperty"/>
        public static readonly DependencyProperty ConverterParameterProperty = DependencyProperty.Register("ConverterParameter",
			// JJD 4/27/11 - TFS73888 - added change callback
           // typeof(object), typeof(Field), new FrameworkPropertyMetadata(null));
			typeof(object), typeof(Field), new FrameworkPropertyMetadata(OnConverterParameterChanged));

		// JJD 4/27/11 - TFS73888 - added
		static private void OnConverterParameterChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
            Field fld = target as Field;

			if (fld != null)
			{
				fld._converterParameter = e.NewValue;

				// JJD 4/27/11 - TFS73888 
				// Call OnFieldConverterChanged so we can refresh the cell values asynchronously
				if (fld.DataPresenter != null)
					fld._owner.OnFieldConverterChanged(fld);
			}
		}


        /// <summary>
        /// Gets/sets a parameter to pass into the Converter's convert methods.
        /// </summary>
        /// <seealso cref="ConverterParameterProperty"/>
        /// <seealso cref="Converter"/>
        /// <seealso cref="ConverterCulture"/>
        //[Description("Gets/sets a parameter to pass into the Converter's convert methods.")]
        //[Category("Data")]
        [Bindable(true)]
        [Localizability(LocalizationCategory.NeverLocalize)]
        [Browsable(false)]
        public object ConverterParameter
        {
            get
            {
				// JJD 4/27/11 - TFS73888 
				// Use cached value instead
				//return (object)this.GetValue(Field.ConverterParameterProperty);
                return _converterParameter;
            }
            set
            {
                this.SetValue(Field.ConverterParameterProperty, value);
            }
        }

                #endregion //ConverterParameter

                #region DataType

        /// <summary>
        /// Identifies the <see cref="DataType"/> dependency property
        /// </summary>
        public static readonly DependencyProperty DataTypeProperty = DependencyProperty.Register("DataType",
            typeof(Type), typeof(Field), new FrameworkPropertyMetadata( DEFAULT_DATA_TYPE ), 
			new ValidateValueCallback( OnValidateDataType ) );

		private static bool OnValidateDataType( object value )
		{
			Type type = value as Type;
			return null != type;
		}


        /// <summary>
        /// The data type of the field
        /// </summary>
        /// <remarks>If the type is not string and it implements the IEnumerable interface then it will default to being expandable.</remarks>
        /// <seealso cref="DataTypeProperty"/>
        /// <seealso cref="IsExpandable"/>
        /// <seealso cref="IsExpandableResolved"/>
        //[Description("The data type of the field")]
		[Bindable(true)]
		public Type DataType
        {
            get
            {
                return this._cachedDataType;
            }
            set
            {
                this.SetValue(Field.DataTypeProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="DataType"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeDataType()
        {
			object defaultValue = DataTypeProperty.GetMetadata( this ).DefaultValue;
			return this._dataTypeExplicitySet && this._cachedDataType != (defaultValue as Type);
        }

                #endregion //DataType

				// JM 6/12/09 NA 2009.2 DataValueChangedEvent
                #region DataValueChangedHistoryLimitResolved

        /// <summary>
		/// Gets the resolved value of the <see cref="FieldSettings.DataValueChangedHistoryLimit"/> property for this <see cref="Field"/>. (read-only)
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public int DataValueChangedHistoryLimitResolved
        {
            get
            {
                
                
                
				
                if ( !_cachedDataValueChangedHistoryLimitResolved.HasValue )
                    _cachedDataValueChangedHistoryLimitResolved = this.GetResolvedValue<int?>( FieldSettings.DataValueChangedHistoryLimitProperty, null, 1 );

                return _cachedDataValueChangedHistoryLimitResolved.Value;
            }
        }

                #endregion //DataValueChangedHistoryLimitResolved

				// JM 6/12/09 NA 2009.2 DataValueChangedEvent
                #region DataValueChangedNotificationsActiveResolved

        /// <summary>
		/// Gets the resolved value of the <see cref="FieldSettings.DataValueChangedNotificationsActive"/> property for this <see cref="Field"/>. (read-only)
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public bool DataValueChangedNotificationsActiveResolved
        {
            get
            {
                
                
                
                
                if ( ! _cachedDataValueChangedNotificationsActiveResolved.HasValue )
                    _cachedDataValueChangedNotificationsActiveResolved = this.GetResolvedValue<bool?>( FieldSettings.DataValueChangedNotificationsActiveProperty, null, false );

                return _cachedDataValueChangedNotificationsActiveResolved.Value;
            }
        }

                #endregion //DataValueChangedNotificationsActiveResolved

				// JM 6/12/09 NA 2009.2 DataValueChangedEvent
                #region DataValueChangedScopeResolved

        /// <summary>
		/// Gets the resolved value of the <see cref="FieldSettings.DataValueChangedScope"/> property for this <see cref="Field"/>. (read-only)
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public DataValueChangedScope DataValueChangedScopeResolved
        {
            get
            {
				// JJD 3/13/11 - TFS67970 - Optimization
				// Cache the resolved changed scope value
				//return this.GetResolvedValue<DataValueChangedScope>(FieldSettings.DataValueChangedScopeProperty, DataValueChangedScope.Default, DataValueChangedScope.OnlyRecordsInView);
				if ( !_cachedDataValueChangedScopeResolved.HasValue )
					_cachedDataValueChangedScopeResolved = this.GetResolvedValue<DataValueChangedScope>(FieldSettings.DataValueChangedScopeProperty, DataValueChangedScope.Default, DataValueChangedScope.OnlyRecordsInView);

				return _cachedDataValueChangedScopeResolved.Value;
            }
        }

                #endregion //DataValueChangedScopeResolved

                // AS 4/8/09 NA 2009.2 ClipboardSupport
                #region DisallowModificationViaClipboard

        /// <summary>
        /// Identifies the <see cref="DisallowModificationViaClipboard"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty DisallowModificationViaClipboardProperty = DependencyProperty.Register("DisallowModificationViaClipboard",
            typeof(bool), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

        /// <summary>
        /// Returns or sets a value indicating whether clipboard operations that would attempt to modify the value of the cell should be skipped.
        /// </summary>
        /// <remarks>
        /// <p class="body"><b>DisallowModificationViaClipboard</b> specifies whether to ignore clipboard operations on 
        /// cells of this field and has a default value of false. If set to True, any clipboard operations that will 
        /// end up modifying the cell values will be ignored for the cells associated with this field. This is useful for 
        /// read-only or ID columns when you would typically not want to allow cutting/pasting on cells of such columns.</p>
        /// <p class="note"><b>Note</b> that operations that do not modify the values, such as Copy 
        /// operation, will still be allowed on the associated cells.</p>
        /// </remarks>
        /// <seealso cref="FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="DisallowModificationViaClipboardProperty"/>
        //[Description("Returns or sets a value indicating whether clipboard operations that would attempt to modify the value of the cell should be skipped.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public bool DisallowModificationViaClipboard
        {
            get
            {
                return (bool)this.GetValue(Field.DisallowModificationViaClipboardProperty);
            }
            set
            {
                this.SetValue(Field.DisallowModificationViaClipboardProperty, value);
            }
        }

                #endregion //DisallowModificationViaClipboard

                #region EditorTypeResolved

        /// <summary>
        /// Gets the resolved editor type for this field (read-only)
        /// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamData_Terms_Editors.html">Editors</a> topic in the Developer's Guide for an explanation of editors.</p>
		/// <p class="body">Refer to the <a href="xamData_Editing_Cell_Values.html">Editing Cell Values</a> topic in the Developer's Guide for an explanation of how editing works.</p>
		/// </remarks>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(false)]
		[ReadOnly(true)]
		public Type EditorTypeResolved
        {
            get
            {
                Type type = null;

                if (this._settings != null)
                    type = this._settings.EditorType;

                if (type != null)
                    return type;

                if (this._owner != null)
                {
					if ( this._owner.HasFieldSettings )
						type = this._owner.FieldSettings.EditorType;

					if (type != null)
						return type;

                    DataPresenterBase dp = this._owner.DataPresenter;

					if (dp != null && dp.HasFieldSettings)
						type = dp.FieldSettings.EditorType;

					if (type != null)
						return type;

                }

				Type editAsType = this.EditAsTypeResolved;

				if (editAsType == null)
					return null;

				return ValueEditor.GetDefaultEditorForType(editAsType);
            }
        }

                #endregion //EditorTypeResolved

				#region EditAsTypeResolved

		/// <summary>
		/// Gets the resolved edit-as-type for this field (read-only). This is the type that will be edited
		/// by the cell.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamData_Terms_Editors.html">Editors</a> topic in the Developer's Guide for an explanation of editors.</p>
		/// <p class="body">Refer to the <a href="xamData_Editing_Cell_Values.html">Editing Cell Values</a> topic in the Developer's Guide for an explanation of how editing works.</p>
		/// </remarks>
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		[Browsable( false )]
		[Bindable( false )]
		[ReadOnly( true )]
		public Type EditAsTypeResolved
		{
			get
			{
                // JJD 5/29/09 - TFS18063
                // Added caching logic for EditAsTypeResolved
                if (this._cachedEditAsTypeResolved == null)
                    this._cachedEditAsTypeResolved = this.GetEditAsTypeResolvedInternal();
 
                return this._cachedEditAsTypeResolved;
			}
		}

        // JJD 5/29/09 - TFS18063
        // Added caching logic for EditAsTypeResolved
        private Type GetEditAsTypeResolvedInternal()
        {
            Type type = null;

            if (this._settings != null)
                type = this._settings.EditAsType;

            if (null == type && this._owner != null)
            {
                if (this._owner.HasFieldSettings)
                    type = this._owner.FieldSettings.EditAsType;

                if (null == type)
                {
                    DataPresenterBase dp = this._owner.DataPresenter;

                    if (dp != null && dp.HasFieldSettings)
                        type = dp.FieldSettings.EditAsType;
                }
            }

            if (null == type)
                type = this.DataType;

            if (null == type)
                type = typeof(string);

            return type;
        }

				#endregion //EditorTypeResolved

				#region CellVisibilityWhenGroupedResolved

		// SSP 7/17/07 BR22919
		// Added CellVisibilityWhenGrouped property so you can hide the group-by fields when
		// the user groups records by them.
		// 
		/// <summary>
		/// Gets the resolved CellVisibilityWhenGrouped property value.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// Use the FieldSettings' <see cref="FieldSettings.CellVisibilityWhenGrouped"/> property to specify whether
		/// the cells of the field should be visible when records are grouped by it. <b>CellVisibilityWhenGroupedResolved</b>
		/// simply returns the resolved value of this property.
		/// </para>
		/// <seealso cref="FieldSettings.CellVisibilityWhenGrouped"/>
		/// </remarks>
		public Visibility CellVisibilityWhenGroupedResolved
		{
			get
			{
				// SSP 6/23/09 - NAS9.2 Field Chooser
				// This is used by the field chooser to force a field to be visible even if it's
				// a group-by field and CellVisibilityWhenGrouped is set to a value other than Visible.
				// 
				if ( _ignoreFieldVisibilityOverrides )
					return Visibility.Visible;

				Visibility? val = null;

				if ( this._settings != null )
					val = this._settings.CellVisibilityWhenGrouped;

				if ( null == val && this._owner != null )
				{
					if ( this._owner.HasFieldSettings )
						val = this._owner.FieldSettings.CellVisibilityWhenGrouped;

					if ( null == val )
					{
						DataPresenterBase dp = this._owner.DataPresenter;

						if ( dp != null && dp.HasFieldSettings )
							val = dp.FieldSettings.CellVisibilityWhenGrouped;
					}
				}

				return val ?? Visibility.Visible;
			}
		}

				#endregion // CellVisibilityWhenGroupedResolved

				#region ExpandableFieldRecordExpansionModeResolved

		/// <summary>
		/// Gets the resolved mode for how an <see cref="ExpandableFieldRecordPresenter"/> will be expanded (read-only).
		/// </summary>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.ExpandableFieldRecordExpansionMode"/>
		/// <seealso cref="FieldSettings.ExpandableFieldRecordExpansionMode"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public ExpandableFieldRecordExpansionMode ExpandableFieldRecordExpansionModeResolved
        {
            get
            {
                ExpandableFieldRecordExpansionMode displayMode = ExpandableFieldRecordExpansionMode.Default;

                if (this._settings != null)
                    displayMode = this._settings.ExpandableFieldRecordExpansionMode;

                if (displayMode != ExpandableFieldRecordExpansionMode.Default)
                    return displayMode;

                if (this._owner != null)
                    return this._owner.GetDefaultExpandableFieldRecordExpansionMode(this);

				return ExpandableFieldRecordExpansionMode.ShowExpansionIndicatorIfSiblingsExist;
            }
        }

                #endregion //ExpandableFieldRecordExpansionMode

                #region ExpandableFieldRecordHeaderDisplayModeResolved

		/// <summary>
		/// Gets the resolved mode for how an <see cref="ExpandableFieldRecordPresenter"/> will display a header (read-only).
		/// </summary>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.ExpandableFieldRecordHeaderDisplayMode"/>
		/// <seealso cref="FieldSettings.ExpandableFieldRecordHeaderDisplayMode"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public ExpandableFieldRecordHeaderDisplayMode ExpandableFieldRecordHeaderDisplayModeResolved
        {
            get
            {
                ExpandableFieldRecordHeaderDisplayMode displayMode = ExpandableFieldRecordHeaderDisplayMode.Default;

                if (this._settings != null)
                    displayMode = this._settings.ExpandableFieldRecordHeaderDisplayMode;

                if (displayMode != ExpandableFieldRecordHeaderDisplayMode.Default)
                    return displayMode;

                if (this._owner != null)
                    return this._owner.GetDefaultExpandableFieldRecordHeaderDisplayMode(this);

				return ExpandableFieldRecordHeaderDisplayMode.AlwaysDisplayHeader;
            }
        }

                #endregion //ExpandableFieldRecordHeaderDisplayMode

                // JJD 1/7/09 - NA 2009 vol 1 - record filtering
                #region FilterCellEditorStyleResolved

        /// <summary>
        /// Gets the resolved editor style for a filter cell for this field (read-only)
        /// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamData_Terms_Editors.html">Editors</a> topic in the Developer's Guide for an explanation of editors.</p>
		/// <p class="body">Refer to the <a href="xamData_Editing_Cell_Values.html">Editing Cell Values</a> topic in the Developer's Guide for an explanation of how editing works.</p>
		/// </remarks>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public Style FilterCellEditorStyleResolved
        {
            get
            {
				// SSP 3/24/10 TFS28668
				// When AllowRecordFiltering is set to false, we resolve the filter operand ui type to None,
				// which in turn causes us to resolve the filter cell editor type to XamTextEditor. If 
				// filter editor style is set to a style that targets different editor, like XamComboEditor,
				// then this will cause an exception when we try to apply that style to XamTextEditor. NOTE
				// that we don't actually display any filter cell when FilterOperandUIType is None. The 
				// exception happens during the time we are processing changes to go into a state where 
				// the filter record doesn't display the filter cell.
				//
				if ( FilterOperandUIType.None == this.FilterOperandUITypeResolved )
					return null;

                Style style = null;

                if (this._settings != null)
                    style = this._settings.FilterCellEditorStyle;

                if (style != null)
                    return style;

                if (this._owner != null)
                {
					if ( this._owner.HasFieldSettings )
						style = this._owner.FieldSettings.FilterCellEditorStyle;

					if (style != null)
						return style;

                    DataPresenterBase dp = this._owner.DataPresenter;

					if (dp != null && dp.HasFieldSettings)
						style = dp.FieldSettings.FilterCellEditorStyle;

					if (style != null)
						return style;

                }

                if (this.FilterOperandUITypeResolved == FilterOperandUIType.UseFieldEditor)
                    return this.EditorStyleResolved;

				return null;
            }
        }

                #endregion //FilterCellEditorStyleResolved

                // JJD 1/7/09 - NA 2009 vo 1 - record filtering
                #region FilterCellValuePresenterStyleResolved

        /// <summary>
        /// Gets the resolved style for a <see cref="FilterCellValuePresenter"/> for this field (read-only)
        /// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamData_Terms_Editors.html">Editors</a> topic in the Developer's Guide for an explanation of editors.</p>
		/// <p class="body">Refer to the <a href="xamData_Editing_Cell_Values.html">Editing Cell Values</a> topic in the Developer's Guide for an explanation of how editing works.</p>
		/// </remarks>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public Style FilterCellValuePresenterStyleResolved
        {
            get
            {
                Style style = null;

                if (this._settings != null)
                    style = this._settings.FilterCellValuePresenterStyle;

                if (style != null)
                    return style;

                if (this._owner != null)
                {
					if ( this._owner.HasFieldSettings )
						style = this._owner.FieldSettings.FilterCellValuePresenterStyle;

					if (style != null)
						return style;

                    DataPresenterBase dp = this._owner.DataPresenter;

					if (dp != null && dp.HasFieldSettings)
						style = dp.FieldSettings.FilterCellValuePresenterStyle;

					if (style != null)
						return style;

                }

				return null;
            }
        }

                #endregion //FilterCellValuePresenterStyleResolved

				#region FilterClearButtonVisibilityResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterClearButtonVisibility"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterClearButtonVisibilityResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterClearButtonVisibility"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterClearButtonVisibility"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public Visibility FilterClearButtonVisibilityResolved
		{
			get
			{
				Visibility? ret = null;
				
				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterClearButtonVisibility;
					if ( ret.HasValue )
						return ret.Value;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterClearButtonVisibility;
						if ( ret.HasValue )
							return ret.Value;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterClearButtonVisibility;
						if ( ret.HasValue )
							return ret.Value;
					}

					// If FilterClearButtonVisibility is not set, then use the FilterClearButtonLocation 
					// setting.
					// 
					FilterClearButtonLocation loc = _owner.FilterClearButtonLocationResolved;
					ret = FilterClearButtonLocation.FilterCell == loc || FilterClearButtonLocation.RecordSelectorAndFilterCell == loc
						? Visibility.Visible : Visibility.Collapsed;
				}

				// Resolve default to Visible.
				// 
				return ret.HasValue ? ret.Value : Visibility.Visible;
			}
		}

				#endregion // FilterClearButtonVisibilityResolved

				#region FilterEvaluationTriggerResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterEvaluationTrigger"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterEvaluationTriggerResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterEvaluationTrigger"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterEvaluationTrigger"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public FilterEvaluationTrigger FilterEvaluationTriggerResolved
		{
			get
			{
				FilterEvaluationTrigger ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterEvaluationTrigger;
					if ( FilterEvaluationTrigger.Default != ret )
						return ret;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterEvaluationTrigger;
						if ( FilterEvaluationTrigger.Default != ret )
							return ret;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterEvaluationTrigger;
						if ( FilterEvaluationTrigger.Default != ret )
							return ret;
					}
				}

				// Resolve default to OnCellValueChange.
				// 
				return FilterEvaluationTrigger.OnCellValueChange;
			}
		}

				#endregion // FilterEvaluationTriggerResolved

				#region FilterOperandUITypeResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterOperandUIType"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterOperandUITypeResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterOperandUIType"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterOperandUIType"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public FilterOperandUIType FilterOperandUITypeResolved
		{
			get
			{
                // JJD 2/10/09 - NA 2009 vol 1 - Record filtering
                // If the field doesn' allow record filtering then return 'None'. 
                if (this.AllowRecordFilteringResolved == false)
                    return FilterOperandUIType.None;

				FilterOperandUIType ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterOperandUIType;
					if ( FilterOperandUIType.Default != ret )
						return ret;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterOperandUIType;
						if ( FilterOperandUIType.Default != ret )
							return ret;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterOperandUIType;
						if ( FilterOperandUIType.Default != ret )
							return ret;
					}
				}

				// Resolve default based on the field's data type.
				// 
				this.VerifyRecordFilterRelatedCache( );
				return _cachedDefaultFilterOperandUIType;
			}
		}

				#endregion // FilterOperandUITypeResolved

				#region FilterOperatorDefaultValueResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterOperatorDefaultValue"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterOperatorDefaultValueResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterOperatorDefaultValue"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterOperatorDefaultValue"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public ComparisonOperator FilterOperatorDefaultValueResolved
		{
			get
			{
				ComparisonOperator? ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterOperatorDefaultValue;
					if ( ret.HasValue )
						return ret.Value;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterOperatorDefaultValue;
						if ( ret.HasValue )
							return ret.Value;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterOperatorDefaultValue;
						if ( ret.HasValue )
							return ret.Value;
					}
				}

				// Resolve default based on the field's data type.
				// 
				this.VerifyRecordFilterRelatedCache( );
				return _cachedDefaultFilterOperatorDefaultValue;
			}
		}

				#endregion // FilterOperatorDefaultValueResolved

				#region FilterOperatorDropDownItemsResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterOperatorDropDownItems"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterOperatorDropDownItemsResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterOperatorDropDownItems"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterOperatorDropDownItems"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public ComparisonOperatorFlags FilterOperatorDropDownItemsResolved
		{
			get
			{
				ComparisonOperatorFlags? ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterOperatorDropDownItems;
					if ( ret.HasValue )
						return ret.Value;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterOperatorDropDownItems;
						if ( ret.HasValue )
							return ret.Value;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterOperatorDropDownItems;
						if ( ret.HasValue )
							return ret.Value;
					}
				}

				// Resolve default based on the field's data type.
				// 
				this.VerifyRecordFilterRelatedCache( );
				return _cachedDefaultFilterOperatorDropDownItems;
			}
		}

				#endregion // FilterOperatorDropDownItemsResolved

				#region FilterOperatorVisibilityResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value indicating whether filter operator is visible in the filter cell associated with this field.
		/// </summary>
		/// <remarks>
		/// <b>FilterOperatorVisibilityResolved</b> returns the resolved value indicating whether filter operator is 
		/// visible in the filter cell associated with this field. Filter operator visibility is determined using various
		/// factors like how many operators are available for the user to choose, or what kind of operand ui type the filter
		/// cell makes use of. You can force the filter operator UI to be hidden by setting the 
		/// <see cref="FieldSettings.FilterOperatorDropDownItems"/> property to <b>None</b>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterOperatorDropDownItems"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public Visibility FilterOperatorVisibilityResolved
		{
			get
			{
				this.VerifyRecordFilterRelatedCache( );
				return _cachedDefaultFilterOperatorVisibility;
			}
		}

				#endregion // FilterOperatorVisibilityResolved

				#region FilterStringComparisonTypeResolved

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Gets the resolved value of <see cref="FieldSettings.FilterStringComparisonType"/> property.
		/// </summary>
		/// <remarks>
		/// <b>FilterStringComparisonTypeResolved</b> returns the resolved value of the <see cref="FieldSettings.FilterStringComparisonType"/> 
		/// property which can be set on the the DataPresenter's <see cref="DataPresenterBase.FieldSettings"/>
		/// or the FieldLayout's <see cref="FieldLayout.FieldSettings"/> or individual Field's <see cref="Field.Settings"/>.
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterStringComparisonType"/>
		/// <seealso cref="FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="FieldLayoutSettings.FilterUIType"/>
		public FieldSortComparisonType FilterStringComparisonTypeResolved
		{
			get
			{
				FieldSortComparisonType ret;

				// Use field's setting first.
				// 
				if ( null != _settings )
				{
					ret = _settings.FilterStringComparisonType;
					if ( FieldSortComparisonType.Default != ret )
						return ret;
				}

				if ( null != _owner )
				{
					// If field doesn't have it set, then use the field layout's setting.
					// 
					FieldSettings settings = _owner.FieldSettingsIfAllocated;
					if ( null != settings )
					{
						ret = settings.FilterStringComparisonType;
						if ( FieldSortComparisonType.Default != ret )
							return ret;
					}

					// If the field layout doesn't have it set then use the data presenter's setting.
					// 
					DataPresenterBase dp = _owner.DataPresenter;
					settings = null != dp ? dp.FieldSettingsIfAllocated : null;
					if ( null != settings )
					{
						ret = settings.FilterStringComparisonType;
						if ( FieldSortComparisonType.Default != ret )
							return ret;
					}
				}

				return FieldSortComparisonType.CaseInsensitive;
			}
		}

				#endregion // FilterStringComparisonTypeResolved

				#region FilterComparerResolved

		// SSP 5/3/10 TFS25788
		// 

		/// <summary>
		/// Property used for specifying a custom comparer used to compare values as part of the filtering logic.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>FilterComparer</b> specifies a comparer that is used to compare field values when evaluating
		/// record filter conditions.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that the field values are converted to type specified by 
		/// <see cref="FieldSettings.EditAsType"/> before performing comparisons.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldLayout.RecordFilters"/>
		/// <seealso cref="FieldSettings.SortComparer"/>
		/// <seealso cref="FieldSettings.EditAsType"/>
		public IComparer FilterComparerResolved
		{
			get
			{

				return this.GetResolvedValue<IComparer>( FieldSettings.FilterComparerProperty, null, null );
			}
		}

				#endregion // FilterComparerResolved

				#region FilterEvaluatorResolved

		// SSP 2/29/12 TFS89053
		// 

		/// <summary>
		/// Returns the resolved filter evaluator.
		/// </summary>
		/// <remarks>
		/// </remarks>
		/// <seealso cref="FieldSettings.FilterEvaluator"/>
		public IFilterEvaluator FilterEvaluatorResolved
		{
			get
			{

				return this.GetResolvedValue<IFilterEvaluator>( FieldSettings.FilterEvaluatorProperty, null, null );
			}
		}

				#endregion // FilterEvaluatorResolved

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region FixedButtonVisibility

        private static readonly DependencyPropertyKey FixedButtonVisibilityPropertyKey =
            DependencyProperty.RegisterReadOnly("FixedButtonVisibility",
            typeof(Visibility), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.VisibilityCollapsedBox));

        /// <summary>
        /// Identifies the <see cref="FixedButtonVisibility"/> dependency property
        /// </summary>
        public static readonly DependencyProperty FixedButtonVisibilityProperty =
            FixedButtonVisibilityPropertyKey.DependencyProperty;

        /// <summary>
        /// Returns a value indicating if the fixed button should be visibility for the field.
        /// </summary>
        /// <seealso cref="FixedButtonVisibilityProperty"/>
        //[Description("Returns a value indicating if the fixed button should be visibility for the field.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [ReadOnly(true)]
        public Visibility FixedButtonVisibility
        {
            get
            {
                return (Visibility)this.GetValue(Field.FixedButtonVisibilityProperty);
            }
        }

                #endregion //FixedButtonVisibility

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region FixedLocation

        /// <summary>
        /// Identifies the 'FixedLocation' dependency property
        /// </summary>
        public static readonly DependencyProperty FixedLocationProperty = DependencyProperty.Register("FixedLocation",
			typeof(FixedFieldLocation), typeof(Field), 
			new FrameworkPropertyMetadata(FixedFieldLocation.Scrollable,
				new PropertyChangedCallback( OnFixedLocationChanged )
				// AS 1/22/10 Coerce FixedLocation
				// In views that don't support fixed fields we should coerce the fixedlocation back to scrollable.
				// Otherwise the logic (esp the layout logic) may consider the field still fixed which causes 
				// problems when we packed the layout because we will move those items to the far/near edges.
				//
				, new CoerceValueCallback(CoerceFixedLocation)
			)
		);

		// AS 1/22/10 Coerce FixedLocation
		private static object FixedFieldLocationScrollable = FixedFieldLocation.Scrollable;
		private FixedFieldLocation _actualFixedLocation = FixedFieldLocation.Scrollable;

		// AS 1/22/10 Coerce FixedLocation
		private static object CoerceFixedLocation(DependencyObject d, object newValue)
		{
			Field f = d as Field;
			DataPresenterBase dp = f.DataPresenter;

			// we need to know what the actual fixed location is and not just
			// the coerced value for when we serialize
			f._actualFixedLocation = (FixedFieldLocation)newValue;

			if (dp != null && !dp.IsFixedFieldsSupportedResolved)
				return FixedFieldLocationScrollable;

			return newValue;
		}

		// AS 1/22/10 Coerce FixedLocation
		internal FixedFieldLocation ActualFixedLocation
		{
			get { return _actualFixedLocation; }
		}

		private static void OnFixedLocationChanged( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
        {




			Field field = (Field)dependencyObject;

			// AS 9/29/09 Optimization
			field._cachedFixedLocation = (FixedFieldLocation)e.NewValue;

			// AS 1/22/10 Coerce FixedLocation
			// If we get a clear then cache the default value.
			//
			if (field.ReadLocalValue(e.Property) == DependencyProperty.UnsetValue)
				field._actualFixedLocation = (FixedFieldLocation)e.Property.GetMetadata(field).DefaultValue;

            field.VerifyFixedState();
            FieldLayout fl = field._owner;

            if (null != fl)
            {
                fl.DirtyFixedState();
                
                DataPresenterBase dp = fl.DataPresenter;

                if (dp != null)
                {
                    if (!dp.IsApplyingCustomizations)
                    {
                        if (!fl.IsInFieldInitialization)
                        {
                            // make sure the snapshot has been created
                            fl.ShouldCreateDragFieldLayout = true;
                        }

                        // AS 3/3/09 Optimization
                        // Added if check so we can avoid the invalidation sometimes.
                        //
						if (!field.GetFlag(FieldFlags.SuppressFixedLocationInvalidate))
						{
							// AS 4/13/11 TFS69264
							//fl.PostDelayedInvalidation();
							fl.InvalidateGeneratedStylesAsnyc(false, false);
						}
                    }
                }
            }
		}

        /// <summary>
        /// Indicates whether the field should be fixed and if so to which edge.
        /// </summary>
        /// <seealso cref="FieldSettings.AllowFixing"/>
        /// <seealso cref="FieldLayoutSettings.FixedFieldUIType"/>
        //[Description("Indicates whether the field should be fixed and if so to which edge.")]
        //[Category("Behavior")]
		[Bindable(true)]
		public FixedFieldLocation FixedLocation
        {
            get
            {
				// AS 9/29/09 Optimization
				//return (FixedFieldLocation)this.GetValue(Field.FixedLocationProperty);
				return _cachedFixedLocation;
            }
            set
            {
                this.SetValue(Field.FixedLocationProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="FixedLocation"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeFixedLocation()
        {
            return Utilities.ShouldSerialize(FixedLocationProperty, this);
        }

		/// <summary>
		/// Resets the <see cref="FixedLocation"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetFixedLocation()
		{
			this.ClearValue(Field.FixedLocationProperty);
		}

                #endregion //FixedLocation

                #region GroupByComparerResolved

        /// <summary>
        /// Gets the resolved comparer to sort groups for this field, may return null.
        /// </summary>
        /// <remarks>
        /// <p>This IComparer instance will be used for sorting group-by records associated with this field if this field were a group-by field.</p>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/> <seealso cref="FieldSettings.SortComparer"/>
        /// </remarks>
        /// <seealso cref="FieldSettings.AllowGroupBy"/>
        /// <seealso cref="AllowGroupByResolved"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="Field.IsGroupBy"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyle"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyleSelector"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByArea"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaLocation"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaStyle"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[ReadOnly(true)]
		public IComparer GroupByComparerResolved
        {
            get
            {
                IComparer comparer = null;

                if ( this._settings != null )
                    comparer = this._settings.GroupByComparer;
                
                if (comparer != null)
                    return comparer;

                if (this._owner != null)
                {
                    if (this._owner.HasFieldSettings)
                    {
                        comparer = this._owner.FieldSettings.GroupByComparer;

                        if (comparer != null)
                            return comparer;
                    }

                    DataPresenterBase layoutOwner = this._owner.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        comparer = layoutOwner.FieldSettings.GroupByComparer;

                        if (comparer != null)
                            return comparer;
                    }
                }

                return null;
            }
        }

                #endregion //GroupByComparerResolved

                #region GroupByEvaluatorResolved

        /// <summary>
        /// Gets the resolved evaluator to group records by this field.
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[ReadOnly(true)]
		public IGroupByEvaluator GroupByEvaluatorResolved
        {
            get
            {
				// SSP 6/3/09 - TFS17233 - Optimization
				// Added caching. Moved the existing code into the new InternalGroupByEvaluatorResolved.
				// 
				if ( null == _cachedGroupByEvaluator )
					_cachedGroupByEvaluator = this.InternalGroupByEvaluatorResolved;

				return _cachedGroupByEvaluator;
            }
        }

		private IGroupByEvaluator InternalGroupByEvaluatorResolved
		{
			get
			{
				IGroupByEvaluator evaluator = null;

				if ( this._settings != null )
					evaluator = this._settings.GroupByEvaluator;

				if ( evaluator != null )
					return evaluator;

				if ( this._owner != null )
				{
					if ( this._owner.HasFieldSettings )
					{
						evaluator = this._owner.FieldSettings.GroupByEvaluator;

						if ( evaluator != null )
							return evaluator;
					}

					DataPresenterBase layoutOwner = this._owner.DataPresenter;

					if ( layoutOwner != null && layoutOwner.HasFieldSettings )
					{
						evaluator = layoutOwner.FieldSettings.GroupByEvaluator;

						if ( evaluator != null )
							return evaluator;
					}
				}

				return GroupByEvaluatorFactory.CreateEvaluator( this );
			}
		}

                #endregion //GroupByEvaluatorResolved

                #region GroupByModeResolved

        /// <summary>
        /// Gets the resolved mode for how <see cref="DataRecord"/>s are grouped.
        /// </summary>
        /// <remarks>If a <see cref="FieldSettings.GroupByComparer"/> is specified then this setting is ignored. Otherwise, an internal <see cref="IGroupByEvaluator"/> implementation will be supplied based on the <see cref="FieldGroupByMode"/> value.</remarks>
        /// <seealso cref="FieldSettings.AllowGroupBy"/>
        /// <seealso cref="Field.AllowGroupByResolved"/>
        /// <seealso cref="FieldGroupByMode"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="Field.IsGroupBy"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings.GroupByModeProperty"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyle"/>
        /// <seealso cref="FieldSettings.GroupByRecordPresenterStyleSelector"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByArea"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaLocation"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.GroupByAreaStyle"/>
        /// <seealso cref="IGroupByEvaluator"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public FieldGroupByMode GroupByModeResolved
        {
            get
            {
                FieldGroupByMode groupByMode = FieldGroupByMode.Default;

                if (this._settings != null)
                    groupByMode = this._settings.GroupByMode;

                if (groupByMode != FieldGroupByMode.Default)
                    return groupByMode;

                if (this._owner != null)
                {
                    if (this._owner.HasFieldSettings)
                    {
                        groupByMode = this._owner.FieldSettings.GroupByMode;

                        if (groupByMode != FieldGroupByMode.Default)
                            return groupByMode;
                    }

                    DataPresenterBase layoutOwner = this._owner.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        groupByMode = layoutOwner.FieldSettings.GroupByMode;

                        if (groupByMode != FieldGroupByMode.Default)
                            return groupByMode;
                    }
                }

                // JJD 4/17/08
                // check underlying data type instead
                //if ( this._cachedDataType == typeof(string))

                // JJD 5/29/09 - TFS18063
                // Use the resolved EditAsType and get its underlying type to determine the default mode
                //if (this._cachedDataTypeUnderlying == typeof(string))
                Type editAsType = this.EditAsTypeResolvedUnderlying;

                if (editAsType == typeof(string))
                    return FieldGroupByMode.Text;

                // JJD 4/17/08
                // check underlying data type instead
                //if (this._cachedDataType == typeof(DateTime))

                // JJD 5/29/09 - TFS18063
                // Use the resolved EditAsType to determine the default mode
                //if (this._cachedDataTypeUnderlying == typeof(DateTime))
                if (editAsType == typeof(DateTime))
                    return FieldGroupByMode.OutlookDate;

                return FieldGroupByMode.Value;
            }
        }

                #endregion //GroupByModeResolved

				// JJD 4/29/11 - TFS74075
                #region GroupByRecordPresenterStyleResolved

        /// <summary>
		/// Gets the resolved <see cref="GroupByRecordPresenter"/> style for the records that are generated when grouping by this field. (read-only)
        /// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b> this property can return null.</p>
		/// </remarks>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public Style GroupByRecordPresenterStyleResolved
        {
            get
            {
                Style style = null;

                if (this._settings != null)
                    style = this._settings.GroupByRecordPresenterStyle;

                if (style != null)
                    return style;

                if (this._owner != null)
                {
					if ( this._owner.HasFieldSettings )
						style = this._owner.FieldSettings.GroupByRecordPresenterStyle;

					if (style != null)
						return style;

                    DataPresenterBase dp = this._owner.DataPresenter;

					if (dp != null && dp.HasFieldSettings)
						style = dp.FieldSettings.GroupByRecordPresenterStyle;

					if (style != null)
						return style;

                }

				return null;
            }
        }

                #endregion //GroupByRecordPresenterStyleResolved

				// AS 5/31/07 BR22875
                #region HasLabel

        /// <summary>
        /// Returns true if <see cref="Label"/> property is set to a value other than null or an empty string.
        /// </summary>
		[ReadOnly(true)]
		[Browsable(false)]
		public bool HasLabel
        {
            get 
			{ 
				return this._cachedLabel != null && 
					(this._cachedLabel is string == false || ((string)this._cachedLabel).Length > 0); 
			}
        }

                #endregion //HasLabel	

                #region HasSettings

        /// <summary>
        /// Returns true if a settings object has been allocated (read-only)
        /// </summary>
		[ReadOnly(true)]
		public bool HasSettings
        {
            get { return this._settings != null; }
        }

                #endregion //HasSettings	

				// AS 6/22/09 NA 2009.2 Field Sizing
				#region Height

		/// <summary>
		/// Identifies the <see cref="Height"/> dependency property
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public static readonly DependencyProperty HeightProperty = FieldSettings.HeightProperty.AddOwner(typeof(Field),
			new FrameworkPropertyMetadata(new PropertyChangedCallback(OnWidthHeightChanged)));

		private static void OnWidthHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			Field fld = (Field)d;

			bool isHeight = e.Property == HeightProperty;

			if (isHeight)
				fld._cachedHeight = null;
			else
				fld._cachedWidth = null;

			// follow the behavior of the (Cell|Label)(Width|Height) and clear the 
			// customization when set
			if (fld._explicitResizeInfo != null)
			{
				fld._explicitResizeInfo.ClearExplicit(true, !isHeight);
				fld._explicitResizeInfo.ClearExplicit(false, !isHeight);
			}

			if (fld._owner != null)
				fld._owner.OnFieldWidthHeightChanged();
		}

		/// <summary>
		/// Returns or sets a FieldLength instance that represents the height of the field.
		/// </summary>
		/// <seealso cref="HeightProperty"/>
		/// <seealso cref="Width"/>
		//[Description("Returns or sets a FieldLength instance that represents the height of the field.")]
		//[Category("Behavior")]
		[Bindable(true)]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public FieldLength? Height
		{
			get
			{
				return (FieldLength?)this.GetValue(Field.HeightProperty);
			}
			set
			{
				this.SetValue(Field.HeightProperty, value);
			}
		}

				#endregion //Height

                #region Index

        /// <summary>
        /// The zero-based index of the field in its <see cref="FieldCollection"/> (read-only).
        /// </summary>
		[ReadOnly(true)]
        public int Index
        {
            get
            {
				if ( this._owner == null )
                    return -1;

				FieldCollection fields = _owner.Fields;

                // Optimization: see if the cached index still represents this field.
                // If not, cache the returned value from the IndexOf method
				int index = _index;
				if (index < 0 ||
					index >= fields.Count ||
					fields[index] != this)
				{
					// JJD 1/4/11 - TFS62509
					// Initialize the member to -1 first in case the filed is no longer in
					// the Fields collection
					_index = -1;

					// AS 11/29/10 TFS60418
					// Instead of having each field do a linear walk when its Index 
					// is requested assume that all the fields need to be updated 
					// when one is dirty and reverify them all.
					//
					//this._index = index = fields.IndexOf(this);
					for (int i = 0, count = fields.Count; i < count; i++)
						fields[i]._index = i;

					index = _index;
				}

                return index;
            }
        }

                #endregion //Index	

				#region InvalidValueBehaviorResolved

		/// <summary>
		/// Gets the resolved value of the <see cref="FieldSettings.InvalidValueBehavior"/> property.
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note: </b>This property can return <see cref="InvalidValueBehavior"/>.Default which means that the editor's default value will be used.</para>
		/// </remarks>
		/// <seealso cref="FieldSettings.InvalidValueBehavior"/>
		/// <seealso cref="FieldSettings"/>
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		[Browsable( false )]
		[Bindable( true )]
		[ReadOnly( true )]
		public InvalidValueBehavior InvalidValueBehaviorResolved
		{
			get
			{
				InvalidValueBehavior val = InvalidValueBehavior.Default;

				if ( this._settings != null )
					val = this._settings.InvalidValueBehavior;

				if ( val != InvalidValueBehavior.Default )
					return val;

				if ( this._owner != null )
				{
					if ( this._owner.HasFieldSettings )
					{
						val = this._owner.FieldSettings.InvalidValueBehavior;

						if ( val != InvalidValueBehavior.Default )
							return val;
					}

					DataPresenterBase layoutOwner = this._owner.DataPresenter;

					if ( layoutOwner != null && layoutOwner.HasFieldSettings )
					{
						val = layoutOwner.FieldSettings.InvalidValueBehavior;

						if ( val != InvalidValueBehavior.Default )
							return val;
					}
				}

				// JJD 4/27/07 
				// Optimization - return Default so we can avoid explicitly setting the property on the editor in this case.
				//return InvalidValueBehavior.DisplayErrorMessage;
				return InvalidValueBehavior.Default;
			}
		}

				#endregion // InvalidValueBehaviorResolved

				#region IsExpandable

		/// <summary>
        /// Identifies the <see cref="IsExpandable"/> dependency property
        /// </summary>
        [TypeConverter(typeof(System.Windows.NullableBoolConverter))]
        public static readonly DependencyProperty IsExpandableProperty = DependencyProperty.Register("IsExpandable",
                typeof(Nullable<bool>), typeof(Field), new FrameworkPropertyMetadata(new Nullable<bool>()));

        /// <summary>
        /// Determines if this <see cref="Field"/>'s cells can be expanded.
        /// </summary>
		/// <remarks>
		/// <para class="note"><b>Note: </b><see cref="Field"/>'s that have a <see cref="Field.DataType"/> that implements the <see cref="System.Collections.IEnumerable"/> interface 
		/// are expandable by default. However, any <see cref="Field"/> can be made expandable by setting its <see cref="Field.IsExpandable"/> property to true. 
		/// Expandable fields have associated <see cref="ExpandableFieldRecord"/>s and <see cref="ExpandableFieldRecordPresenter"/>s to represent them in the UI. When one of these is expanded 
		/// its nested content will contain either a <see cref="RecordListControl"/> if its value implements the <b>IEnumerable</b> interface and is not a string. All 
		/// other data types including string will display an <see cref="ExpandedCellPresenter"/>.</para>
		/// <para></para>
        /// <para>Note: If this property is left to its default setting of null then <see cref="IsExpandableResolved"/> will return true for <see cref="Field"/>s whose <see cref="DataType"/> implements <b>IEnumerable</b>. All other data types will return false by default.</para>
        /// </remarks>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="DataType"/>
        /// <seealso cref="FieldSettings.ExpandedCellStyle"/>
        /// <seealso cref="FieldSettings.ExpandedCellStyleSelector"/>
        /// <seealso cref="Record.IsExpanded"/>
        /// <seealso cref="IsExpandableProperty"/>
        /// <seealso cref="IsExpandableResolved"/>
        /// <seealso cref="RecordPresenter"/>
        /// <seealso cref="RecordPresenter.NestedContent"/>
        //[Description("Determines if this field can be expanded")]
        //[Category("Behavior")]
		[Bindable(true)]
		[TypeConverter(typeof(System.Windows.NullableBoolConverter))]
        public Nullable<bool> IsExpandable
        {
            get
            {
                return (Nullable<bool>)this.GetValue(Field.IsExpandableProperty);
            }
            set
            {
                this.SetValue(Field.IsExpandableProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="IsExpandable"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeIsExpandable()
        {
            return this.IsExpandable.HasValue;
        }

		/// <summary>
		/// Resets the <see cref="IsExpandable"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetIsExpandable()
		{
			this.ClearValue(IsExpandableProperty);
		}

                #endregion //IsExpandable

                #region IsExpandableResolved

        /// <summary>
        /// Determines if this <see cref="Field"/> can be expanded (read-only).
        /// </summary>
        /// <remarks>
		/// <para class="note"><b>Note: </b><see cref="Field"/>'s that have a <see cref="Field.DataType"/> that implements the <see cref="System.Collections.IEnumerable"/> interface 
		/// are expandable by default. However, any <see cref="Field"/> can be made expandable by setting its <see cref="Field.IsExpandable"/> property to true. 
		/// Expandable fields have associated <see cref="ExpandableFieldRecord"/>s and <see cref="ExpandableFieldRecordPresenter"/>s to represent them in the UI. When one of these is expanded 
		/// its nested content will contain either a <see cref="RecordListControl"/> if its value implements the <b>IEnumerable</b> interface and is not a string. All 
		/// other data types including string will display an <see cref="ExpandedCellPresenter"/>.</para>
		/// <para></para>
        /// <para>Note: If the <see cref="IsExpandable"/> property is left to its default setting of null then this will return true for <see cref="Field"/>s whose <see cref="DataType"/> implements <b>IEnumerable</b>. All other data types will return false by default.</para>
        /// </remarks>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="DataType"/>
        /// <seealso cref="FieldSettings.ExpandedCellStyle"/>
        /// <seealso cref="FieldSettings.ExpandedCellStyleSelector"/>
        /// <seealso cref="Record.IsExpanded"/>
        /// <seealso cref="IsExpandable"/>
        /// <seealso cref="IsExpandableProperty"/>
        /// <seealso cref="RecordPresenter"/>
        /// <seealso cref="RecordPresenter.NestedContent"/>
        //[Description("Determines if this field can be expanded (read-only)")]
        //[Category("Behavior")]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public bool IsExpandableResolved
        {
            get
            {
                if (this._cachedIsExpandable.HasValue)
                    return this._cachedIsExpandable.Value;

                return this._isExpandableByDefault;
            }
        }

                #endregion //IsExpandableResolved

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region IsFixed

        private static readonly DependencyPropertyKey IsFixedPropertyKey =
            DependencyProperty.RegisterReadOnly("IsFixed",
            typeof(bool), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

        /// <summary>
        /// Identifies the <see cref="IsFixed"/> dependency property
        /// </summary>
        public static readonly DependencyProperty IsFixedProperty =
            IsFixedPropertyKey.DependencyProperty;

        /// <summary>
        /// Returns a boolean indicating if the field is fixed based on the FixedLocation and whether the current view supports fixing fields.
        /// </summary>
        /// <seealso cref="IsFixedProperty"/>
        //[Description("Returns a boolean indicating if the field is fixed based on the FixedLocation and whether the current view supports fixing fields.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [ReadOnly(true)]
        public bool IsFixed
        {
            get
            {
                return (bool)this.GetValue(Field.IsFixedProperty);
            }
        }

                #endregion //IsFixed

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region IsFixedStateChanging

        internal static readonly DependencyPropertyKey IsFixedStateChangingPropertyKey =
            DependencyProperty.RegisterReadOnly("IsFixedStateChanging",
            typeof(bool), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

        /// <summary>
        /// Identifies the <see cref="IsFixedStateChanging"/> dependency property
        /// </summary>
        public static readonly DependencyProperty IsFixedStateChangingProperty =
            IsFixedStateChangingPropertyKey.DependencyProperty;

        /// <summary>
        /// Returns a boolean indicating that the fixed state of the field will be changing.
        /// </summary>
        /// <seealso cref="IsFixedStateChangingProperty"/>
        //[Description("Returns a boolean indicating that the fixed state of the field will be changing.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [ReadOnly(true)]
        public bool IsFixedStateChanging
        {
            get
            {
                return (bool)this.GetValue(Field.IsFixedStateChangingProperty);
            }
        }

                #endregion //IsFixedStateChanging

                #region IsGroupBy

        /// <summary>
        /// Returns true if this is a groupby field (read-only)
        /// </summary>
        /// <remarks>
        /// <para><see cref="Field"/>s become groupby fields once corresponding <see cref="FieldSortDescription"/> objects, whose <see cref="FieldSortDescription.IsGroupBy"/> properties were set to true, have been added to the <see cref="Owner"/>'s <see cref="FieldLayout.SortedFields"/> collection.</para>
        /// <para></para>
        /// <para>In order to initialize a field as a groupby field you need to add a corresponding <see cref="FieldSortDescription"/> object to the <see cref="FieldLayout"/>'s <see cref="FieldLayout.SortedFields"/> collection in response to the <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>'s <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayoutInitialized"/> event.</para>
        /// </remarks>
        /// <seealso cref="FieldLayout"/>
        /// <seealso cref="FieldSortDescription"/>
        /// <seealso cref="FieldSortDescriptionCollection"/>
        /// <seealso cref="FieldSortDescription.IsGroupBy"/>
        /// <seealso cref="Owner"/>
        /// <seealso cref="FieldLayout.SortedFields"/>
        //[Description("Returns true if this is a groupby field (read-only)")]
        //[Category("Behavior")]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public bool IsGroupBy
        {
            get
            {
                return this._isGroupBy;
            }
        }

                #endregion //IsGroupBy

                #region IsPrimary

        /// <summary>
        /// Gets/sets whether this is the Primary Field
        /// </summary>
        /// <seealso cref="FieldLayoutSettings.HighlightPrimaryField"/>
        /// <seealso cref="FieldLayout.HighlightPrimaryFieldResolved"/>
        /// <seealso cref="FieldLayout"/>
        /// <seealso cref="FieldLayout.PrimaryField"/>
        /// <seealso cref="FieldLayoutSettings"/>
        /// <seealso cref="FieldLayoutSettings.AutoArrangePrimaryFieldReservation"/>
		[Bindable(true)]
		//[ReadOnly(true)]	JM 07-02-08 BR34560
		public bool IsPrimary
        {
            get
            {
                // If our owner is set rely on it to keep track of the current Primary field
                if (this._owner != null)
                    return this == this._owner.PrimaryField;

                // return the cached setting
                return this._isPrimary;
            }
            set
            {
                // cache the setting in case we aren't hooked up to the owner yet
                this._isPrimary = value;

				// AS 8/25/11 TFS84612
				this._cachedCellContentAlignmentResolved = null;

                if (this._owner != null)
                {
					if (value == true)
					{
						// AS 4/4/07 BR21809
						if (false == this._owner.Fields.Contains(this))
							throw new ArgumentException( DataPresenterBase.GetString( "LE_ArgumentException_15" ) );

						this._owner.PrimaryField = this;
					}
					else
						if (this._owner.PrimaryField == this)
							this._owner.PrimaryField = null;
                }
            }
        }

		/// <summary>
		/// Determines if the <see cref="IsPrimary"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeIsPrimary()
        {
            return this._isPrimary;
        }

		/// <summary>
		/// Resets the <see cref="IsPrimary"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetIsPrimaryField()
		{
			this.IsPrimary = false;
		}

                #endregion //IsPrimaryField

                #region IsScrollTipField

        /// <summary>
        /// Gets/sets whether this is the Field in the owning field layout that is used to provide the value for the scroll tip when the GridViewSettings.ScrollingMode is set to DeferredWithScrollTips.
        /// </summary>
        /// <seealso cref="FieldLayout"/>
        /// <seealso cref="FieldLayout.ScrollTipField"/>
		[Bindable(true)]
		//[ReadOnly(true)]  JM 02-07-08 BR30360
		public bool IsScrollTipField
        {
            get
            {
                // If our owner is set rely on it to keep track of the current ScrollTipField field
                if (this._owner != null)
                    return this == this._owner.ScrollTipField;

                // return the cached setting
                return this._isScrollTip;
            }
            set
            {
                // cache the setting in case we aren't hooked up to the owner yet
				this._isScrollTip = value;

                if (this._owner != null)
                {
					if (value == true)
					{
						// AS 4/4/07 BR21809
						if (false == this._owner.Fields.Contains(this))
							throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_16"));

						this._owner.ScrollTipField = this;
					}
					else
						if (this._owner.ScrollTipField == this)
							this._owner.ScrollTipField = null;
                }
            }
        }

		/// <summary>
		/// Determines if the <see cref="IsScrollTipField"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeIsScrollTipField()
        {
            return this._isScrollTip;
        }

		/// <summary>
		/// Resets the <see cref="IsScrollTipField"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetIsScrollTipFieldField()
		{
			this.IsScrollTipField = false;
		}

                #endregion //IsScrollTipFieldField

				#region IsSelected

		/// <summary>
		/// Identifies the <see cref="IsSelected"/> dependency property
		/// </summary>
		public static readonly DependencyProperty IsSelectedProperty = DependencyProperty.Register("IsSelected",
				typeof(bool), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, null, new CoerceValueCallback(OnCoerceIsSelected)));

		private static object OnCoerceIsSelected(DependencyObject target, object value)
		{
			Field fld = target as Field;

			if (fld != null && value is bool)
			{
				if (fld._selected == (bool)value)
					return fld._selected;

				// JM 03-26-10 TFS30118 - If IsSelected is set in XAML, the owner will be null.
				if (fld.Owner == null)
					return value;

				DataPresenterBase dp = fld.Owner.DataPresenter;

				if (null != dp)
				{
					bool clearExistingItems = true;

					SelectionStrategyBase selectionStrategy = fld.Owner.GetSelectionStrategyForItem(fld);

					if (null != selectionStrategy)
						clearExistingItems = selectionStrategy.IsSingleSelect;

					// JM 02-05-09 TFS12744
					//dp.InternalSelectItem(fld, clearExistingItems, (bool)value);
					bool selected = dp.InternalSelectItem(fld, clearExistingItems, (bool)value);
					if (selected && dp.SelectedItems.Fields.Count == 1)
						((ISelectionHost)dp).SetPivotItem(fld, false);

					return fld._selected;
				}
			}

			return false;
		}

		/// <summary>
		/// Gets/sets whether the <see cref="Field"/> is selected.
		/// </summary>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.SelectedItems"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.SelectedItemHolder"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.SelectedItemHolder.Fields"/>
		/// <seealso cref="SelectedFieldCollection"/>
		/// <seealso cref="IsSelectedProperty"/>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		public bool IsSelected
		{
			get
			{
				return this._selected;
			}
			set
			{
				this.SetValue(Field.IsSelectedProperty, KnownBoxes.FromValue(value));
			}
		}

				#endregion //IsSelected

				#region IsUnbound

		/// <summary>
		/// Internal use only
		/// </summary>
		protected static readonly DependencyPropertyKey IsUnboundPropertyKey =
			DependencyProperty.RegisterReadOnly("IsUnbound",
			typeof(bool), typeof(Field), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		/// <summary>
		/// Identifies the <see cref="IsUnbound"/> dependency property
		/// </summary>
		public static readonly DependencyProperty IsUnboundProperty =
			IsUnboundPropertyKey.DependencyProperty;

		/// <summary>
		/// Returns true if this is an UnboundField (read-only)
		/// </summary>
		/// <seealso cref="IsUnboundProperty"/>
		/// <seealso cref="UnboundField"/>
		/// <seealso cref="UnboundCell"/>
		/// <seealso cref="DataItemPresenter.IsUnbound"/>
		//[Description("Returns true if this is an UnboundField (read-only)")]
		//[Category("Behavior")]
		[Bindable(true)]
		[ReadOnly(true)]
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		public virtual bool IsUnbound
		{
			get
			{
				return false;
			}
		}

				#endregion //IsUnbound
    
                #region Label

        /// <summary>
        /// Identifies the <see cref="Label"/> dependency property
        /// </summary>
        public static readonly DependencyProperty LabelProperty = DependencyProperty.Register("Label",
            typeof(object), typeof(Field), 
            // JJD 7/25/08 - BR35098 
            // Change default from null to DefaultValueMarker.Instance so we can recognize it in the CoerceCallback
			//new FrameworkPropertyMetadata(null,
			new FrameworkPropertyMetadata(DefaultValueMarker.Instance,
				
				
				
				
				
				
				
				//null, new CoerceValueCallback(CoerceLabel)
				new PropertyChangedCallback( OnLabelChanged ),
                // JJD 7/24/08 - BR35098
                // Added CoerceValueCallback so we can default the Label's value without having to st
                // anything locally and thereby possibly step on a bindin
                new CoerceValueCallback(CoerceLabel)
			)
		);

        // JJD 7/25/08 - BR35098 
        // Added corce logic so we don't have to explicitly set a default and
        // possible step on a pending binding operation
        private static object CoerceLabel(DependencyObject target, object value)
        {
            // JJD 7/25/08 - BR35098 
            // We should never return the LabelDefaultValue object from the coerce.
            // We should return the defaultLabel in this case;
            if (value == DefaultValueMarker.Instance)
            {
                Field field = target as Field;

                // JJD 5/20/09 - TFS17823 
                // Check if _defaultLabel is the DefaultValueMarker.Instance if so return null
                //if (field != null)
                if (field != null && field._defaultLabel != DefaultValueMarker.Instance)
                    return field._defaultLabel;
                else
                    return null;
            }

            return value;
        }

		private object _cachedLabel;

		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)









#endregion // Infragistics Source Cleanup (Region)


		
		
		
		
		
		private static void OnLabelChanged( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			Field field = (Field)dependencyObject;
			object newVal = (object)e.NewValue;

            // JJD 7/25/08 - BR35098 
            // If the value is LabelDefaultValue, which means someone called ClearValue, then force a Coerce. 
            if (newVal == DefaultValueMarker.Instance)
            {
                // JJD 5/20/09 - TFS17823 
                // Check if _defaultLabel is the DefaultValueMarker.Instance 
                if (field._defaultLabel == DefaultValueMarker.Instance)
                    field._defaultLabel = null;
                else
                    field._cachedLabel = field._defaultLabel;

                field.CoerceValue(Field.LabelProperty);
            }
            else
                field._cachedLabel = newVal;

            // AS 12/11/08 TFS11518
            // We want to track the number of lines of text in the label (assuming its text)
            // so when we determine which fields to virtualize we can measure the one with 
            // the most lines of text.
            //
            int newLineCount = Utilities.GetLineCount(field._cachedLabel as string);

			if (field._owner != null)
			{
				// the line count is part of the label key cache so we need to rebuild
				// that and the template cache
				if (newLineCount != field._labelLineCount)
					field._owner.InternalVersion++;

				// AS 7/21/09 NA 2009.2 Field Sizing
				field._owner.AutoSizeInfo.OnLabelChanged(field);
			}

            field._labelLineCount = newLineCount;

            // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
            field.BumpLayoutItemVersion();
		}

        /// <summary>
        /// The label for the <see cref="Field"/>
        /// </summary>
        /// <remarks>
		/// <para class="body">This defaults to the <see cref="Name"/> of the this.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Label.html">Field Label</a> topic in the Developer's Guide for an explanation of the Field Labels.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Settings.html">Field Settings</a> topic in the Developer's Guide for an explanation of the FieldSettings object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
		/// </remarks>
		/// <seealso cref="LabelPresenter"/>
        //[Description("The label for the field")]
		[Bindable(true)]
		public object Label
        {
            get
            {
				// JJD 5/4/07 - Optimization
				// use the cached the label value
                //return this.getValue(Field.LabelProperty);
				return this._cachedLabel;
            }
            set
            {
                this.SetValue(Field.LabelProperty, value);
            }
        }

        internal void InitializeDefaultLabel(object value)
        {
            // JJD 7/25/08 - BR35098
            // Instead of setting the label explicitly set the _defalutLabel and corce the label property
            //this.Label = value;
            //this._labelExplicitySet = false;
            this._defaultLabel = value;
            this.CoerceValue(LabelProperty);
        }

		/// <summary>
		/// Determines if the <see cref="Label"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeLabel()
        {
            // JJD 7/25/08 - BR35098 
            // Don't use _labelExplicitySet flag anymore since we are coercing the value.
            // Insetad get the Valuesource of the property
            //return this._labelExplicitySet && this.Label != null;
             BaseValueSource source = DependencyPropertyHelper.GetValueSource(this, LabelProperty).BaseValueSource;

            // The property should be serialized if it was locally set
            return ((int)source >= (int)BaseValueSource.Local);
        }

		/// <summary>
		/// Resets the <see cref="Label"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetLabel()
		{
            // JJD 7/25/08 - BR35098 
            // always call ClearValue
            //if (this.ShouldSerializeLabel())
            {
                this.ClearValue(LabelProperty);
            }
		}

                #endregion //Label

                #region LabelClickActionResolved

        /// <summary>
        /// Gets the resolved relative clickAction of the label to its field (read-only)
        /// </summary>
        /// <remarks>
        /// <para class="note"><b>Note:</b> when using the SortByOneFieldOnlyTriState or SortByMultipleFieldsTriState settings, if the 'Ctrl' key is pressed during a click, or the <see cref="Field.IsGroupBy"/> property is true, then the Field will not cycle thru the unsorted state. Instead it will cycle thru the ascending and descending states only.</para>
        /// </remarks>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public LabelClickAction LabelClickActionResolved
        {
            get
            {
				// SSP 2/3/12 NAS12.1 External Sorting/Filtering/Grouping/Summaries
				// Refactored so we can disable sorting on unbound fields if sort evaluation mode is
				// to use collection view.
				// 
				
				LabelClickAction clickAction = LabelClickAction.Default;

				if ( this._settings != null )
					clickAction = this._settings.LabelClickAction;

				if ( LabelClickAction.Default == clickAction && this._owner != null )
					clickAction = this._owner.GetDefaultLabelClickAction( this );

				if ( LabelClickAction.Default == clickAction )
				{
					// If a specific sort comparer isn't suplied for this field
					// and its data type doesn't support IComparable then return No
					// JJD 4/17/08
					// check underlying data type instead
					if ( ( this._settings == null || this._settings.SortComparer == null ) &&
						!typeof( IComparable ).IsAssignableFrom( this._cachedDataTypeUnderlying ) )
						clickAction = LabelClickAction.Nothing;
				}

				if ( LabelClickAction.Default == clickAction )
					clickAction = Field.DefaultLabelClickAction;

				// If we are using collection view to sort, disallow sorting on unbound fields.
				// 
				if ( ( LabelClickAction.SortByMultipleFields == clickAction || LabelClickAction.SortByMultipleFields == clickAction
					|| LabelClickAction.SortByMultipleFields == clickAction || LabelClickAction.SortByMultipleFields == clickAction )
					&& this.IsUnbound && null != _owner && SortEvaluationMode.UseCollectionView == _owner.SortEvaluationModeResolvedDefault )
				{
					clickAction = LabelClickAction.Nothing;
				}

				return clickAction;
				
#region Infragistics Source Cleanup (Region)


















#endregion // Infragistics Source Cleanup (Region)

				
            }
        }

                #endregion //LabelClickAction

                #region LabelHeightResolved

        /// <summary>
        /// The resolved height for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelHeightResolved
        {
            get
            {
				// AS 12/14/07 BR25223
				// Get the height from the template cell.
				//
				if (this._owner != null)
				{
					Size size = VirtualizingDataRecordCellPanel.GetTemplateItemSize(this, true);

					double maxHeight = this.LabelMaxHeightResolved;

					// constrain the height to its max since that is what
					// the cell element itself would do
					if (double.IsNaN(maxHeight) == false &&
						size.Height > maxHeight)
					{
						size.Height = maxHeight;
					}

					return size.Height;
				}

				return this.LabelHeightResolvedInternal;
			}
		}

		// AS 12/14/07 BR25223
		// Changed what was the public CellHeightResolved to an internal. We need to 
		// always get a value based on the CellHeight properties but customers want to 
		// know what the actual height is.
		//
		/// <summary>
		/// Returns a resolved value based on the <see cref="FieldSettings.LabelHeight"/>
		/// </summary>
		internal double LabelHeightResolvedInternal
		{
			get
			{
				double value = this.GetLabelHeightResolvedHelper(false, false);
                if (!double.IsNaN(value))
                    return value;

                if (this._cellPosition.RowSpan > 1)
                    return double.NaN;

                FieldLayout fl = this.Owner;

				bool sizeToContent = true;

				if (fl != null)
				{
					// in horizonatl gridview the height is never sized to content
					if (fl.IsHorizontal)
						sizeToContent = false;
					else
						sizeToContent = fl.IsDataRecordSizedToContent;
				}

				if (sizeToContent == true)
					return double.NaN;

                value = this.GetCellHeightResolvedHelper(false);
                if (!double.IsNaN(value))
                    return value;

				// AS 3/13/07 BR21065
				// Try to use the height of the template label.
				//
				//return this.DefaultCellHeight;
				return this.GetDefaultHeight(true);
            }
        }

        internal double GetLabelHeightResolvedHelper(bool provideDefault, bool forceDefault)
        {
			// SSP 8/29/08 BR35923
			// 
			// AS 7/30/09 NA 2009.2 Field Sizing
			//if ( null != _explicitResizeInfo && !double.IsNaN( _explicitResizeInfo.LabelHeight ) )
			FieldSize size = this.GetResizeSize(true, false);

			if (size.HasExplicitSize)
			{
				ViewBase view = GridUtilities.GetView( this );
				Orientation logicalOrientation = null != view ? view.LogicalOrientation : Orientation.Vertical;

				// Explicit resize cell width is only applicable in vertical orientation.
				// 
				if ( Orientation.Horizontal == logicalOrientation )
					// AS 7/30/09 NA 2009.2 Field Sizing
					//return _explicitResizeInfo.LabelHeight;
					return size.Value;
			}

			// AS 6/24/09 NA 2009.2 Field Sizing
			FieldLength len = this.GetWidthOrHeight(false);

			if (len.IsAbsolute && SyncCellLabelHeight)
				return len.Value;

			// if we're in auto mode and we have an auto size...
			if (len.IsAnyAuto && size.HasAutoModeSize)
				return size.Value;

			double value = double.NaN;

            if (this._settings != null)
            {
                value = this._settings.LabelHeight;

                if (!double.IsNaN(value))
                    return value;
            }

            FieldLayout fl = this.Owner;

            if (fl != null)
            {
                if (fl.HasFieldSettings)
                {
                    value = fl.FieldSettings.LabelHeight;

                    if (!double.IsNaN(value))
                        return value;
                }

                DataPresenterBase layoutOwner = fl.DataPresenter;

                if (layoutOwner != null && layoutOwner.HasFieldSettings)
                {
                    value = layoutOwner.FieldSettings.LabelHeight;

                    if (!double.IsNaN(value))
                        return value;
                }
            }

			if (provideDefault)
			{
				// AS 3/13/07 BR21065
				// Try to use the height of the template label.
				//
				//value = this.DefaultCellHeight;
				value = this.GetDefaultHeight(true);

				if (forceDefault && double.IsNaN(value))
					return 32d;

				return value;
			}

            return double.NaN;
        }

                #endregion //LabelHeightResolved

                #region LabelMaxHeightResolved

        /// <summary>
        /// The resolved maximum height for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelMaxHeightResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.LabelMaxHeight;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.LabelMaxHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.LabelMaxHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return double.PositiveInfinity;
            }
        }

                #endregion //LabelMaxHeightResolved

                #region LabelMaxWidthResolved

        /// <summary>
        /// The resolved maximum width for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelMaxWidthResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.LabelMaxWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.LabelMaxWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.LabelMaxWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return double.PositiveInfinity;
            }
        }

                #endregion //LabelMaxWidthResolved

                #region LabelMinHeightResolved

        /// <summary>
        /// The resolved minimum height for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelMinHeightResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.LabelMinHeight;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.LabelMinHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.LabelMinHeight;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return 0.0d;
            }
        }

                #endregion //LabelMinHeightResolved

                #region LabelMinWidthResolved

        /// <summary>
        /// The resolved minimum width for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelMinWidthResolved
        {
            get
            {
                double value = double.NaN;

                if (this._settings != null)
                {
                    value = this._settings.LabelMinWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                FieldLayout fl = this.Owner;

                if (fl != null)
                {
                    if (fl.HasFieldSettings)
                    {
                        value = fl.FieldSettings.LabelMinWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }

                    DataPresenterBase layoutOwner = fl.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        value = layoutOwner.FieldSettings.LabelMinWidth;

                        if (!double.IsNaN(value))
                            return value;
                    }
                }

                return 0.0d;
            }
        }

                #endregion //LabelMinWidthResolved

                // JJD 2/7/08 - BR30444 - added
                #region LabelTextAlignmentResolved

        /// <summary>
        /// Gets the resolved text alignment setting of the label to this field (read-only)
        /// </summary>
        /// <remarks>
        /// <p class="note"><b>Note:</b> This setting only applies if the <see cref="Field"/>'s <see cref="Field.Label"/> is a string and the ContentTemplate property of <see cref="LabelPresenter"/> is not set.</p>
        /// </remarks>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSettings.LabelTextAlignment"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public TextAlignment LabelTextAlignmentResolved
        {
            get
            {
                if (this._settings != null)
                {
                    TextAlignment? textAlignment = this._settings.LabelTextAlignment;

                    if (textAlignment.HasValue)
                        return textAlignment.Value;
                }

                if (this._owner != null)
                    return this._owner.GetDefaultLabelTextAlignment(this);

                return TextAlignment.Left;
            }
        }

                #endregion //LabelTextAlignment

                // JJD 2/7/08 - BR30444 - added
                #region LabelTextTrimmingResolved

        /// <summary>
        /// Gets the resolved text trimming setting of the label to this field (read-only)
        /// </summary>
        /// <remarks>
        /// <p class="note"><b>Note:</b> This setting only applies if the <see cref="Field"/>'s <see cref="Field.Label"/> is a string and the ContentTemplate property of <see cref="LabelPresenter"/> is not set.</p>
        /// </remarks>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSettings.LabelTextTrimming"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public TextTrimming LabelTextTrimmingResolved
        {
            get
            {
                if (this._settings != null)
                {
                    TextTrimming? textTrimming = this._settings.LabelTextTrimming;

                    if (textTrimming.HasValue)
                        return textTrimming.Value;
                }

                if (this._owner != null)
                    return this._owner.GetDefaultLabelTextTrimming(this);

                return TextTrimming.None;
            }
        }

                #endregion //LabelTextTrimming

                // JJD 2/7/08 - BR30444 - added
                #region LabelTextWrappingResolved

        /// <summary>
        /// Gets the resolved wrapping setting of the label to its field (read-only)
        /// </summary>
        /// <remarks>
        /// <p class="note"><b>Note:</b> This setting only applies if the <see cref="Field"/>'s <see cref="Field.Label"/> is a string and the ContentTemplate property of <see cref="LabelPresenter"/> is not set.</p>
        /// </remarks>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSettings.LabelTextWrapping"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public TextWrapping LabelTextWrappingResolved
        {
            get
            {
                if (this._settings != null)
                {
                    TextWrapping? textWrapping = this._settings.LabelTextWrapping;

                    if (textWrapping.HasValue)
                        return textWrapping.Value;
                }

                if (this._owner != null)
                    return this._owner.GetDefaultLabelTextWrapping(this);

                return TextWrapping.NoWrap;
            }
        }

                #endregion //LabelTextWrapping

                #region LabelWidthResolved

        /// <summary>
        /// The resolved width for this field's labels in device-independent units (1/96th inch per unit)
        /// </summary>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Bindable(true)]
		[ReadOnly(true)]
		public double LabelWidthResolved
        {
            get
            {
				// AS 12/14/07 BR25223
				// Get the width from the template cell.
				//
				if (this._owner != null)
				{
					Size size = VirtualizingDataRecordCellPanel.GetTemplateItemSize(this, true);

					double maxWidth = this.LabelMaxWidthResolved;

					// constrain the width to its max since that is what
					// the cell element itself would do
					if (double.IsNaN(maxWidth) == false &&
						size.Width > maxWidth)
					{
						size.Width = maxWidth;
					}

					return size.Width;
				}

				return this.LabelWidthResolvedInternal;
			}
		}

		// AS 12/14/07 BR25223
		// Changed what was the public CellWidthResolved to an internal. We need to 
		// always get a value based on the CellWidth properties but customers want to 
		// know what the actual width is.
		//
		/// <summary>
		/// Returns a resolved value based on the <see cref="FieldSettings.LabelWidth"/>
		/// </summary>
		internal double LabelWidthResolvedInternal
		{
			get
			{
				double value = this.GetLabelWidthResolvedHelper(false, false);
                if (!double.IsNaN(value))
                    return value;

                if (this._cellPosition.ColumnSpan > 1)
                    return double.NaN;

                FieldLayout fl = this.Owner;

				bool sizeToContent = true;

				if (fl != null)
				{
					// in vertical layout the width is never sized to content
					if (!fl.IsHorizontal)
						sizeToContent = false;
					else
						sizeToContent = fl.IsDataRecordSizedToContent;
				}

				if (sizeToContent == true)
					return double.NaN;

				value = this.GetCellWidthResolvedHelper(false);
                if (!double.IsNaN(value))
                    return value;

				return this.DefaultCellWidth;
            }
        }

		internal double GetLabelWidthResolvedHelper(bool provideDefault, bool forceDefault)
        {
			// SSP 8/29/08 BR35923
			// 
			// AS 7/30/09 NA 2009.2 Field Sizing
			//if ( null != _explicitResizeInfo && !double.IsNaN( _explicitResizeInfo.LabelWidth ) )
			FieldSize size = this.GetResizeSize(true, true);

			if (size.HasExplicitSize)
			{
				ViewBase view = GridUtilities.GetView( this );
				Orientation logicalOrientation = null != view ? view.LogicalOrientation : Orientation.Vertical;

				// Explicit resize cell width is only applicable in vertical orientation.
				// 
				if ( Orientation.Vertical == logicalOrientation )
					// AS 7/30/09 NA 2009.2 Field Sizing
					//return _explicitResizeInfo.LabelWidth;
					return size.Value;
			}

			// AS 6/24/09 NA 2009.2 Field Sizing
			FieldLength len = this.GetWidthOrHeight(true);

			if (len.IsAbsolute && this.SyncCellLabelWidth)
				return len.Value;

			// if we're in auto mode and we have an auto size...
			if (len.IsAnyAuto && size.HasAutoModeSize)
				return size.Value;

			double value = double.NaN;

            if (this._settings != null)
            {
                value = this._settings.LabelWidth;

                if (!double.IsNaN(value))
                    return value;
            }

            FieldLayout fl = this.Owner;

            if (fl != null)
            {
                if (fl.HasFieldSettings)
                {
                    value = fl.FieldSettings.LabelWidth;

                    if (!double.IsNaN(value))
                        return value;
                }

                DataPresenterBase layoutOwner = fl.DataPresenter;

                if (layoutOwner != null && layoutOwner.HasFieldSettings)
                {
                    value = layoutOwner.FieldSettings.LabelWidth;

                    if (!double.IsNaN(value))
                        return value;
                }
            }

			if (provideDefault)
			{
				// AS 10/9/09 NA 2010.1 - CardView
				// Changed to a method so we can handle labels and cells differently.
				//
				//value = this.DefaultCellWidth;
				value = this.GetDefaultWidth(true);

				if (forceDefault && double.IsNaN(value))
					return 120d;

				return value;
			}

            return double.NaN;
        }

                #endregion //LabelWidthResolved

                #region Name

        /// <summary>
        /// Identifies the <see cref="Name"/> dependency property
        /// </summary>
        public static readonly DependencyProperty NameProperty = DependencyProperty.Register("Name",
                  typeof(string), typeof(Field), new FrameworkPropertyMetadata(String.Empty, new PropertyChangedCallback(OnNameChanged)));

        // JJD 5/20/09 - TFS17823 - added
        private static void OnNameChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            Field fld = target as Field;

            if (fld != null)
            {
                fld._nameExplicitySet = true;

                // JJD 1/26/08 - Optimization
                // Let the fields collection know that the name has changed so it
                // can maintain the index map properly
                if (fld._owner != null)
                    fld._owner.Fields.OnFieldNameChanged(fld, (string)(e.NewValue), (string)(e.OldValue));

                fld._cachedName = (string)fld.GetValue(Field.NameProperty);

                // JJD 7/25/08 - BR35098
                // Udpate and coerce the label property if the old default matched the old Name value

                // JJD 5/20/09 - TFS17823 
                // Check if _defaultLabel is the DefaultValueMarker.Instance 
                if (fld._defaultLabel == DefaultValueMarker.Instance ||
                    (fld._defaultLabel is string && string.Compare((string)e.OldValue, (string)fld._defaultLabel, false) == 0))
                {
                    fld._defaultLabel = fld._cachedName;
                    fld.CoerceValue(LabelProperty);
                }
            }
        }

        /// <summary>
        /// The name of the <see cref="Field"/> which is used as its key into the <see cref="FieldCollection"/>.
        /// </summary>
        /// <seealso cref="FieldLayout"/>
        /// <seealso cref="FieldLayout.Fields"/>
        /// <seealso cref="FieldCollection"/>
        //[Description("The name of the field which is used as the key into the Fieldlayout's Fields collection")]
        //[Category("Behavior")]
        public string Name
        {
            get
            {
                return this._cachedName;
            }
            set
            {
                this.SetValue(Field.NameProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="Name"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeName()
        {
            return this._nameExplicitySet && this._cachedName != null && this._cachedName.Length > 0;
        }

		/// <summary>
		/// Resets the <see cref="Name"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetName()
		{
			if ( this.ShouldSerializeName())
				this.ClearValue(NameProperty);
		}

                #endregion //Name

				// JJD 7/15/10 - TFS35815 - added
				#region NonSpecificNotificationBehaviorResolved

		/// <summary>
		/// Determines if values are refreshed when a notification is received that a change has occured for a DataRecord but the notification doesn't specify which field value has been changed.
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note</b>: non-specific notifications can be received in one of 2 ways. The first is if the parent list implements <see cref="IBindingList"/> and raises
		///  a ListChanged event with a <see cref="ListChangedType"/> of 'ItemChanged' and a null PropertyDescriptor. The second way is if the data item implements <see cref="INotifyPropertyChanged"/> and 
		///  raises a PropertyChanged event with a null or empty 'PropertyName'.</para>
		/// </remarks>
		/// <seealso cref="FieldSettings.NonSpecificNotificationBehavior"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable( false )]
		[ReadOnly( true )]
		public NonSpecificNotificationBehavior NonSpecificNotificationBehaviorResolved
		{
			get
			{
                if (this._cachedNonSpecificNotificationBehavior == NonSpecificNotificationBehavior.Default)
                    this._cachedNonSpecificNotificationBehavior = this.GetNonSpecificNotificationBehaviorResolvedInternal();
 
                return this._cachedNonSpecificNotificationBehavior;
			}
		}

        private NonSpecificNotificationBehavior GetNonSpecificNotificationBehaviorResolvedInternal()
        {
            NonSpecificNotificationBehavior behavior = NonSpecificNotificationBehavior.Default;

            if (this._settings != null)
                behavior = this._settings.NonSpecificNotificationBehavior;

            if (behavior == NonSpecificNotificationBehavior.Default && this._owner != null)
            {
                if (this._owner.HasFieldSettings)
                    behavior = this._owner.FieldSettings.NonSpecificNotificationBehavior;

                if (behavior == NonSpecificNotificationBehavior.Default)
                {
                    DataPresenterBase dp = this._owner.DataPresenter;

                    if (dp != null && dp.HasFieldSettings)
                        behavior = dp.FieldSettings.NonSpecificNotificationBehavior;
                }
            }

			if (behavior == NonSpecificNotificationBehavior.Default)
				behavior = NonSpecificNotificationBehavior.RefreshValue;

            return behavior;
        }

				#endregion //NonSpecificNotificationBehaviorResolved

                #region Owner

        /// <summary>
        /// Returns the <see cref="FieldLayout"/> that owns this collection
        /// </summary>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
        /// <seealso cref="FieldLayout"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
        public FieldLayout Owner
        {
            get
            {
                return this._owner;
            }
        }

                #endregion //Owner

                #region Row

        /// <summary>
        /// Identifies the <see cref="Row"/> dependency property
        /// </summary>
        public static readonly DependencyProperty RowProperty = DependencyProperty.Register("Row",
			// JJD 7/19/07 - BR24928
			// Added change method to regen styles on a row, column, rowspan, columnspan change 
			//typeof(int), typeof(Field), new FrameworkPropertyMetadata(0), new ValidateValueCallback(OnValidateRowColumnSetting));
                typeof(int), typeof(Field), new FrameworkPropertyMetadata(0, new PropertyChangedCallback(OnRowOrColumnChange)), new ValidateValueCallback(OnValidateRowColumnSetting));

        /// <summary>
        /// The row in the grid in the <see cref="Owner"/>'s generated cell area template and optionally its <see cref="FieldLayout.HeaderAreaTemplate"/> where this <see cref="Field"/>s cells and labels should be placed.
        /// </summary>
        /// <remarks>
        /// <para class="body">
		/// This property is ignored if <see cref="AutoArrangeCells"/> does not resolve to 'Never'.
        /// </para>
  		/// <para class="note"><b>Note: </b>In addition to the <see cref="Column"/> and <see cref="Row"/> properties, there are separate <see cref="ColumnSpan"/> and <see cref="RowSpan"/> properites. These settings determine that actual grid row and column for this Field's cells and labels.</para>
		/// </remarks>
        /// <seealso cref="Column"/>
        /// <seealso cref="ColumnSpan"/>
        /// <seealso cref="RowSpan"/>
        /// <seealso cref="FieldLayout.HeaderAreaTemplate"/>
        /// <seealso cref="FieldSettings.CellContentAlignment"/>
        /// <seealso cref="CellContentAlignmentResolved"/>
        /// <seealso cref="RowProperty"/>
		/// <seealso cref="ActualPosition"/>
        //[Description("The row in the grid where this field's cells and/or labels should be placed")]
		[Bindable(true)]
		public int Row
        {
            get
            {
                return (int)this.GetValue(Field.RowProperty);
            }
            set
            {
                this.SetValue(Field.RowProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="Row"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeRow()
        {
            return this.Row > 0;
        }

		/// <summary>
		/// Resets the <see cref="Row"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetRow()
		{
			this.ClearValue(RowProperty);
		}

                #endregion //Row

                #region RowSpan

        /// <summary>
        /// Identifies the <see cref="RowSpan"/> dependency property
        /// </summary>
        public static readonly DependencyProperty RowSpanProperty = DependencyProperty.Register("RowSpan",
			// JM 05-04-10 TFS24462 Remove ValidateValueCallback and add CoerceValueCallback
			// JJD 7/19/07 - BR24928
			// Added change method to regen styles on a row, column, rowspan, columnspan change
			// Also changed default value to 1 and validate it isn't less thn 1 
			//typeof(int), typeof(Field), new FrameworkPropertyMetadata(-1));
                //typeof(int), typeof(Field), new FrameworkPropertyMetadata(1, new PropertyChangedCallback(OnRowOrColumnChange)), new ValidateValueCallback(ValidateRowColumnSpanSetting));
				typeof(int), typeof(Field), new FrameworkPropertyMetadata(1, new PropertyChangedCallback(OnRowOrColumnChange), new CoerceValueCallback(OnCoerceRowColumnSpan)));

        /// <summary>
        /// Determines how many logical rows this <see cref="Field"/>'s cells span in the layout
        /// </summary>
        /// <remarks>
		/// <para class="body">
		/// This property is ignored if <see cref="AutoArrangeCells"/> does not resolve to 'Never'.
		/// </para>
		/// <para class="note"><b>Note: </b>In addition to the <see cref="Column"/> and <see cref="Row"/> properties, there are separate <see cref="ColumnSpan"/> and <see cref="RowSpan"/> properites. These settings determine that actual grid row and column for this Field's cells and labels.</para>
		/// </remarks>
        /// <seealso cref="ColumnSpan"/>
        /// <seealso cref="RowSpanProperty"/>
        /// <seealso cref="Column"/>
        /// <seealso cref="FieldLayout.HeaderAreaTemplate"/>
        /// <seealso cref="FieldSettings.CellContentAlignment"/>
        /// <seealso cref="CellContentAlignmentResolved"/>
        /// <seealso cref="FieldLayoutSettings.AutoArrangePrimaryFieldReservation"/>
        /// <seealso cref="Row"/>
		/// <seealso cref="ActualPosition"/>
        //[Description("Determines how many logical rows this field's cells span in the layout")]
		[Bindable(true)]
		public int RowSpan
        {
            get
            {
                return (int)this.GetValue(Field.RowSpanProperty);
            }
            set
            {
                this.SetValue(Field.RowSpanProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="RowSpan"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeRowSpan()
        {
            return this.RowSpan >= 0;
        }

		/// <summary>
		/// Resets the <see cref="RowSpan"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetRowSpan()
		{
			this.ClearValue(RowSpanProperty);
		}

                #endregion //RowSpan
    
                #region Settings

        /// <summary>
        /// Gets/sets an object that holds specific settings for this field. 
        /// </summary>
		/// <remarks>
		/// <para class="body"><see cref="FieldSettings"/> are exposed via the following 3 properties:
		/// <ul>
		/// <li><see cref="DataPresenterBase"/>'s <see cref="DataPresenterBase.FieldSettings"/> - settings specified here become the default for all <see cref="Field"/>s in every <see cref="FieldLayout"/>.</li>
		/// <li><see cref="FieldLayout"/>'s <see cref="FieldLayout.FieldSettings"/> - settings specified here become the default for all <see cref="Field"/>s in this <see cref="FieldLayout"/>'s <see cref="FieldLayout.Fields"/> collection.</li>
		/// <li><see cref="Field"/>'s <see cref="Field.Settings"/> - settings specified here apply to only this one specific <see cref="Field"/>.</li>
		/// </ul>
		/// </para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Settings.html">Field Settings</a> topic in the Developer's Guide for an explanation of the FieldSettings object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="FieldLayout.FieldSettings"/>
		/// <seealso cref="FieldLayout.Fields"/>
        //[Description("Gets/sets an object that holds Field specific settings")]
        //[Category("Behavior")]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public FieldSettings Settings
        {
            get
            {
                if (this._settings == null)
                {
                    // JJD 12/21/07
                    // If we know we are in desin mode then return null.
                    if (this._owner == null || this._owner.DataPresenter == null ||
                         !DesignerProperties.GetIsInDesignMode(this._owner.DataPresenter))
                    {
                        this._settings = new FieldSettings();

                        // listen for property changes
                        this._settings.PropertyChanged += new PropertyChangedEventHandler(this.OnSettingsPropertyChanged);
                    }
                }

                return this._settings;
            }
            set
            {
                if (value != this._settings)
                {
                    // remove property change listener for old settings
                    if ( this._settings != null )
                        this._settings.PropertyChanged -= new PropertyChangedEventHandler(this.OnSettingsPropertyChanged);

                    this._settings = value;

                    // listen for property changes
                    if ( this._settings != null )
                        this._settings.PropertyChanged += new PropertyChangedEventHandler(this.OnSettingsPropertyChanged);

					// JJD 8/24/11 - TFS84478
					// To handle the case where the DataType was previously set we need to clear some
					// values that might have been cached so that they can be re-cached taking into 
					// account any of the new settings
					_cachedEditAsTypeResolved = null;
					_cachedEditAsTypeResolvedUnderlying = null;
					this.DirtyRecordFilterRelatedCache(true);
                }
            }
        }

		
		
		internal FieldSettings SettingsIfAllocated
		{
			get
			{
				return _settings;
			}
		}

        /// <summary>
        /// Checks if the <see cref="Settings"/> object should be serialized
        /// </summary>
        /// <returns></returns>
        public bool ShouldSerializeSettings()
        {
            return this._settings != null && this._settings.ShouldSerialize();
        }

		/// <summary>
		/// Resets the <see cref="Settings"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetSettings()
		{
			this.Settings = null;
		}

                #endregion //Settings	

                #region SortComparerResolved

        /// <summary>
        /// Gets the resolved comparer to sort <see cref="DataRecord"/>s by this <see cref="Field"/>.
        /// </summary>
		/// <value>An object that inplements the IComparer interface or null if one was not set via the <see cref="FieldSettings.SortComparer"/> property.</value>
 		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Sorting.html">About Sorting</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
		/// </remarks>
		/// <seealso cref="DataRecord"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        /// <seealso cref="FieldSettings.SortComparerProperty"/>
        /// <seealso cref="SortComparerResolved"/>
        /// <seealso cref="FieldSettings.SortComparisonType"/>
        /// <seealso cref="SortStatus"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[ReadOnly(true)]
		public IComparer SortComparerResolved
        {
            get
            {
                IComparer comparer = null;

                if (this._settings != null)
                    comparer = this._settings.SortComparer;

                if (comparer != null)
                    return comparer;

                if (this._owner != null)
                {
                    if (this._owner.HasFieldSettings)
                    {
                        comparer = this._owner.FieldSettings.SortComparer;

                        if (comparer != null)
                            return comparer;
                    }

                    DataPresenterBase layoutOwner = this._owner.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        comparer = layoutOwner.FieldSettings.SortComparer;

                        if (comparer != null)
                            return comparer;
                    }
                }

                return null;
            }
        }

                #endregion //SortComparerResolved

                #region SortComparisonTypeResolved

        /// <summary>
        /// Gets the resolved comparison type for sorting <see cref="DataRecord"/>s by this field.
        /// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Sorting.html">About Sorting</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
		/// </remarks>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="FieldSortComparisonType"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        /// <seealso cref="FieldSettings.SortComparisonType"/>
        /// <seealso cref="FieldSettings.SortComparisonTypeProperty"/>
        /// <seealso cref="SortStatus"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public FieldSortComparisonType SortComparisonTypeResolved
        {
            get
            {
                FieldSortComparisonType comparisonType = FieldSortComparisonType.Default;

                if (this._settings != null)
                    comparisonType = this._settings.SortComparisonType;

                if (comparisonType != FieldSortComparisonType.Default)
                    return comparisonType;

                if (this._owner != null)
                {
                    if (this._owner.HasFieldSettings)
                    {
                        comparisonType = this._owner.FieldSettings.SortComparisonType;

                        if (comparisonType != FieldSortComparisonType.Default)
                            return comparisonType;
                    }

                    DataPresenterBase layoutOwner = this._owner.DataPresenter;

                    if (layoutOwner != null && layoutOwner.HasFieldSettings)
                    {
                        comparisonType = layoutOwner.FieldSettings.SortComparisonType;

                        if (comparisonType != FieldSortComparisonType.Default)
                            return comparisonType;
                    }
                }

                return FieldSortComparisonType.CaseSensitive;
            }
        }

                #endregion //SortComparisonTypeResolved

                #region SortStatus

        private static readonly DependencyPropertyKey SortStatusPropertyKey =
            DependencyProperty.RegisterReadOnly("SortStatus",
			// JJD 11/17/11 - TFS78651 - Optimization - add property changed callback
            //typeof(SortStatus), typeof(Field), new FrameworkPropertyMetadata(SortStatus.NotSorted));
            typeof(SortStatus), typeof(Field), new FrameworkPropertyMetadata(SortStatus.NotSorted, OnSortStatusChanged));
		
		// JJD 11/17/11 - TFS78651 - Optimization
		// cache the status for quicker retrieval
		private SortStatus _cachedSortStatus = SortStatus.NotSorted;
		private static void OnSortStatusChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			Field fld = target as Field;
			fld._cachedSortStatus = (SortStatus)e.NewValue;
		}

        /// <summary>
        /// Identifies the <see cref="SortStatus"/> dependency property
        /// </summary>
        public static readonly DependencyProperty SortStatusProperty =
            SortStatusPropertyKey.DependencyProperty;

        /// <summary>
        /// Returns the current sort status of this field (read-only)
        /// </summary>
        /// <remarks>
        /// <para><see cref="Field"/>s become sorted once corresponding <see cref="FieldSortDescription"/> objects have been added to the <see cref="Owner"/>'s <see cref="FieldLayout.SortedFields"/> collection.</para>
        /// <para></para>
        /// <para>In order to initalize a field as being sorted you need to add a corresponding <see cref="FieldSortDescription"/> object to the <see cref="FieldLayout"/>'s <see cref="FieldLayout.SortedFields"/> collection in response to the <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>'s <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayoutInitialized"/> event.</para>
		/// </remarks>
        /// <seealso cref="FieldLayout"/>
        /// <seealso cref="FieldSortDescription"/>
        /// <seealso cref="FieldSortDescriptionCollection"/>
        /// <seealso cref="FieldSettings.SortComparisonType"/>
        /// <seealso cref="IsGroupBy"/>
        /// <seealso cref="Owner"/>
        /// <seealso cref="FieldLayout.SortedFields"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        /// <seealso cref="FieldSettings.SortComparisonType"/>
        /// <seealso cref="SortStatusProperty"/>
        //[Description("Returns the current sort status of this field (read-only)")]
        //[Category("Behavior")]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public SortStatus SortStatus
        {
            get
            {
				// JJD 11/17/11 - TFS78651 - Optimization
				// Returns the cached status
				//return (SortStatus)this.GetValue(SortStatusProperty);
                return _cachedSortStatus;
            }
        }

                #endregion //SortStatus

				#region SummaryStringFormats

		
		
		/// <summary>
		/// Identifies the <see cref="SummaryStringFormats"/> dependency property
		/// </summary>
		public static readonly DependencyProperty SummaryStringFormatsProperty = DependencyProperty.Register(
				"SummaryStringFormats",
				typeof( string ),
				typeof( Field ),
				new FrameworkPropertyMetadata( null ),
				new ValidateValueCallback( ValidateSummaryStringFormats )
			);

		/// <summary>
		/// Specifies string formats to use to format summary results for one or more calculator types.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// This will be comma separated list of formats where you can specify a string format for 1 or more calculators 
		/// as needed. 
		/// </para>
		/// <para class="body">
		/// <b>Example:</b> ”sum: TOTAL={0:c}, average: AVG={0:c}, count: COUNT={0}”
		/// <br/>
		/// Each comma separated value in the string has a calculator name followed by ‘:’ followed by the format 
		/// for that calculator. With this example, sum will be formatted using ‘TOTAL={0:c}’, average with 
		/// ‘AVG={0:c}' and count using ‘COUNT={0}’.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that you can also specify the string format on individual SummaryDefinition object
		/// using <see cref="SummaryDefinition.StringFormat"/> property.
		/// </para>
		/// </remarks>
		/// <seealso cref="SummaryDefinition.StringFormat"/>
		//[Description( "Specifies string formats to use to format summary results for one or more calculator types." )]
		//[Category( "Data" )]
		[Bindable( true )]
		public string SummaryStringFormats
		{
			get
			{
				return (string)this.GetValue( SummaryStringFormatsProperty );
			}
			set
			{
				this.SetValue( SummaryStringFormatsProperty, value );
			}
		}

		private static bool ValidateSummaryStringFormats( object objVal )
		{
			string val = (string)objVal;

			// If the value is not empty then check if it's valid formats string.
			// 
			if ( !string.IsNullOrEmpty( val ) && !SummaryStringFormatsParser.IsValid( val ) )
				return false;

			return true;
		}

		internal string GetSummaryStringFormat( string calculatorName )
		{
			string summaryFormats = this.SummaryStringFormats;
			if ( !string.IsNullOrEmpty( summaryFormats ) )
			{
				Dictionary<string, string> formats = SummaryStringFormatsParser.Parse( summaryFormats );
				string value;
				if ( null != formats && formats.TryGetValue( calculatorName, out value ) )
					return value;
			}

			return null;
		}

		/// <summary>
		/// Returns true if the SummaryStringFormats property is set to a non-default value.
		/// </summary>
		[EditorBrowsable( EditorBrowsableState.Never )]
		public bool ShouldSerializeSummaryStringFormats( )
		{
			return Utilities.ShouldSerialize( SummaryStringFormatsProperty, this );
		}

		/// <summary>
		/// Resets the SummaryStringFormats property to its default state.
		/// </summary>
		[EditorBrowsable( EditorBrowsableState.Never )]
		public void ResetSummaryStringFormats( )
		{
			this.ClearValue( SummaryStringFormatsProperty );
		}

				#endregion // SummaryStringFormats

				#region SummaryUITypeResolved

		
		
		/// <summary>
		/// Determines various options for the summary calculation selection UI (read-only).
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>SummaryUITypeResolved</b> returns the resolved value based on FieldSettings'
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryUIType"/> property settings. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>
		/// object is exposed on <b>DataPresenterBase</b> (<see cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldSettings"/>), 
		/// FieldLayout (<see cref="Infragistics.Windows.DataPresenter.FieldLayout.FieldSettings"/>) and Field (<see cref="Infragistics.Windows.DataPresenter.Field.Settings"/>).
		/// </para>
		/// <para class="body">
		/// To actually specify summary UI type, use the FieldSettings' 
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryUIType"/> properties.
		/// </para>
		/// <para class="body">
		/// See <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/> for more information.
		/// </para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryUIType"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryDisplayArea"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayout.SummaryDefinitions"/>
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		[Browsable( false )]
		//[Description( "Determines options for summary calculation selection UI (read-only)." )]
		[Bindable( true )]
		[ReadOnly( true )]
		public SummaryUIType SummaryUITypeResolved
		{
			get
			{
				if ( null != _settings )
				{
					SummaryUIType ret = _settings.SummaryUIType;
					if ( SummaryUIType.Default != ret )
						return ret;
				}

				if ( null != _owner )
					return _owner.GetDefaultSummaryUIType( this );

				return SummaryUIType.MultiSelectForNumericsOnly;
			}
		}

				#endregion // SummaryUITypeResolved

				// JJD 2/20/08
                // Added Tag property
                #region Tag

        /// <summary>
        /// Identifies the <see cref="Tag"/> dependency property
        /// </summary>
        public static readonly DependencyProperty TagProperty = FrameworkElement.TagProperty.AddOwner(typeof(Field));

        /// <summary>
        /// Gets or sets an arbitrary object value that can be used to store custom information about this object.
        /// </summary>
        [Localizability(LocalizationCategory.NeverLocalize)]
        // JJD 2/11/09 - TFS10860/TFS13609
        [CloneBehavior(CloneBehavior.ShareInstance)]
        public object Tag
        {
            get 
            { 
                return this.GetValue(TagProperty); 
            }
            set
            {
                this.SetValue(TagProperty, value);
            }
        }

                #endregion //Tag	

				#region ToolTip

		// SSP 6/3/09 - NAS9.2 Field Chooser
		// 

		/// <summary>
		/// Identifies the <see cref="ToolTip"/> dependency property.
		/// </summary>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public static readonly DependencyProperty ToolTipProperty = DependencyProperty.Register(
			"ToolTip",
			typeof( object ),
			typeof( Field ),
			new FrameworkPropertyMetadata( null )
		);

		/// <summary>
		/// Specifies the tooltip for the field. It's displayed when the user hovers the mouse over the field label.
		/// </summary>
		//[Description( "Specifies the tooltip that's displayed when the mouse is hovered over the field label." )]
		//[Category( "Data" )]
		[Bindable( true )]
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public object ToolTip
		{
			get
			{
				return (object)this.GetValue( ToolTipProperty );
			}
			set
			{
				this.SetValue( ToolTipProperty, value );
			}
		}

				#endregion // ToolTip

                #region Visibility

        /// <summary>
        /// Identifies the 'Visibility' dependency property
        /// </summary>
        public static readonly DependencyProperty VisibilityProperty = DependencyProperty.Register("Visibility",
			typeof(Visibility), typeof(Field), 
			new FrameworkPropertyMetadata(KnownBoxes.VisibilityVisibleBox,
				
				
				
				
				
				
				
				
				new PropertyChangedCallback( OnVisibilityChanged )
			)
		);

		// JJD 4/26/07
		// Optimization - cache the property locally
		private Visibility _cachedVisibility = Visibility.Visible;

		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)











#endregion // Infragistics Source Cleanup (Region)


		
		
		
		
		
		private static void OnVisibilityChanged( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			Field field = (Field)dependencyObject;
			Visibility newVal = (Visibility)e.NewValue;

			field._cachedVisibility = newVal;

            // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
            field.BumpLayoutItemVersion();

            // JJD 10/30/08 - TFS7145
            // Raise the prop change event for VisibilityResolved
            field.RaisePropertyChangedEvent("VisibilityResolved");
		}

        /// <summary>
        /// Gets/sets whether this field will be visible.
        /// </summary>
        //[Description("Description")]
        //[Category("Behavior")]
		[Bindable(true)]
		public Visibility Visibility
        {
            get
            {
				// JJD 4/26/07
				// Optimization - use the locally cached property 
				//return (Visibility)this.GetValue(Field.VisibilityProperty);
				return this._cachedVisibility;
            }
            set
            {
                this.SetValue(Field.VisibilityProperty, value);
            }
        }

		/// <summary>
		/// Determines if the <see cref="Visibility"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeVisibility()
        {
            return this.Visibility != Visibility.Visible;
        }

		/// <summary>
		/// Resets the <see cref="Visibility"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetVisibility()
		{
			this.ClearValue(Field.VisibilityProperty);
		}

                #endregion //Visibility

                #region VisibilityResolved

        /// <summary>
        /// Gets the resolved visibility for this field.
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		[Bindable(true)]
		[ReadOnly(true)]
		public Visibility VisibilityResolved
        {
            get
            {
				// SSP 7/17/07 BR22919
				// Added CellVisibilityWhenGrouped property so you can hide the group-by fields when
				// the user groups records by them.
				// 
				if ( _isGroupBy && Visibility.Collapsed != _cachedVisibility )
				{
					Visibility tmp = this.CellVisibilityWhenGroupedResolved;
					if ( Visibility.Visible != tmp )
						return tmp;
				}

				// JJD 4/26/07
				// Optimization - used the locally cached property 
				//return this.Visibility;
				return this._cachedVisibility;
            }
        }

                #endregion //VisibilityResolved

				// AS 6/22/09 NA 2009.2 Field Sizing
				#region Width

		/// <summary>
		/// Identifies the <see cref="Width"/> dependency property
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public static readonly DependencyProperty WidthProperty = FieldSettings.WidthProperty.AddOwner(typeof(Field),
			new FrameworkPropertyMetadata(new PropertyChangedCallback(OnWidthHeightChanged)));

		/// <summary>
		/// Returns or sets a FieldLength instance that represents the width of the field.
		/// </summary>
		/// <seealso cref="WidthProperty"/>
		/// <seealso cref="Height"/>
		//[Description("Returns or sets a FieldLength instance that represents the width of the field.")]
		//[Category("Behavior")]
		[Bindable(true)]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public FieldLength? Width
		{
			get
			{
				return (FieldLength?)this.GetValue(Field.WidthProperty);
			}
			set
			{
				this.SetValue(Field.WidthProperty, value);
			}
		}

				#endregion //Width

            #endregion // Public Properties

            #region Internal Properties

                // JJD 8/19/09 - NA 2009 Vol 2 - Cross Band grouping - added
                
                #region AllowUnGrouping

		internal bool AllowUnGrouping
        {
            get
            {
                Nullable<bool> allowGroupBy = new Nullable<bool>();
                
                if ( this._settings != null)
                    allowGroupBy = this._settings.AllowGroupBy;

                if (allowGroupBy.HasValue)
                    return allowGroupBy.Value;

                if (this._owner != null)
                {
                    // JJD 8/19/09 - NA 2009 Vol 2 - Cross Band grouping
                    
                    // Pass null in as the default value so we will return true or false
                    // based on the data type if the property descriptor has been ininitalized,
                    // otherwise default to true
                    //return this._owner.GetDefaultAllowGroupBy(this);
                    return this._owner.GetDefaultAllowGroupBy(this, this._isPropertyDescriptorInitialized ? null : (bool?)true);
                }

                return true;
            }
        }

                #endregion //AllowUnGrouping

				// AS 6/9/09 NA 2009.2 Field Sizing
				#region AutoSizeOptionsResolved

		internal FieldAutoSizeOptions AutoSizeOptionsResolved
		{
			get
			{
				return GetResolvedValue<FieldAutoSizeOptions?>(FieldSettings.AutoSizeOptionsProperty, null, FieldAutoSizeOptions.All).Value;
			}
		}

				#endregion // AutoSizeOptionsResolved

				// AS 6/22/09 NA 2009.2 Field Sizing
				#region AutoSizeScopeResolved

		internal FieldAutoSizeScope AutoSizeScopeResolved
		{
			get
			{
				return GetResolvedValue<FieldAutoSizeScope>(FieldSettings.AutoSizeScopeProperty, FieldAutoSizeScope.Default, FieldAutoSizeScope.RecordsInView);
			}
		}

				#endregion // AutoSizeScopeResolved

				// AS 7/31/09 NA 2009.2 Field Sizing
				#region AutoSizeVersion
		internal int AutoSizeVersion
		{
			get { return _autoSizeVersion; }
			set { _autoSizeVersion = value; }
		} 
				#endregion //AutoSizeVersion

				// JJD 2/7/08 - BR30444 
                // Moved to public property and added corresponding public property on FieldSettings
                #region Old Code 

        //        // JJD 5/4/07 - Optimization
        //        // Added support for label virtualization
        //        #region AllowLabelVirtualizationResolved

        //internal bool AllowLabelVirtualizationResolved
        //{
        //    get
        //    {
        //        if (this._cachedLabel is string ||
        //            this._cachedLabel == null)
        //            return true;

        //        return false;
        //    }
        //}
        //        #endregion //AllowLabelVirtualizationResolved	

                #endregion //Old Code 

				// JJD 3/9/11 - TFS67970 - Optimization - cache the binding
				#region CellContentAlignmentBinding

		// JJD 3/9/11 - TFS67970 - Optimization - cahe the binding
		internal Binding CellContentAlignmentBinding
		{
			get
			{
				if (_cellContentAlignmentBinding == null)
					_cellContentAlignmentBinding = Utilities.CreateBindingObject("CellContentAlignmentResolved", BindingMode.OneWay, this);

				return _cellContentAlignmentBinding;
			}
		}

				#endregion //CellContentAlignmentBinding
        
				// JJD 5/3/07 - Optimization
				// Cache a key so that multiple field's can share a cell elment in the template record
				#region CellElementKey

		internal CellElementKey CellElementKey
		{
			get
			{
				this.VerifyLayoutVersion();

				if (this._cellElementKey == null)
					this._cellElementKey = new CellElementKey(this);

				return this._cellElementKey;
			}
		}

				#endregion //CellElementKey	
    
                // AS 12/9/08 NA 2009 Vol 1 - Fixed Fields
                #region CellLayoutItem
        internal FieldLayoutItem CellLayoutItem
        {
            get
            {
                if (this._cellLayoutItem == null)
                    this._cellLayoutItem = new FieldLayoutItem(this, false);

                return this._cellLayoutItem;
            }
        }
                #endregion //CellLayoutItem

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                #region CellLayoutConstraint
        internal IGridBagConstraint CellLayoutConstraint
        {
            get
            {
                if (this._owner != null && this._owner.UseCellPresenters)
                    return this.CellLayoutItem;

                return this.LayoutConstraint;
            }
        } 
                #endregion //CellLayoutConstraint

				#region CellPresenterStyleResolved

		internal Style CellPresenterStyleResolved
		{
			get
			{
                
#region Infragistics Source Cleanup (Region)




















#endregion // Infragistics Source Cleanup (Region)

                return GetFieldSettingsStyleResolved(FieldSettings.CellPresenterStyleProperty);
			}
		}

				#endregion //CellPresenterStyleResolved

				#region CellValuePresenterStyleResolved

		internal Style CellValuePresenterStyleResolved
		{
			get
			{
                
#region Infragistics Source Cleanup (Region)




















#endregion // Infragistics Source Cleanup (Region)

                return GetFieldSettingsStyleResolved(FieldSettings.CellValuePresenterStyleProperty);
			}
		}

				#endregion //CellValuePresenterStyleResolved

				#region DataPresenter

		
		
		internal DataPresenterBase DataPresenter
		{
			get
			{
				FieldLayout owner = _owner;
				return null != owner ? owner.DataPresenter : null;
			}
		}

				#endregion // DataPresenter

				#region DataTypeUnderlying

		// SSP 5/23/07
		// 
		/// <summary>
		/// If the DataType is a Nullable type then returns the underlying type
		/// otherwise returns the DataType.
		/// </summary>
		internal Type DataTypeUnderlying
		{
            get
            {
                // JJD 4/17/08 - Optimization
                // Use the cached underlying type
                //return Utilities.GetUnderlyingType(this.DataType);
                return this._cachedDataTypeUnderlying;
            }
		}
				#endregion // DataTypeUnderlying

                // JJD 5/29/09 - TFS18063 - added
                #region EditAsTypeResolvedUnderlying

        internal Type EditAsTypeResolvedUnderlying
        {
            get
            {
                if (this._cachedEditAsTypeResolvedUnderlying == null)
                    this._cachedEditAsTypeResolvedUnderlying = Utilities.GetUnderlyingType(this.EditAsTypeResolved);

                return this._cachedEditAsTypeResolvedUnderlying;
            }
        }

                #endregion //EditAsTypeResolvedUnderlying

				#region EditorStyleResolved

		internal Style EditorStyleResolved
		{
			get
			{
                
#region Infragistics Source Cleanup (Region)




















#endregion // Infragistics Source Cleanup (Region)

                return GetFieldSettingsStyleResolved(FieldSettings.EditorStyleProperty);
			}
		}

				#endregion //EditorStyleResolved

                // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                #region FilterCellElementKey

        internal FilterCellElementKey FilterCellElementKey
        {
            get
            {
                this.VerifyLayoutVersion();

                if (_filterCellElementKey == null)
                    _filterCellElementKey = new FilterCellElementKey(this);

                return _filterCellElementKey;
            }
        }

                #endregion //FilterCellElementKey	

                // JJD 12/22/08 - added
                #region FilterEditAsTypeResolved

        internal Type FilterEditAsTypeResolved
        {
            get
            {
                switch (this.FilterOperandUITypeResolved)
                {
                    case FilterOperandUIType.Combo:
                    case FilterOperandUIType.DropDownList:
                        return typeof(object);

                    case FilterOperandUIType.UseFieldEditor:
                        return this.EditAsTypeResolved;
                    default:
                        return typeof(string);
                }
            }
        }

                #endregion //FilterEditAsTypeResolved	

                // JJD 12/22/08 - added
                #region FilterEditorTypeResolved

        internal Type FilterEditorTypeResolved
        {
            get
            {



                switch (this.FilterOperandUITypeResolved)
                {
                    case FilterOperandUIType.Combo:
                    case FilterOperandUIType.DropDownList:
                        return typeof(XamComboEditor);

                    case FilterOperandUIType.UseFieldEditor:
                        return this.EditorTypeResolved;
                    default:
                        return typeof(XamTextEditor);
                }

            }
        }

                #endregion //FilterEditorTypeResolved	
    
				// AS - NA 11.2 Excel Style Filtering
				#region FilterLabelIconDropDownTypeResolved
		internal FilterLabelIconDropDownType FilterLabelIconDropDownTypeResolved
		{
			get
			{
				return this.GetResolvedValue<FilterLabelIconDropDownType>(FieldSettings.FilterLabelIconDropDownTypeProperty, FilterLabelIconDropDownType.Default, FilterLabelIconDropDownType.SingleSelect);
			}
		} 
				#endregion //FilterLabelIconDropDownTypeResolved

                #region GridPosition

        internal FieldGridPosition GridPosition { get { return this._cellPosition; } }

                #endregion //GridPosition

				// JJD 6/30/11 - TFS80466 - added
				#region Has...StyleSelector properties

		internal bool HasCellValuePresenterStyleSelector { get { return _hasCellValuePresenterStyleSelector; } }
		internal bool HasEditorStyleSelector { get { return _hasEditorStyleSelector; } }

				#endregion //Has...StyleSelector properties	

				#region HasFormula

		// SSP 9/30/11 Calc
		// 
		/// <summary>
		/// Returns true if Formula is set on the calculation settings.
		/// </summary>
		internal bool HasFormula
		{
			get
			{

				return null != _calculationSettings && !string.IsNullOrEmpty( _calculationSettings.Formula );



			}
		} 

				#endregion // HasFormula

				#region IgnoreFieldVisibilityOverrides

		// SSP 6/23/09 - NAS9.2 Field Chooser
		// This is used by the field chooser to force a field to be visible even if it's
		// a group-by field and CellVisibilityWhenGrouped is set to a value other than Visible.
		// 
		internal bool IgnoreFieldVisibilityOverrides
		{
			get
			{
				return _ignoreFieldVisibilityOverrides;
			}
			set
			{
				if ( _ignoreFieldVisibilityOverrides != value )
				{
					Visibility oldVisibility = this.VisibilityResolved;

					_ignoreFieldVisibilityOverrides = value;

					if ( oldVisibility != this.VisibilityResolved )
					{
						// AS 7/7/09 TFS19145
						// Since the actual visibility is changing we should notify the owner.
						//
						if (null != _owner)
							_owner.OnFieldVisibilityChanged(this);

						this.RaisePropertyChangedEvent( "VisibilityResolved" );
					}
				}
			}
		}

				#endregion // IgnoreFieldVisibilityOverrides

                // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
                #region IsCellVirtualized
        internal bool IsCellVirtualized
        {
            get { return GetFlag(FieldFlags.CellVirtualized); }
            set { SetFlag(FieldFlags.CellVirtualized, value); }
        }
                #endregion //IsCellVirtualized

				// JJD 12/2/11 - TFS21317 - added
				#region IsDataTypeExplicitySet

		internal bool IsDataTypeExplicitySet { get { return _dataTypeExplicitySet; } }

				#endregion //IsDataTypeExplicitySet	
    
                // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                #region IsFilterCellVirtualized
        internal bool IsFilterCellVirtualized
        {
            get { return GetFlag(FieldFlags.FilterCellVirtualized); }
            set { SetFlag(FieldFlags.FilterCellVirtualized, value); }
        }
                #endregion //IsFilterCellVirtualized

                // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
                #region IsInLayout
        internal bool IsInLayout
        {
            get { return GetFlag(FieldFlags.IsInLayout); }
            set { SetFlag(FieldFlags.IsInLayout, value); }
        }
                #endregion //IsInLayout

                // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
                #region IsLabelVirtualized
        internal bool IsLabelVirtualized
        {
            get { return GetFlag(FieldFlags.LabelVirtualized); }
            set { SetFlag(FieldFlags.LabelVirtualized, value); }
        }
                #endregion //IsLabelVirtualized

                // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
                #region LabelElementKey

        internal LabelElementKey LabelElementKey
        {
            get
            {
                this.VerifyLayoutVersion();

                if (this._labelElementKey == null)
                    this._labelElementKey = new LabelElementKey(this);

                return this._labelElementKey;
            }
        }

                #endregion //LabelElementKey	

                // AS 12/9/08 NA 2009 Vol 1 - Fixed Fields
                #region LabelLayoutItem
        internal FieldLayoutItem LabelLayoutItem
        {
            get
            {
                if (this._labelLayoutItem == null)
                    this._labelLayoutItem = new FieldLayoutItem(this, true);

                return this._labelLayoutItem;
            }
        } 
                #endregion //LabelLayoutItem

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                #region LabelLayoutConstraint
        internal IGridBagConstraint LabelLayoutConstraint
        {
            get
            {
                if (this._owner != null && this._owner.UseCellPresenters)
                    return this.LabelLayoutItem;

                return this.LayoutConstraint;
            }
        } 
                #endregion //LabelLayoutConstraint

                // AS 12/11/08 TFS11518
                #region LabelLineCount
        internal int LabelLineCount
        {
            get { return this._labelLineCount; }
        } 
                #endregion //LabelLineCount

				#region LastFieldLabelAccessed

		// AS 4/12/11 TFS62951
		// The only reason we have this is so that we can get to its containing 
		// record presenter from within the GetNearestCompatibleRecordPresenter.
		// The problem was when the LP was recycled we would have returned null
		// so we wouldn't be able to get to the record presenter. We also shouldn't 
		// have used a strong reference to the label presenter. So we'll cache 
		// this on the FieldLayout instead and use a weak reference.
		//
		//internal LabelPresenter LastFieldLabelAccessed
		//{
		//    get
		//    {
		//        if (this._lastFieldLabel == null)
		//            return null;
		//
		//        // verify the LabelPresenter is still valid
		//        if (this._lastFieldLabel.Field != this)
		//            this._lastFieldLabel = null;
		//
		//        return this._lastFieldLabel;
		//    }
		//    set
		//    {
		//        this._lastFieldLabel = value;
		//    }
		//}

				#endregion //LastFieldLabelAccessed

                // AS 12/9/08 NA 2009 Vol 1 - Fixed Fields
                #region LayoutConstraint
        internal GridBagConstraint LayoutConstraint
        {
            get
            {
                if (null == this._layoutConstraint)
                    this._layoutConstraint = new GridBagConstraint();

                return this._layoutConstraint;
            }
        } 
                #endregion //LayoutConstraint

                // AS 12/18/08 NA 2009 Vol 1 - Fixed Fields
                #region LayoutItemVersion
        internal int LayoutItemVersion
        {
			// AS 11/29/10 TFS60418
			// Now include the new _layoutItemVersion so we can 
			// identify when just this field's information has been changed.
			//
            get { return _layoutItemVersion + (this._owner != null ? this._owner.LayoutItemVersion : 0); }
        } 
                #endregion //LayoutItemVersion

				// AS 4/27/09 TFS17122
				#region NavigationIndex
		internal int NavigationIndex
		{
			get
			{
				FieldLayout fl = _owner;
				if (null != _owner &&
					null != _owner.StyleGenerator)
				{
					_navigationIndex = _owner.StyleGenerator.GridFieldMap.GetNavigationIndex(this, _navigationIndex);
				}

				return _navigationIndex;
			}
		} 
				#endregion //NavigationIndex

                #region InternalVersion

        internal static readonly DependencyProperty InternalVersionProperty = FieldLayout.InternalVersionProperty.AddOwner(typeof(Field));

        internal int InternalVersion
        {
            get
            {
                return (int)this.GetValue(Field.InternalVersionProperty);
            }
            set
            {
                this.SetValue(Field.InternalVersionProperty, value);
            }
        }

                #endregion //InternalVersion

				#region IsEditAsTypeNumeric

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Returns true if the EditAsTypeResolved is numeric.
		/// </summary>
		internal bool IsEditAsTypeNumeric
		{
			get
			{
				Type dataType = this.EditAsTypeResolved;
				return Utilities.IsNumericType( Utilities.GetUnderlyingType( dataType ) );
			}
		}

				#endregion // IsEditAsTypeNumeric

                #region IsExpandableByDefault

        internal bool IsExpandableByDefault
        {
            get
            {
                return this._isExpandableByDefault;
            }
        }

                #endregion //IsExpandableByDefault

				// JM 07-29-09 TFS 19241 - Added
				#region IsPropertyDescriptorInitialized

		internal bool IsPropertyDescriptorInitialized
		{
			get { return this._isPropertyDescriptorInitialized; }
		}

				#endregion //IsPropertyDescriptorInitialized

				#region IsVisibleInCellArea

		internal bool IsVisibleInCellArea
        {
            get
            {
				// SSP 8/24/09 - NAS9.2 Field chooser - TFS19140
				// Moved the commented out code into the new VisibilityInCellArea
				// property. Use that instead.
				// 
				// ----------------------------------------------------------------
				return Visibility.Collapsed != this.VisibilityInCellArea;
				
#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

				// ----------------------------------------------------------------
            }
		}

				#endregion //IsVisibleInCellArea

				#region ExplicitResizeInfo

		
		
		
		
		
		internal FieldResizeInfo ExplicitResizeInfo
		{
			get 
			{
				if ( null == _explicitResizeInfo )
					_explicitResizeInfo = new FieldResizeInfo( this );

				return _explicitResizeInfo;
			}
		}

		internal FieldResizeInfo ExplicitResizeInfoIfAllocated
		{
			get
			{
				return _explicitResizeInfo;
			}
		}

				#endregion //ExplicitResizeExtent

				// JJD 6/27/11 - TFS36572 - added
				#region PropertyDescriptorVersion

		internal int PropertyDescriptorVersion { get { return _propertyDescriptorVersion; } }

				#endregion //PropertyDescriptorVersion	
       
				#region SupportDataErrorInfoResolved

		
		
		internal bool SupportDataErrorInfoResolved
		{
			get
			{
                
                
                
                
                if ( -1 == _cachedSupportDataErrorInfoResolved )
                {
                    bool? val = this.GetResolvedValue<bool?>( FieldSettings.SupportDataErrorInfoProperty, null, null );
                    _cachedSupportDataErrorInfoResolved = ! val.HasValue ? 0 : ( val.Value ? 1 : 2 );
                }

                if ( 0 != _cachedSupportDataErrorInfoResolved )
                    return 1 == _cachedSupportDataErrorInfoResolved;

                
#region Infragistics Source Cleanup (Region)






























#endregion // Infragistics Source Cleanup (Region)

                

				FieldLayout fl = _owner;
				if ( null != fl )
				{
					SupportDataErrorInfo supportDataErrorInfo = fl.SupportDataErrorInfoResolvedDefault;
					return SupportDataErrorInfo.CellsOnly == supportDataErrorInfo 
						|| SupportDataErrorInfo.RecordsAndCells == supportDataErrorInfo;
				}

				return false;
			}
		}

				#endregion // SupportDataErrorInfoResolved

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                #region SyncCellLabelWidth
        internal bool SyncCellLabelWidth
        {
            get
            {
                FieldLayout owner = this._owner;

                if (null != owner)
                {
                    if (owner.UseCellPresenters)
                    {
                        return GridUtilities.IsLabelAboveBelowCell(this.CellContentAlignmentResolved);
                    }
                    else
                    {
                        return owner.IsHorizontal == false &&
                            owner.CellPresentation == CellPresentation.GridView;
                    }
                }

                return false;
            }
        } 
                #endregion //SyncCellLabelWidth

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                #region SyncCellLabelHeight
        internal bool SyncCellLabelHeight
        {
            get
            {
                FieldLayout owner = this._owner;

                if (null != owner)
                {
                    if (owner.UseCellPresenters)
                    {
                        return GridUtilities.IsLabelLeftRightCell(this.CellContentAlignmentResolved);
                    }
                    else
                    {
                        return owner.IsHorizontal &&
                            owner.CellPresentation == CellPresentation.GridView;
                    }
                }

                return false;
            }
        } 
                #endregion //SyncCellLabelHeight

				// AS 5/1/07 Performance
				#region TemplateCellIndex
		internal int TemplateCellIndex
		{
			get { return this._templateCellIndex; }
			set { this._templateCellIndex = value; }
		} 
				#endregion //TemplateCellIndex

				// JJD 3/9/11 - TFS67970 - Optimization - cache the binding
				#region VisibilityBinding

		// JJD 3/9/11 - TFS67970 - Optimization - cahe the binding
		internal Binding VisibilityBinding
		{
			get
			{
				if (_visibilityBinding == null)
					_visibilityBinding = Utilities.CreateBindingObject("VisibilityResolved", BindingMode.OneWay, this);

				return _visibilityBinding;
			}
		}

				#endregion //VisibilityBinding	
    
				#region VisibilityInCellArea

		// SSP 8/24/09 - NAS9.2 Field chooser - TFS19140
		// 
		/// <summary>
		/// Returns the visibility state of the field in the cell area.
		/// </summary>
		internal Visibility VisibilityInCellArea
		{
			get
			{
				if ( this.IsExpandableResolved )
					return Visibility.Collapsed;

				return this.VisibilityResolved;
			}
		}

				#endregion // VisibilityInCellArea

            #endregion //Internal Properties

            #region Private Properties

                // JJD 4/26/10 - TFS30833 
                // Made ConverterCultureResolved public and made ConverterCultureResolvedImpl a private helper
                // JJD 3/5/08 - Added
                #region ConverterCultureResolvedImpl

        private CultureInfo ConverterCultureResolvedImpl
        {
            get
            {
                // JJD 5/29/09 - TFS18063 
                // Use the cached convertor culture
                //CultureInfo ci = this.ConverterCulture;
                CultureInfo ci = this._converterCulture;

                if (ci != null)
                    return ci;

                if (this._owner != null)
                {
                    DataPresenterBase dp = this._owner.DataPresenter;

                    if (dp != null)
                        return dp.DefaultConverterCulture;
                }

                return null;
            }
        }

                #endregion //ConverterCultureResolvedImpl	

        

        #region DefaultCellHeight

        private double DefaultCellHeight
		{
			get
			{
				
#region Infragistics Source Cleanup (Region)


























#endregion // Infragistics Source Cleanup (Region)

				return this.GetDefaultHeight(false);
			}
		}

				#endregion //DefaultCellHeight	
    
				#region DefaultCellWidth

		private double DefaultCellWidth
		{
			get
			{
                
#region Infragistics Source Cleanup (Region)







#endregion // Infragistics Source Cleanup (Region)


				
#region Infragistics Source Cleanup (Region)


























#endregion // Infragistics Source Cleanup (Region)

				return this.GetDefaultWidth(false);
			}
		}
				#endregion //DefaultCellWidth	

            #endregion //Private Properties

        #endregion //Properties

        #region Methods

			#region Public Methods

				// AS 6/9/09 NA 2009.2 Field Sizing
				#region CalculateAutoSizeExtent
		/// <summary>
		/// Returns the preferred size for the field based on the current resolved <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AutoSizeOptions"/>
		/// </summary>
		/// <returns>A double that represents the preferred size for the field or double.NaN if a value could not be calculated.</returns>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public double CalculateAutoSizeExtent()
		{
			return this.CalculateAutoSizeExtent(this.AutoSizeOptionsResolved, this.AutoSizeScopeResolved);
		}

		/// <summary>
		/// Returns the preferred size for the field based on the specified <see cref="FieldAutoSizeOptions"/>.
		/// </summary>
		/// <param name="options">Provides information about what aspects should affect the size of the field.</param>
		/// <param name="scope">Indicates which records should be evaluated</param>
		/// <returns>A double that represents the preferred size for the field or double.NaN if a preferred size could not be calculated.</returns>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public double CalculateAutoSizeExtent(FieldAutoSizeOptions options, FieldAutoSizeScope scope)
		{
			AutoSizeFieldHelper helper;

			if (!this.CalculateAutoSizeExtent(options, scope, out helper))
				return double.NaN;

			return helper.GetExtent(this);
		}

		private bool CalculateAutoSizeExtent(FieldAutoSizeOptions options, FieldAutoSizeScope scope, out AutoSizeFieldHelper helper)
		{
			helper = new AutoSizeFieldHelper(this, options, scope);
			FieldLayout fl = this.Owner;

			if (fl == null)
				throw new InvalidOperationException(DataPresenterBase.GetString("LE_NotInFieldLayoutFields"));

			DataPresenterBase dp = fl.DataPresenter;

			if (dp == null)
				throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_5"));

			// AS 8/19/09 TFS21036
			//helper.ExitEditModeIfNeeded();
			if (!helper.ExitEditModeIfNeeded())
				return false;

			AutoSizeCalculationFlags flags = AutoSizeCalculationFlags.RecalculateRecords
				| AutoSizeCalculationFlags.UseTemplateRecordAsFallback; // AS 8/10/11 TFS83904
			return helper.Calculate(dp.Records, AutoSizeFieldHelper.GetNestingDepth(fl), flags, null );
		}

				#endregion //CalculateAutoSizeExtent

				#region GetPropertyDescriptor

		// SSP 2/2/10 - CellsInViewChanged event
		// Added GetPropertyDescriptor method.
		// 
		/// <summary>
		/// Returns the property descriptor used by this field when retrieving cell data for the specified data record.
		/// </summary>
		/// <param name="dataRecord">Data record.</param>
		/// <returns>PropertyDescriptor instance.</returns>
		/// <remarks>
		/// <para class="body">
		/// <b>GetPropertyDescriptor</b> method is used to get the PropertyDescriptor used by this field. With
		/// homogeneous data source, all data records from a field layout will use the same PropertyDescriptor
		/// for a field.
		/// </para>
		/// </remarks>
		/// <seealso cref="DataRecord.GetCellValue( Field )"/>
		/// <seealso cref="DataRecord.SetCellValue( Field, object )"/>
		public PropertyDescriptor GetPropertyDescriptor( DataRecord dataRecord )
		{
			return dataRecord.GetPropertyDescriptor( this );
		}

				#endregion // GetPropertyDescriptor

				// AS 6/9/09 NA 2009.2 Field Sizing
				#region PerformAutoSize
		/// <summary>
		/// Updates the customized preferred size for the field based on the current <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AutoSizeOptions"/>
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public void PerformAutoSize()
		{
			this.PerformAutoSize(this.AutoSizeOptionsResolved, this.AutoSizeScopeResolved);
		}

		/// <summary>
		/// Updates the customized preferred size for the field based on the specified <see cref="FieldAutoSizeOptions"/>
		/// </summary>
		/// <param name="options">Provides information about what aspects should affect the size of the field.</param>
		/// <param name="scope">Indicates which records should be evaluated</param>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public void PerformAutoSize(FieldAutoSizeOptions options, FieldAutoSizeScope scope)
		{
			this.PerformAutoSize(options, scope, false);
		}

		/// <summary>
		/// Updates the customized preferred size for the field
		/// </summary>
		/// <param name="options">The options to include when calculating the size</param>
		/// <param name="scope">Indicates which records should be evaluated</param>
		/// <param name="addToUndo">True if the operation should be added to the undo stack</param>
		internal void PerformAutoSize(FieldAutoSizeOptions options, FieldAutoSizeScope scope, bool addToUndo)
		{
			AutoSizeFieldHelper helper;
			
			if (!this.CalculateAutoSizeExtent(options, scope, out helper))
				return;

			FieldLayout fl = this.Owner;
			DataPresenterBase dp = fl.DataPresenter;
			ViewBase view = dp.CurrentViewInternal;

			// if the view doesn't support resizing then exit
			if (!view.IsLogicalFieldWidthResizingAllowed)
				return;

			bool isHorz = fl.IsHorizontal;
			FieldGridBagLayoutManager lm = fl.LabelLayoutManager;

			Size preferredSize = lm.CalculatePreferredSize();
			// AS 6/29/10 TFS32094
			//bool isAutoFitHeight = fl.IsAutoFitHeight;
			//bool isAutoFitWidth = fl.IsAutoFitWidth;
			bool isAutoFitHeight = fl.IsGridBagAutoFitHeight;
			bool isAutoFitWidth = fl.IsGridBagAutoFitWidth;

			// for autofit we need a record element to provide the constraining cell area extents.
			if (isAutoFitHeight || isAutoFitWidth)
			{
				Utilities.DependencyObjectSearchCallback<DataRecordPresenter> callback = delegate(DataRecordPresenter rp)
				{
					return rp.FieldLayout == this.Owner;
				};

				DataRecordPresenter drp = Utilities.GetDescendantFromType(dp, true, callback,
					// AS 9/4/09 Optimization
					new Type[] { typeof(RecordCellAreaBase), typeof(GroupByAreaBase) });

				if (null != drp)
				{
					if (isAutoFitHeight)
						preferredSize.Height = drp.AutoFitCellAreaHeight;

					if (isAutoFitWidth)
					{
						// AS 9/4/09 TFS21657
						//preferredSize.Width = drp.AutoFitCellAreaHeight;
						preferredSize.Width = drp.AutoFitCellAreaWidth;
					}
				}
			}

			object rectContext = new Rect(preferredSize);
			List<FieldLayoutItemBase> layoutItems = new List<FieldLayoutItemBase>();

			FieldLayoutItemBase labelItem = lm.GetLayoutItem(this, true);
			FieldLayoutItemBase cellItem = lm.GetLayoutItem(this, false);

			if (null != labelItem)
				layoutItems.Add(labelItem);

			if (null != cellItem)
				layoutItems.Add(cellItem);

			Dictionary<ILayoutItem, Size> preferredSizes = helper.GetPreferredSizes(lm, layoutItems);

			Dictionary<ILayoutItem, bool> autoSizeWidthStates;
			Dictionary<ILayoutItem, bool> autoSizeHeightStates;
			Dictionary<ILayoutItem, Size> newExtents = lm.PerformAutoSize(CalcSizeLayoutContainer.Instance, rectContext, preferredSizes, isAutoFitWidth, isAutoFitHeight, out autoSizeWidthStates, out autoSizeHeightStates);

			lm.ResizeItems(newExtents, !isHorz, null, addToUndo, ItemSizeType.ExplicitAutoSize, !isHorz ? autoSizeWidthStates : autoSizeHeightStates);
		}
				#endregion //PerformAutoSize

			#endregion //Public Methods

            #region Internal Methods

                // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
                #region BumpLayoutItemVersion
        /// <summary>
        /// The LayoutItemVersion is used to control when the cached layout information for a specific field.
        /// </summary>
        internal void BumpLayoutItemVersion()
        {
			// AS 11/29/10 TFS60418
			_layoutItemVersion++;

            if (null != this._owner)
            {
				// AS 11/29/10 TFS60418
				// When the field's layout version is bumped do not dirty 
				// the fieldlayout's version since that will cause every 
				// field to retreive its constraints again.
				//
				//this._owner.BumpLayoutItemVersion();
                this._owner.BumpLayoutItemVersion(false);
            }
        }
                #endregion //BumpLayoutItemVersion

				// JJD 6/27/11 - TFS36572 - added
				#region BumpPropertyDescriptorVersion

		internal void BumpPropertyDescriptorVersion()
		{
			_propertyDescriptorVersion++;
			this.RaisePropertyChangedEvent("PropertyDescriptorVersion");
		}

				#endregion //BumpPropertyDescriptorVersion	

                #region BumpVersion

        internal void BumpVersion()
        {
            this.InternalVersion++;

            this.Owner.DataPresenter.InvalidateItemsHost();
        }

                #endregion //BumpVersion

				#region ClearUserResize

		
		
		/// <summary>
		/// Clears user field resize information and reverts field extents back to their default values.
		/// </summary>
		internal void ClearUserResize( )
		{
			if ( null != _explicitResizeInfo )
			{
				_explicitResizeInfo.Reset( );

				// AS 9/30/09 TFS22891
				// This isn't directly related to this bug but I was thinking about this while 
				// fixing this issue. Essentially if the user resized a field that was initial 
				// auto or the developer loaded a layout that has resized extents for an initial 
				// auto field, if the customizations are cleared we are going to throw away 
				// that user resize info (which is correct) but for an initial auto field its 
				// just going to revert to the default width. We may never have even calculated 
				// an initial auto extent if the customizations were loaded before the calculation 
				// occurred. It seems that the correct thing to do would be to reset the initial 
				// pending flag for such a field.
				//
				bool isHorz = _owner != null && _owner.IsHorizontal;

				if (this.GetWidthOrHeight(!isHorz).IsInitialAuto)
					_hasPendingInitialAutoSize = true;
			}
		}

				#endregion // ClearUserResize

                // JJD 9/10/08 - added clone support for printing
                #region Clone


        internal Field Clone(bool includeSettings)
        {
            Field clone = Activator.CreateInstance(this.GetType()) as Field;

            clone.InitializeFrom(this);

            if (includeSettings && this.HasSettings)
            {
                // JJD 2/9/09 - TFS13678
                // Pass true as 2nd param to copy over those properties that are marked 
                // DesignerSerializationVisibility.Hidden
                //clone.Settings = DataPresenterReportControl.CloneHelper(this.Settings) as FieldSettings;
                clone.Settings = DataPresenterReportControl.CloneHelper(this.Settings, true) as FieldSettings;
            }

            return clone;

        }

                #endregion //Clone

        // JJD 3/5/08 - Added support for Converter properties
                #region ConvertValue

		// SSP 3/25/10 TFS26315
		// Added record parameter.
		// 
        //internal object ConvertValue(object value)
		internal object ConvertValue( object value, DataRecord record )
        {
			if ( this._converter != null )
			{
				// SSP 3/25/10 TFS26315
				// If cell's EditAsType is set then use that. Also pass along
				// record for the converter parameter if none has been specified.
				// 
				// --------------------------------------------------------------
				//return this._converter.Convert( value, this.EditAsTypeResolved, this.ConverterParameter, this.ConverterCultureResolved );
				Cell cell = null != record ? record.GetCellIfAllocated( this ) : null;
				Type editAsTypeResolved = null != cell ? cell.EditAsTypeResolved : this.EditAsTypeResolved;

				object converterParameter = this.GetConverterParameterResolved( record );

				return this._converter.Convert( value, editAsTypeResolved, converterParameter, this.ConverterCultureResolved );
				// --------------------------------------------------------------
			}

            return value;
        }

                #endregion //ConvertValue	

				// AS 8/25/11 TFS84612
				#region DirtyCellContentAlignmentCache
		internal void DirtyCellContentAlignmentCache()
		{
			_cachedCellContentAlignmentResolved = null;
		}
				#endregion //DirtyCellContentAlignmentCache

				#region DirtyRecordFilterRelatedCache

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		internal void DirtyRecordFilterRelatedCache( bool verify )
		{
			_isFilterRecordCacheDirty = true;

			if ( verify )
				this.VerifyRecordFilterRelatedCache( );
		}

				#endregion // DirtyRecordFilterRelatedCache
    
				#region DoesPropertyMatch

		internal bool DoesPropertyMatch(PropertyDescriptor pd)
        {
			if (pd == null ||
				this is UnboundField)
				return false;

			// do a case sensitive match
			return this.Name == pd.Name;
		}

				#endregion //DoesPropertyMatch

				// AS 6/9/09 NA 2009.2 Field Sizing
				#region GetAutoFitWeight
		internal float GetAutoFitWeight(bool cell, bool weightX, AutoFitMode autoFitMode)
		{
			float weight = GetAutoFitWeight(cell, weightX);

			// AS 10/9/09 NA 2010.1 - CardView
			// We want the cells to take up the distribution space (at least in card view)
			// and not the labels.
			//
			if (cell && weight == 0)
			{
				switch (autoFitMode)
				{
					case AutoFitMode.Default:
					case AutoFitMode.Always:
						{
							FieldLayout fl = this._owner;

							// AS 1/25/09
							// We should only be doing this when the labels are with the 
							// cells and even then I'm going to limit this to card view 
							// since this has not come up for grid view before and in 
							// carousel view (the only previous cardview impl) the labels 
							// we not displayed by default.
							//
							if (null != fl
								&& fl.CellPresentation == CellPresentation.CardView 
								&& fl.LabelLocationResolved == LabelLocation.InCells
								)
							{
								if (weightX && !fl.HasStarFieldsX)
									weight = 1;
								else if (!weightX && !fl.HasStarFieldsY)
									weight = 1;
							}
							break;
						}
				}
			}

			return weight;
		}

		internal float GetAutoFitWeight(bool cell, bool weightX)
		{
			LayoutItemSize size = weightX ? LayoutItemSize.PreferredWidth : LayoutItemSize.PreferredHeight;

			if (!cell && !FieldLayoutItem.ShouldSynchronize(size, this))
				return 0f;

			FieldLength len = GetWidthOrHeight(weightX);

			if (!len.IsStar)
				return 0f;

			return Convert.ToSingle(len.Value);
		} 
				#endregion //GetAutoFitWeight

				#region GetConverterParameterResolved

		// SSP 3/25/10 TFS26315
		// 
		internal object GetConverterParameterResolved( DataRecord record )
		{
			object ret = this.ConverterParameter;

			if ( null == ret )
				ret = record;

			return ret;
		}

				#endregion // GetConverterParameterResolved

				// AS 8/10/09 NA 2009.2 Field Sizing
				#region GetCurrentAutoSizeOptions
		internal FieldAutoSizeOptions GetCurrentAutoSizeOptions()
		{
			FieldAutoSizeOptions options = this.AutoSizeOptionsResolved;

			if (options != FieldAutoSizeOptions.None && null != _owner && null != _explicitResizeInfo)
			{
				bool isHorz = _owner.IsHorizontal;

				// if the label/cell extents are not synchronized then strip out 
				// the appropriate bits
				if ((!isHorz && !this.SyncCellLabelWidth)
					||
					(isHorz && !this.SyncCellLabelHeight))
				{
					if (_explicitResizeInfo.GetSize(true, !isHorz).HasExplicitSize)
						options &= ~FieldAutoSizeOptions.Label;

					if (_explicitResizeInfo.GetSize(false, !isHorz).HasExplicitSize)
						options &= ~AutoSizeFieldHelper.RecordOptions;
				}
			}

			return options;
		} 
				#endregion //GetCurrentAutoSizeOptions

				// AS 6/22/09 NA 2009.2 Field Sizing
				#region GetWidthOrHeight
		internal FieldLength GetWidthOrHeight(bool width)
		{
			// return the cache unless its dirty
			if (width && null !=_cachedWidth)
				return _cachedWidth.Value;

			if (!width && null != _cachedHeight)
				return _cachedHeight.Value;

			FieldLength? len = width ? this.Width : this.Height;

			if (null == len)
			{
				DependencyProperty prop = width ? FieldSettings.WidthProperty : FieldSettings.HeightProperty;
				len = GetResolvedValue<FieldLength?>(prop, null, null);
			}

			// if none was specified then store empty so we know its been resolved
			if (len == null)
				len = FieldLength.Empty;

			if (width)
				_cachedWidth = len;
			else
				_cachedHeight = len;

			if (!len.Value.IsAnyAuto)
			{
				// if we have some calculated auto sizes and the field is no longer
				// an auto field then clear that autosize information. if we had explicit 
				// info that would have been cleared when the width/height was set.
				//
				if (_explicitResizeInfo != null)
				{
					_explicitResizeInfo.ClearAuto(true, width);
					_explicitResizeInfo.ClearAuto(false, width);
				}
			}

			return len.Value;
		} 
				#endregion //GetWidthOrHeight

				#region GetExtent

        
#region Infragistics Source Cleanup (Region)


















































































#endregion // Infragistics Source Cleanup (Region)

                #endregion //GetExtent

				#region GetCellValue

        
#region Infragistics Source Cleanup (Region)













































































































#endregion // Infragistics Source Cleanup (Region)

                #endregion //GetCellValue

                #region GetCellValuePresenter

        internal CellValuePresenter GetCellValuePresenter()
		{
			this.VerifyLayoutVersion();

			if (this._cachedCellValuePresenters != null &&
				 this._cachedCellValuePresenters.Count > 0)
				return this._cachedCellValuePresenters.Pop();

			return new CellValuePresenter();
		}

				#endregion //GetCellValuePresenter	

                // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
                #region GetFieldSettingsStyleResolved
        internal Style GetFieldSettingsStyleResolved(DependencyProperty property)
        {
            Debug.Assert(null != property);
            Style style = null;

            if (this._settings != null)
                style = this._settings.GetValue(property) as Style;

            if (null == style && this._owner != null)
            {
                if (this._owner.HasFieldSettings)
                    style = this._owner.FieldSettings.GetValue(property) as Style;

                if (null == style)
                {
                    DataPresenterBase dp = this._owner.DataPresenter;

                    if (dp != null && dp.HasFieldSettings)
                        style = dp.FieldSettings.GetValue(property) as Style;
                }
            }

            return style;
        } 
                #endregion //GetFieldSettingsStyleResolved

                // AS 10/3/08 TFS8634
                // Refactored from logic in CVP & Cell's IsEditingAllowed properties.
                //
                #region GetIsEditingAllowed
        internal bool GetIsEditingAllowed(DataRecord record)
        {
            if (record == null)
                return false;

			
#region Infragistics Source Cleanup (Region)





























































































#endregion // Infragistics Source Cleanup (Region)

			return record.GetIsEditingAllowed(this);
        } 
                #endregion //GetIsEditingAllowed

				#region GetLabelPresenter

		internal LabelPresenter GetLabelPresenter()
		{

			this.VerifyLayoutVersion();

			if (this._cachedLabelPresenters != null &&
				 this._cachedLabelPresenters.Count > 0)
				return this._cachedLabelPresenters.Pop();

			return new LabelPresenter();
		}

				#endregion //GetLabelPresenter	
    
                // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
                #region GetCPLayoutManager
        /// <summary>
        /// Returns a GridBagLayoutManager that can be used to measure a cell value presenter and label presenter within a CellPresenter.
        /// </summary>
		// JJD 08/16/10 - TFS26331 - added constrainedSize
		
        internal CPGridBagLayoutManager GetCPLayoutManager(Size constrainedSize)
        {
            // hand out the one we have if we have one. clear the reference
            // to it so we don't hand it out to multiple callers should that 
            // happen before the returned one is released
            CPGridBagLayoutManager sharedLm = this._cachedCPLayoutManager;

            // if we didn't have a cached one then create one and return it
            if (sharedLm == null)
            {
				// JJD 08/16/10 - TFS26331 - added constrainedSize
				
                sharedLm = new CPGridBagLayoutManager(this, constrainedSize);
                sharedLm.ExpandToFitHeight = true;
                sharedLm.ExpandToFitWidth = true;
            }
            else
            {
				// JJD 08/16/10 - TFS26331 - added constrainedSize
				// update the constrined size
				sharedLm.ConstrainedSize = constrainedSize;

                // if we are handing back our cached one then clear our reference
                // to it so we don't hand it back to another field should it be
                // requested while this one was being used. in that case we would
                // create another
                this._cachedCPLayoutManager = null;
            }
            return sharedLm;
        } 
                #endregion //GetCPLayoutManager

				// AS 4/8/09 NA 2009.2 ClipboardSupport
                #region GetResolvedValue
        private T GetResolvedValue<T>(DependencyProperty property, T defaultValue, T defaultResolvedValue)
        {
            Debug.Assert(null != property && property.OwnerType == typeof(FieldSettings));

            T value;

            if (null != _settings)
            {
                value = (T)_settings.GetValue(property);

                if (!object.Equals(defaultValue, value))
                    return value;
            }

			if (null != _owner)
			{
				FieldSettings settings = _owner.FieldSettingsIfAllocated;

				if (null != settings)
				{
					value = (T)settings.GetValue(property);

					if (!object.Equals(defaultValue, value))
						return value;
				}

				DataPresenterBase dp = _owner.DataPresenter;

				settings = null != dp ? dp.FieldSettingsIfAllocated : null;

				if (null != settings)
				{
					value = (T)settings.GetValue(property);

					if (!object.Equals(defaultValue, value))
						return value;
				}

			}

            return defaultResolvedValue;

        }
                #endregion //GetResolvedValue

				// AS 7/30/09 NA 2009.2 Field Sizing
				#region GetResizeSize
		/// <summary>
		/// Returns the size information from the ExplicitResizeInfo for the given type/extent.
		/// </summary>
		/// <param name="label">True to return the extent for the label; false to return the extent for the cell</param>
		/// <param name="width">True to return the width for the specified type; otherwise false to get the height.</param>
		internal FieldSize GetResizeSize(bool label, bool width)
		{
			if (_explicitResizeInfo == null)
				return FieldSize.Empty;

			return _explicitResizeInfo.GetSize(label, width);
		} 
				#endregion //GetResizeSize

                #region Initialize

        internal void Initialize(FieldLayout owner)
        {
            if (this._owner != null && this._owner != owner)
				throw new InvalidOperationException( DataPresenterBase.GetString( "LE_InvalidOperationException_9" ) );

            this._owner = owner;

            if (this._owner != null)
            {
				if (this._isPrimary)
					this._owner.PrimaryField = this;

				if (this._isScrollTip)
					this._owner.ScrollTipField = this;

                // JJD 2/4/09
                // If the field is being added after the fieldlayout has been initialized
                // then initialize the default label
                // JJD 5/20/09 - TFS17823 
                // Check if _defaultLabel is the DefaultValueMarker.Instance 
                if (this._owner.IsInitialized &&
                     (this._defaultLabel == null || this._defaultLabel == DefaultValueMarker.Instance))
                {
                    string name = this.Name;

                    if (name != null && name.Length > 0)
                        this.InitializeDefaultLabel(name);
                }

				
				
				
				
				
				
				
				
            }
        }

		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)
















#endregion // Infragistics Source Cleanup (Region)


		
		
		
		
		
#region Infragistics Source Cleanup (Region)






































































































































#endregion // Infragistics Source Cleanup (Region)


                #endregion //Initialize

                // JJD 12/22/08 - added
                #region InitializeFilterCellEditor

        internal void InitializeFilterCellEditor(ValueEditor editor)
        {
			// JJD 11/9/11 - TFS95718
			// Don't bind the editor's sty;e property. Otherwise, a null value (which is the default)
			// will prevent an implicit style from being picked up.
			// Instead call new SetFilterCellEditorStyle method which will only set the style
			// if it is not null. If it is null it will only call ClearValue(StyleProperty) if
			// the style had been previously set by us
            //editor.SetBinding(ValueEditor.StyleProperty, Utilities.CreateBindingObject("FilterCellEditorStyleResolved", BindingMode.OneWay, this));
			this.SetFilterCellEditorStyle(editor);

            switch (this.FilterOperandUITypeResolved)
            {
                case FilterOperandUIType.Combo:
                    {

                        XamComboEditor combo = editor as XamComboEditor;
                        if (combo != null)
                            combo.IsEditable = true;

                    }
                    break;

                case FilterOperandUIType.DropDownList:
                    break;

                case FilterOperandUIType.UseFieldEditor:
                     break;
                case FilterOperandUIType.Disabled:
                    editor.IsEnabled = false;
                    break;
            }
        }

                #endregion //InitializeCellEditor	
            
                // JJD 9/10/08 - added clone support for printing
                #region InitializeFrom

        internal virtual void InitializeFrom(Field source)
        {
            this.Column                     = source.Column;
            this.ColumnSpan                 = source.ColumnSpan;
            this.Converter                  = source.Converter;
            this.ConverterCulture           = source.ConverterCulture;
            this.ConverterParameter         = source.ConverterParameter;
            this.DataType                   = source.DataType;
            this.IsExpandable               = source.IsExpandable;
            this.IsPrimary                  = source.IsPrimary;
            this.IsScrollTipField           = source.IsScrollTipField;
            if (source.HasLabel)
                this.Label                  = source.Label;
            this.Name                       = source.Name;
            this.Tag                        = source.Tag;
            this.Row                        = source.Row;
            this.RowSpan                    = source.RowSpan;
            this.SummaryStringFormats       = source.SummaryStringFormats;
            this.Visibility                 = source.Visibility;
  
			// JJD 3/21/11 - TFS67571
			// Clone the width and height properties as well
			this.Height						= source.Height;
            this.Width						= source.Width;

			// JJD 12/2/11 - TFS21317
			// copy over the fals that says whther the data type was explicitly set
			this._dataTypeExplicitySet = source._dataTypeExplicitySet;

            // MBS 8/25/09 - TFS21047
            // We should ensure that we update the EditAsType property after the clone process, since 
            // it's possible that we cache the wrong value too early.
            this._cachedEditAsTypeResolved = null;
			// JJD 8/24/11 - TFS84478 - clear the underlying cached value as well
			this._cachedEditAsTypeResolvedUnderlying = null;

			// JJD 7/15/10 - TFS35815 - added
			this._cachedNonSpecificNotificationBehavior = NonSpecificNotificationBehavior.Default;

			if (source._explicitResizeInfo != null)
			{
				this._explicitResizeInfo = new FieldResizeInfo(this, source._explicitResizeInfo);
				this._hasPendingInitialAutoSize = source._hasPendingInitialAutoSize; // AS 1/17/11 TFS59925
			}
        }

                #endregion //InitializeFrom	

                #region InitializePropertyDescriptor

		// SSP 9/26/11 TFS86720
		// 
        //internal void InitializePropertyDescriptor(PropertyDescriptor propertyDescriptor)
		internal void InitializePropertyDescriptor( PropertyDescriptor propertyDescriptor, bool reinitialize )
        {
			// JM 11-25-08 TFS10863
			// SSP 9/26/11 TFS86720
			// Don't change the Visibility if we are re-initializing the field. The developer may have explicitly
			// set it to be visible even if the IsBrowsable is false.
			// 
			//if (propertyDescriptor != null && propertyDescriptor.IsBrowsable == false)
			if ( ! reinitialize && propertyDescriptor != null && propertyDescriptor.IsBrowsable == false )
				this.Visibility = Visibility.Collapsed;

			this._dataTypeExplicitySet = false;

			// JM 07-29-09 TFS 19241
			this._isPropertyDescriptorInitialized = true;
        }

                #endregion //InitializePropertyDescriptor


				#region InternalSelect







		internal void InternalSelect(bool value)
		{
			if (this._selected != value)
			{
				this._selected = value;
				this.IsSelected = value;
			}
		}

				#endregion //InternalSelect	
    
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region IsFixedLocationAllowed
        internal bool IsFixedLocationAllowed(FixedFieldLocation fixedFieldLocation)
        {
            switch (this.AllowFixingResolved)
            {
                case AllowFieldFixing.Far:
                    return fixedFieldLocation != FixedFieldLocation.FixedToNearEdge;
                case AllowFieldFixing.Near:
                    return fixedFieldLocation != FixedFieldLocation.FixedToFarEdge;
                default:
                case AllowFieldFixing.No:
                    return false;
                case AllowFieldFixing.NearOrFar:
                    return true;
            }
        }
                #endregion //IsFixedLocationAllowed

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region OnCurrentViewChanged
		// AS 10/13/09 NA 2010.1 - CardView
		// Added format settings changed parameter.
		//
		internal void OnCurrentViewChanged(bool formatSettingsChanged)
        {
            this.VerifyFixedState();

			// AS 1/22/10 Coerce FixedLocation
			this.CoerceValue(FixedLocationProperty);
		}
                #endregion //OnCurrentViewChanged

				// JM 1/14/09 NA 2009 Vol 1 - Fixed Fields
				#region OnFieldLayoutTemplatesGenerated







		internal void OnFieldLayoutTemplatesGenerated()
		{
			this.VerifyFixedState();
		}

				#endregion //OnFieldLayoutTemplatesGenerated

                // JJD 5/18/09 - added
                #region OnPropertyDescriptorChanged

        internal void OnPropertyDescriptorChanged(PropertyDescriptor pd, PropertyDescriptorProvider provider)
        {
            string label = null;

            if (this._owner != null)
            {
                
                
                
                label = this._owner.GetLabelFromPropertyDescriptor(pd, provider.Source);
            }

            this.Name = pd.Name;
            this.InitializeDefaultLabel(label);

            this.DataType = pd.PropertyType;

            // reset the flags that were set to true by setting the properties above
            this._dataTypeExplicitySet = false;

            // JJD 7/25/08 - BR35098 
            // Don't need _labelExplicitySet flag anymore since we are coercing the value.
            //this._labelExplicitySet = false;

            this._nameExplicitySet = false;

            this.Initialize();

			// SSP 9/26/11 TFS86720
			// 
            //this.InitializePropertyDescriptor(pd);
			this.InitializePropertyDescriptor( pd, true );
        }

                #endregion //OnPropertyDescriptorChanged	
    
				#region PerformLabelClickAction

		internal bool PerformLabelClickAction()
		{
			LabelClickAction clickAction = this.LabelClickActionResolved;

			switch (clickAction)
			{
				case LabelClickAction.SortByOneFieldOnly:
				case LabelClickAction.SortByMultipleFields:
                // JJD 12/03/08 
                // Added support for cycling thru ascending/descending/unsorted
                case LabelClickAction.SortByOneFieldOnlyTriState:
                case LabelClickAction.SortByMultipleFieldsTriState:
					#region Refactored for Undo/Redo
					
#region Infragistics Source Cleanup (Region)
























































































































































































































#endregion // Infragistics Source Cleanup (Region)

					#endregion //Refactored for Undo/Redo
					DataPresenterBase dp = this.DataPresenter;

					if (null == dp)
						return false;

					SortingAction action = new SortingAction(this, Keyboard.Modifiers);
					return dp.History.PerformAction(action, null);
				default:
					return false;
			}

		} 
				#endregion //PerformLabelClickAction

                // JJD 7/21/08 - BR34098 - Optimization - added
                #region PostDelayedInvalidation

        private void PostDelayedInvalidation()
        {
            // JJD 11/12/08 - TFS7858
            // Call the fieldlayout's PostDelayedInvalidation instead so we only invalidate
            // the styles if we aren't in the the middle of initializing all the fields 
            //DataPresenterBase dp = null != this.Owner ? this.Owner.DataPresenter : null;
            //if (null != dp)
            //    dp.InvalidateGeneratedStylesAsync();
            if (this._owner != null)
                this._owner.PostDelayedInvalidation();
        }

                #endregion //PostDelayedInvalidation	
    
 				#region ProcessIsExpandableChanged

		
		
		private void ProcessIsExpandableChanged( )
		{
			// SSP 8/28/09 - Enhanced grid-view - TFS21591
			// 
			DataPresenterBase dp = this.DataPresenter;
			if ( null != dp )
				dp.BumpScrollCountRecalcVersion( );

            // JJD 7/21/08 - BR34098 - Optimization
            // Invalidate the generated styles asynchronously so that if alot of
            // changes are made in a tight loop that only one invalidation will take place
            //DataPresenterBase dp = null != this.Owner ? this.Owner.DataPresenter : null;
            //if (null != dp)
            //    dp.InvalidateGeneratedStyles(true, false);
            this.PostDelayedInvalidation();

			this.RaisePropertyChangedEvent( "IsExpandableResolved" );
		}

				#endregion // ProcessIsExpandableChanged

				#region ProcessFieldSettingsPropertyChanged

		// SSP 4/23/08 - Summaries Functionality
		// Added infrastructure so field, field layout and the data presenter can each process
		// change in field settings of any of these objects.
		// 
		/// <summary>
		/// This method is called whenever a property on FieldSettings belonging to this FieldLayout, the DataPresenterBase
		/// or a Field changes. When DataPresenter's FieldSettings changes, this method is called on all FieldLayouts, otherwise
		/// its called on just the associated FieldLayout.
		/// </summary>
		/// <param name="e">Property change notification event args.</param>
		/// <param name="settings">Settings whose property changed.</param>
		/// <param name="settingsOwner">The owner of the settings object - either DataPresenterBase or FieldLayout or Field 
		/// that the settings object belongs to.</param>
		/// <param name="firstPassForPresenterFlag"></param>
		/// <param name="firstPassForFieldLayoutFlag"></param>
		/// <param name="field">Can be null. The field for which to process the change.</param>
		/// <param name="fieldLayout">Associated field layout if any.</param>
		/// <param name="presenter">Associated data presenter if any.</param>
		internal static void ProcessFieldSettingsPropertyChanged( 
			PropertyChangedEventArgs e, 
			FieldSettings settings, 
			object settingsOwner,
			bool firstPassForPresenterFlag,
			bool firstPassForFieldLayoutFlag,
			Field field, 
			FieldLayout fieldLayout, 
			DataPresenterBase presenter )
		{
			bool dpInitialized = null != presenter && presenter.IsInitialized;
			bool raiseResolved = false;

			// SSP 6/7/08 BR33120
			List<string> raisePropChangeList = new List<string>( );

			// This is to maintain what we were doing before whenever field layout's or data presenter's
			// settings changed.
			// 
			bool invalidateGeneratedStyles = settingsOwner is DataPresenterBase || settingsOwner is FieldLayout;

			string propName = e.PropertyName;
			switch ( propName )
			{
				case "AllowGroupBy":
					
					
					
                    if (null != presenter && firstPassForPresenterFlag)
                    {
                        // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                        // use the BumpGroupByAreaStyleVersion method instead of the GroupByArea property
                        //presenter.GroupByArea.StyleVersionNumber++;
                        presenter.BumpGroupByAreaStyleVersion();
                    }
					raiseResolved = true;

					// SSP 9/9/09 TFS18914
					// There's no need to invalidate the generated styles when AllowGroupBy changes.
					// 
					invalidateGeneratedStyles = false;
					break;

				// JJD 6/30/11 - TFS80466 
				// cache whether there is a selector specified at any level, Field, FieldLayout or DataPresenter
				case "CellValuePresenterStyleSelector":
					if (field != null)
					{
						field._hasCellValuePresenterStyleSelector = null != field.GetResolvedValue<StyleSelector>(FieldSettings.CellValuePresenterStyleSelectorProperty, null, null);

						// JJD 7/05/11 - TFS80466 
						// If the setting is on a specific field then raise the CellValuePresenterStyleResolved prop change event to update existing elements
						if (field == settingsOwner)
							field.RaisePropertyChangedEvent("CellValuePresenterStyleResolved");
					}
					break;

				// JJD 6/30/11 - TFS80466 
				// cache whether there is a selector specified at any level, Field, FieldLayout or DataPresenter
				case "EditorStyleSelector":
					if (field != null)
					{
						field._hasEditorStyleSelector = null != field.GetResolvedValue<StyleSelector>(FieldSettings.EditorStyleSelectorProperty, null, null);

						// JJD 7/05/11 - TFS80466 
						// If the setting is on a specific field then raise the EditorStyleResolved prop change event to update existing elements
						if (field == settingsOwner)
							field.RaisePropertyChangedEvent("EditorStyleResolved");
					}
					break;
				
				// JJD 7/05/11 - TFS80466 
				case "LabelPresenterStyleSelector":
					// JJD 7/05/11 - TFS80466 
					// If the setting is on a specific field then raise the LabelPresenterStyleResolved prop change event to update existing elements
					if (field != null && field == settingsOwner)
						field.RaisePropertyChangedEvent("LabelPresenterStyleResolved");
					break;

				// JJD 4/29/11 - TFS74075
				// Raise 'Resolved' prop change notifications for these style properties
				case "CellValuePresenterStyle":
				case "ExpandedCellStyle":
				case "GroupByRecordPresenterStyle":
				case "LabelPresenterStyle":
					raiseResolved = true;
					break;

				case "LayoutDisplayMode":
				case "IsExpandable":
				case "CellContentAlignment":
					// JJD 2/26/07 
					// Call the invalidate of the dp so the panels get refreshed
					
					
                    if (null != presenter && firstPassForPresenterFlag)
                    {
                        // SSP 7/17/07 BR22919
                        // Don't clear the group-by fields.
                        // 
                        //this._owner.DataPresenter.InvalidateGeneratedStyles(true, this.IsGroupBy);
                        
                        

                        // JJD 7/21/08 - BR34098 - Optimization
                        // Invalidate the generated styles asynchronously so that if alot of
                        // changes are made in a tight loop that only one invalidation will take place
                        //presenter.InvalidateGeneratedStyles(true, false);

                        // JJD 11/12/08 - TFS7858
                        // Set the invalidateGeneratedStyles flag instead so we trigger the invalidation below
                        //presenter.InvalidateGeneratedStylesAsync();
                        invalidateGeneratedStyles = true;				
                    }

                    // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
					if (null != field)
					{
						// AS 8/25/11 TFS84612
						if (propName == "CellContentAlignment")
							field._cachedCellContentAlignmentResolved = null;

						field.BumpLayoutItemVersion();
					}

					raiseResolved = true;
					break;

				
#region Infragistics Source Cleanup (Region)
















#endregion // Infragistics Source Cleanup (Region)

				#region Cell Width

				case "CellMaxWidth":
					if ( null != field )
					{
						double cellMaxWidthResolved = field.CellMaxWidthResolved;
						field.ProcessSizeChange( true, true, SizeChangeType.Max, cellMaxWidthResolved );

						// SSP 8/29/08 BR35923
						// 
						// --------------------------------------------------------------------
						
#region Infragistics Source Cleanup (Region)





#endregion // Infragistics Source Cleanup (Region)

						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.CellWidth = FieldResizeInfo.RestrictHelper( 
							//	field._explicitResizeInfo.CellWidth, double.NaN, cellMaxWidthResolved );
							field._explicitResizeInfo.Restrict(false, true, double.NaN, cellMaxWidthResolved);
						// --------------------------------------------------------------------
					}

					raiseResolved = true;
					break;
				case "CellMinWidth":
					if ( null != field )
					{
						double cellMinWidthResolved = field.CellMinWidthResolved;
						field.ProcessSizeChange( true, true, SizeChangeType.Min, cellMinWidthResolved );

						// SSP 8/29/08 BR35923
						// 
						// --------------------------------------------------------------------
						
#region Infragistics Source Cleanup (Region)





#endregion // Infragistics Source Cleanup (Region)

						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.CellWidth = FieldResizeInfo.RestrictHelper( 
							//	field._explicitResizeInfo.CellWidth, cellMinWidthResolved, double.NaN );
							field._explicitResizeInfo.Restrict(false, true, cellMinWidthResolved, double.NaN);
						// --------------------------------------------------------------------
					}

					raiseResolved = true;
					break;
				case "CellWidth":
					if ( null != field )
					{
                        // JJD 2/5/09 - TFS10946
                        // When the CellWidth is set reset any explicit resize value for CellWidth
                        // so the new setting can take effect
						if (field._explicitResizeInfo != null)
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.CellWidth = double.NaN;
							field._explicitResizeInfo.ClearExplicit(false, true);

						field.ProcessSizeChange( true, true, SizeChangeType.Size, field.CellWidthResolvedInternal );

						// SSP 8/29/08 BR35923
						// Decided to not synchronize if CellWidth is set after user resizes the field.
						// That is if the user resizes a field and then the CellWidth is set, the CellWidth
						// will not have any effect. Instead you need to user ClearUserResize method to
						// clear the user resize information so the CellWidth setting takes effect. This
						// was done so that if CellWidth were to be set to the same value as it currently
						// contains, it would result in a NOOP because there would be no notifications
						// raised by the dependency property.
						// 
						// --------------------------------------------------------------------------------
						
#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)

						// --------------------------------------------------------------------------------
					}
					raiseResolved = true;
					break;

				#endregion //Cell Width

				#region Label Width
				case "LabelMaxWidth":
					if ( null != field )
					{
						double labelMaxWidthResolved = field.LabelMaxWidthResolved;
						field.ProcessSizeChange( false, true, SizeChangeType.Max, labelMaxWidthResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.LabelWidth = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.LabelWidth, double.NaN, labelMaxWidthResolved );
							field._explicitResizeInfo.Restrict(true, true, double.NaN, labelMaxWidthResolved);
					}
					raiseResolved = true;
					break;
				case "LabelMinWidth":
					if ( null != field )
					{
						double labelMinWidthResolved = field.LabelMinWidthResolved;
						field.ProcessSizeChange( false, true, SizeChangeType.Min, labelMinWidthResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.LabelWidth = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.LabelWidth, labelMinWidthResolved, double.NaN );
							field._explicitResizeInfo.Restrict(true, true, labelMinWidthResolved, double.NaN);
					}
					raiseResolved = true;
					break;
				case "LabelWidth":
                    if (null != field)
                    {
                        // JJD 2/5/09 - TFS10946
                        // When the LabelWidth is set reset any explicit resize value for LabelWidth
                        // so the new setting can take effect
                        if (field._explicitResizeInfo != null)
							// AS 7/30/09 NA 2009.2 Field Sizing
                            //field._explicitResizeInfo.LabelWidth = double.NaN;
							field._explicitResizeInfo.ClearExplicit(true, true);

                        field.ProcessSizeChange(false, true, SizeChangeType.Size, field.LabelWidthResolvedInternal);
                    }
					raiseResolved = true;
					break;

				#endregion //Label Width

				#region CellHeight

				case "CellHeight":
                    if (null != field)
                    {
                        // JJD 2/5/09 - TFS10946
                        // When the CellHeight set reset any explicit resize value for CellHeight
                        // so the new setting can take effect
                        if (field._explicitResizeInfo != null)
							// AS 7/30/09 NA 2009.2 Field Sizing
                            //field._explicitResizeInfo.CellHeight = double.NaN;
							field._explicitResizeInfo.ClearExplicit(false, false);

                        field.ProcessSizeChange(true, false, SizeChangeType.Size, field.CellHeightResolvedInternal);
                    }
					raiseResolved = true;
					break;
				case "CellMaxHeight":
					if ( null != field )
					{
						double cellMaxHeightResolved = field.CellMaxHeightResolved;
						field.ProcessSizeChange( true, false, SizeChangeType.Max, field.CellMaxHeightResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.CellHeight = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.CellHeight, double.NaN, cellMaxHeightResolved );
							field._explicitResizeInfo.Restrict(false, false, double.NaN, cellMaxHeightResolved);
					}
					raiseResolved = true;
					break;
				case "CellMinHeight":
					if ( null != field )
					{
						double cellMinHeightResolved = field.CellMinHeightResolved;
						field.ProcessSizeChange( true, false, SizeChangeType.Min, cellMinHeightResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.CellHeight = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.CellHeight, cellMinHeightResolved, double.NaN );
							field._explicitResizeInfo.Restrict(false, false, cellMinHeightResolved, double.NaN);
					}
					raiseResolved = true;
					break;

				#endregion //CellHeight

				#region LabelHeight

				case "LabelHeight":
                    if (null != field)
                    {
                        // JJD 2/5/09 - TFS10946
                        // When the LabelHeight set reset any explicit resize value for LabelHeight
                        // so the new setting can take effect
                        if (field._explicitResizeInfo != null)
							// AS 7/30/09 NA 2009.2 Field Sizing
                            //field._explicitResizeInfo.LabelHeight = double.NaN;
							field._explicitResizeInfo.ClearExplicit(true, false);

                        field.ProcessSizeChange(false, false, SizeChangeType.Size, field.LabelHeightResolvedInternal);
                    }
					raiseResolved = true;
					break;
				case "LabelMaxHeight":
					if ( null != field )
					{
						double labelMaxHeightResolved = field.LabelMaxHeightResolved;
						field.ProcessSizeChange( false, false, SizeChangeType.Max, labelMaxHeightResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.LabelHeight = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.LabelHeight, double.NaN, labelMaxHeightResolved );
							field._explicitResizeInfo.Restrict(true, false, double.NaN, labelMaxHeightResolved);
					}
					raiseResolved = true;
					break;
				case "LabelMinHeight":
					if ( null != field )
					{
						double labelMinHeightResolved = field.LabelMinHeightResolved;
						field.ProcessSizeChange( false, false, SizeChangeType.Min, labelMinHeightResolved );

						// SSP 8/29/08 BR35923
						// 
						if ( null != field._explicitResizeInfo )
							// AS 7/30/09 NA 2009.2 Field Sizing
							//field._explicitResizeInfo.LabelHeight = FieldResizeInfo.RestrictHelper(
							//	field._explicitResizeInfo.LabelHeight, labelMinHeightResolved, double.NaN );
							field._explicitResizeInfo.Restrict(true, false, labelMinHeightResolved, double.NaN);
					}
					raiseResolved = true;
					break;

				#endregion //LabelHeight

				case "InvalidValueBehavior":
				case "LabelClickAction":
					raiseResolved = true;
					break;

				
				
				case "AllowSummaries":
				
				
				
				case "AllowHiding":
					raiseResolved = true;
					invalidateGeneratedStyles = false;

					// SSP 8/31/09 TFS21539
					// 
					if ( firstPassForPresenterFlag && null != presenter )
						presenter.DirtyFieldChooserFields( );

					break;
				case "SummaryUIType":
					raiseResolved = true;
					invalidateGeneratedStyles = false;
					// SSP 6/7/08 BR33120
					raisePropChangeList.Add( "AllowSummariesResolved" );
					break;
				case "SummaryDisplayArea":
					if ( null != fieldLayout && firstPassForFieldLayoutFlag && null != fieldLayout.SummaryDefinitionsIfAllocated )
						fieldLayout.SummaryDefinitionsIfAllocated.BumpSummariesVersion( );
					invalidateGeneratedStyles = false;
					break;
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                case "AllowFixing":
                    invalidateGeneratedStyles = false;

                    // make sure the fixed state is cleared before any fields are processed in 
                    // case someone checks the FixedFieldUIType from one of the resulting change
                    // notifications or if the property is changed on the field layout itself
                    if (null != fieldLayout && (null != field || firstPassForFieldLayoutFlag))
                    {
                        fieldLayout.DirtyFixedState();

						// AS 9/4/09 TFS19589
						// We don't want to bump this for every field unless this is being 
						// set on a single field's fieldsettings. Otherwise the recordpresenters 
						// will get the internalversion change multiple times which will cause the 
						// templaterecordcache to be rebuilt for each field.
						//
						if (firstPassForFieldLayoutFlag || settingsOwner is Field)
						{
							// AS 1/15/09
							// Since there is information (e.g. the fixed field info transforms)
							// that changes when we go from fixing to non-fixing and vice
							// versa, we need to bump the version so the rp knows to get the 
							// new info.
							//
							fieldLayout.InternalVersion++;
						}
                    }

                    if (null != field)
                    {
                        field.VerifyFixedState();
                        raiseResolved = true;
                    }
                    break;
				// AS 6/9/09 NA 2009.2 Field Sizing
				case "AutoSizeOptions":
				case "AutoSizeScope":
					invalidateGeneratedStyles = false;

					if (firstPassForFieldLayoutFlag)
					{
						fieldLayout.AutoSizeInfo.OnAutoSizeSettingsChanged();
					}

					break;
				// AS 6/9/09 NA 2009.2 Field Sizing
				case "Width":
				case "Height":
					invalidateGeneratedStyles = false;

					if (null != field)
					{
						bool isWidth = propName == "Width";

						if (isWidth)
							field._cachedWidth = null;
						else
							field._cachedHeight = null;

						// follow the behavior of the (Cell|Label)(Width|Height) and clear the 
						// customization when set
						if (field._explicitResizeInfo != null)
						{
							field._explicitResizeInfo.ClearExplicit(true, isWidth);
							field._explicitResizeInfo.ClearExplicit(false, isWidth);
						}
					}

					if (firstPassForFieldLayoutFlag)
						fieldLayout.OnFieldWidthHeightChanged();
					break;

				case "EditAsType":
				case "FilterOperatorDefaultValue":
				case "FilterOperatorDropDownItems":
                    invalidateGeneratedStyles = propName == "EditAsType";
					raiseResolved = true;

					// SSP 12/11/08 - NAS9.1 Record Filtering
					// EditAsTypeResolved is used to resolve some of the filter record related properties. We 
					// need verify cached values and raise appropriate property change notifications for the 
					// affected properties.
					// 
                    if (null != field)
                    {
                        field._cachedEditAsTypeResolved = null;
                        field._cachedEditAsTypeResolvedUnderlying = null;
                        field.DirtyRecordFilterRelatedCache(true);
                    }

                    // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                    // The filtercell caches are based on the filter properties so we need
                    // to release the cache.
                    //
					if (null != fieldLayout && firstPassForFieldLayoutFlag)
						fieldLayout.InternalVersion++;

					break;
				// SSP 12/15/08 - NAS9.1 Record Filtering
				// 
				case "AllowRecordFiltering":
				case "FilterClearButtonVisibility":
				case "FilterEvaluationTrigger":
				case "FilterOperandUIType":
				case "FilterStringComparisonType":
					invalidateGeneratedStyles = false;
					raiseResolved = true;

					// Bump the special records version because the filter record's visibility can potentially
					// change as a result of change in AllowRecordFiltering and FilterOperandUIType property 
					// settings.
					// 
					if ( null != fieldLayout && firstPassForFieldLayoutFlag )
                    {
						fieldLayout.BumpSpecialRecordsVersion( );

                        // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                        // The filtercell caches are based on the filter properties so we need
                        // to release the cache.
                        //
						fieldLayout.InternalVersion++;
                    }

                    // JJD 2/10/09 - NA 2009 vol 1 - Record filtering
                    // Since the AllowRecordFiltering setting can effect the FilterOperandUITypeResolved
                    // we need to raise it's prop change as well
                    if (propName == "AllowRecordFiltering")
                    {
                        raisePropChangeList.Add("FilterOperandUITypeResolved");
                    }
                    // JJD 2/18/09 - TFS14057 
                    // If the string comparison type changed then bump the filter version
                    // so any existing filters will get re-applied
                    else if (fieldLayout != null && propName == "FilterStringComparisonType")
                    {
                        fieldLayout.BumpRecordFilterVersion();
                    }

					break;

                // SSP 5/3/10 TFS25788
				// Added FilterComparer property.
				// 
				case "FilterComparer":
				// SSP 2/29/12 TFS89053
				// Added FilterEvaluator property.
				// 
				case "FilterEvaluator":
					raiseResolved = true;
					invalidateGeneratedStyles = false;

					if ( null != fieldLayout && firstPassForFieldLayoutFlag )
						fieldLayout.BumpRecordFilterVersion( );

					break;

                // JJD 1/7/09 - NA 2009 vol 1 - record filtering
				case "FilterCellValuePresenterStyle":
				case "FilterCellEditorStyle":
					raiseResolved = true;
                    break;
				// SSP 4/1/09 Cell Text
				// When a field's EditorType and EditorStyle changes, we need to re-create the
				// template cache with potentially new editors.
				// 
				case "EditorType":
				case "EditorStyle":
					if (firstPassForFieldLayoutFlag && null != fieldLayout)
						invalidateGeneratedStyles = true;
					else
					{
						// JJD 7/05/11 - TFS80466 
						// raise resolved if the setting change was on a specific field
						if (field != null && field == settingsOwner)
							raiseResolved = true;
					}
					break;
				// SSP 5/3/09 NAS9.2 IDataErrorInfo Support
				// 
				case "SupportDataErrorInfo":
					raiseResolved = true;

					if ( firstPassForPresenterFlag && null != presenter )
						invalidateGeneratedStyles = true;

                    // SSP 6/7/10 - Optimizations - TFS34031
                    // Cache resolved property value.
                    // 
                    if ( null != field )
                        field._cachedSupportDataErrorInfoResolved = -1;

					break;
				// SSP 5/29/09 - TFS17233 - Optimization
				// Added caching for GroupByEvaluatorResolved.
				// 
				case "GroupByEvaluator":
				case "SortComparisonType":
				case "GroupByMode":
					if ( null != field )
						field._cachedGroupByEvaluator = null;

					raiseResolved = true;
					if ( "GroupByEvaluator" != propName )
						raisePropChangeList.Add( "GroupByEvaluatorResolved" );

					break;
				// JM 6/12/09 NA 2009.2 DataValueChangedEvent
				case "DataValueChangedScope":
				case "DataValueChangedNotificationsActive":
				case "DataValueChangedHistoryLimit":	// JM 08-25-09 TFS20914 
					// JM 08-17-09  TFS20914 - Don't invalidate the generated styles
					invalidateGeneratedStyles = false;
					
					if (fieldLayout != null)
						fieldLayout.Fields.RefreshDataValueChangedCounts();

                    // SSP 6/7/10 - Optimizations - TFS34031
                    // Cache resolved property value.
                    // 
                    if ( null != field )
                    {
                        field._cachedDataValueChangedHistoryLimitResolved = null;
                        field._cachedDataValueChangedNotificationsActiveResolved = null;
 						// JJD 3/13/11 - TFS67970 - Optimization
						// Cache the resolved changed scope value
						field._cachedDataValueChangedScopeResolved = null;
                   }

					break;

                // JJD 9/18/09 - TFS20567
                case "ExpandableFieldRecordExpansionMode":
                case "ExpandableFieldRecordHeaderDisplayMode":

                    if (presenter != null)
                    {
                        presenter.BumpScrollCountRecalcVersion();
                        raiseResolved = true;
                    }
                    break;

				// AS 10/27/09 NA 2010.1 - CardView
				case "AllowCollapseEmptyCells":
					invalidateGeneratedStyles = false;
					raiseResolved = true;

					if (firstPassForFieldLayoutFlag)
					{
						fieldLayout.BumpLayoutManagerVersion();
					}
					break;

				// JJD 7/15/10 - TFS35815 - added
				case "NonSpecificNotificationBehavior":
					invalidateGeneratedStyles = false;
					raiseResolved = true;
                    if (null != field)
                        field._cachedNonSpecificNotificationBehavior = NonSpecificNotificationBehavior.Default;
					break;

				// AS - NA 11.2 Excel Style Filtering
				case "FilterLabelIconDropDownType":
					raiseResolved = true;
					invalidateGeneratedStyles = false;
					break;
			}

			// This is to maintain what we were doing before whenever field layout's or data presenter's
			// settings changed.
			// 
			if ( invalidateGeneratedStyles )
			{
				if ( null != presenter && firstPassForPresenterFlag )
				{
					// JJD 7/19/07 - BR21417
					// Bump the .GroupByArea.StyleVersionNumber to refresh the group by area
                    // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                    // use the BumpGroupByAreaStyleVersion method instead of the GroupByArea property
                    //if (presenter.GroupByAreaLocation != GroupByAreaLocation.None)
                    //  presenter.GroupByArea.StyleVersionNumber++;
                    presenter.BumpGroupByAreaStyleVersion();
 
					// SSP 7/17/07 BR22919
					// Don't clear the group-by fields.
					// 
					//this.InvalidateGeneratedStyles(true, true);
                    // JJD 7/21/08 - BR34098 - Optimization
                    // Invalidate the generated styles asynchronously so that if alot of
                    // changes are made in a tight loop that only one invalidation will take place
                    //presenter.InvalidateGeneratedStyles(true, false);

                    // JJD 11/12/08 - TFS7858
                    // Call the fieldlayout's PostDelayedInvalidation instead so we only invalidate
                    // the styles if we aren't in the the middle of initializing all the fields 
                    //presenter.InvalidateGeneratedStylesAsync();
                    if (fieldLayout == null)
                        presenter.InvalidateGeneratedStylesAsync();
                    else
                        fieldLayout.PostDelayedInvalidation();
				}
			}

			if ( raiseResolved && null != field )
				field.RaisePropertyChangedEvent( propName + "Resolved" );

			// SSP 6/7/08 BR33120
			// 
			if ( null != field )
			{
				for ( int i = 0, count = raisePropChangeList.Count; i < count; i++ )
					field.RaisePropertyChangedEvent( raisePropChangeList[i] );
			}
				
		}

				#endregion // ProcessFieldSettingsPropertyChanged

				#region RaisePropertyChangedEventHelper

		// SSP 1/12/10 TFS25122
		// Raise ActualPosition property change notifications.
		// 
		internal static void RaisePropertyChangedEventHelper( IEnumerable<Field> fields, string propertyName )
		{
			if ( null != fields )
			{
				foreach ( Field ii in fields )
				{
					ii.RaisePropertyChangedEvent( propertyName );
				}
			}
		}

				#endregion // RaisePropertyChangedEventHelper

                // AS 12/19/08 NA 2009 Vol 1 - Fixed Fields
                #region ReleaseCPLayoutManager
        internal void ReleaseCPLayoutManager(CPGridBagLayoutManager lm)
        {
            Debug.Assert(null != lm);

            lm.Initialize(null, Rect.Empty, Rect.Empty, Rect.Empty);

            if (this._cachedCPLayoutManager == null)
                this._cachedCPLayoutManager = lm;
        } 
                #endregion //ReleaseCPLayoutManager

		        #region ReleaseCellValuePresenter

		internal void ReleaseCellValuePresenter( CellValuePresenter presenter )
		{
			if (this._cachedCellValuePresenters == null)
				this._cachedCellValuePresenters = new Stack<CellValuePresenter>();

			if (presenter != null)
				this._cachedCellValuePresenters.Push(presenter);
		}

				#endregion //ReleaseCellValuePresenter	

				#region ReleaseLabelPresenter

		internal void ReleaseLabelPresenter(LabelPresenter presenter)
		{
			if (this._cachedLabelPresenters == null)
				this._cachedLabelPresenters = new Stack<LabelPresenter>();

			if (presenter != null)
				this._cachedLabelPresenters.Push(presenter);
		}

				#endregion //ReleaseLabelPresenter	

				#region SetActualPosition

		// SSP 9/2/09 TFS17893
		// Added a way to be able to change the position of the field after a field has been moved.
		// 
		/// <summary>
		/// Sets the position of the field in the record cell area.
		/// </summary>
		/// <param name="position">New position</param>
		/// <param name="ensureItemDoesntOverlap">If true then makes sure this field doesn't
		/// overlap any other field by moving other fields' positions as necessary.</param>
		internal void SetActualPosition( FieldPosition position, bool ensureItemDoesntOverlap )
		{
			FieldLayout fl = this.Owner;
			if ( null != fl )
			{
				// Get the layout info from the field layout.
				// 
				LayoutInfo layoutInfo = fl.GetFieldLayoutInfo( true, false );
				if ( null == layoutInfo )
					layoutInfo = new LayoutInfo( fl );

				// Get the existing ItemLayoutInfo for the field if it exists. Otherwise create
				// a new one.
				// 
				ItemLayoutInfo itemInfo;
				if ( layoutInfo.TryGetValue( this, out itemInfo ) )
					itemInfo.SetPosition( position );
				else
					layoutInfo.Add( this, itemInfo = ItemLayoutInfo.Create( this, position ) );

				// LayoutInfo's EnsureItemsDontOverlap method will give higher priority to items
				// that were modified the last. This time stamp is used for that.
				// 
				itemInfo.UpdateExplicitSetPositionTimeStamp( );

				if ( ensureItemDoesntOverlap )
					layoutInfo.EnsureItemDoesntOverlap( this );

				// Set the layout info on the field layout and invalidate generated styles
				// to have the changes actually take effect.
				// 
				fl.SetFieldLayoutInfo( layoutInfo, true, false );
				fl.InvalidateGeneratedStylesAsnyc( false, false );
			}
			else
			{
				// If there's no field layout then simply set the row/col/span properties.

				this.Row = position.Row;
				this.Column = position.Column;
				this.RowSpan = position.RowSpan;
				this.ColumnSpan = position.ColumnSpan;
			}
		}

				#endregion // SetActualPosition

				// JJD 11/9/11 - TFS95718 - added
				#region SetFilterCellEditorStyle

		internal void SetFilterCellEditorStyle(ValueEditor editor)
		{
			if (editor == null)
				return;

			Style editorStyle = this.FilterCellEditorStyleResolved;

			if (editorStyle != null)
				editor.SetValue(FrameworkElement.StyleProperty, editorStyle);
			else
			{
				// Only clear the value if it was previously set
				object localStyle = editor.ReadLocalValue(Control.StyleProperty);

				if (localStyle != DependencyProperty.UnsetValue)
					editor.ClearValue(FrameworkElement.StyleProperty);
			}
		}

				#endregion //SetFilterCellEditorStyle	
    
				#region SetGridPositions

		internal void SetGridPositions(ref FieldLayoutTemplateGenerator.RowColInfo rcInfo, ref FieldLayoutTemplateGenerator.SpanInfo spanInfo)
        {
			Debug.Assert(spanInfo.ColumnSpan > 0 && spanInfo.RowSpan > 0);

			this._cellPosition.Column = rcInfo.Column;
            this._cellPosition.ColumnSpan = spanInfo.ColumnSpan;
            this._cellPosition.Row = rcInfo.Row;
            this._cellPosition.RowSpan = spanInfo.RowSpan;

            // AS 12/9/08 NA 2009 Vol 1 - Fixed Fields
            GridBagConstraint constraint = this.LayoutConstraint;
            constraint.Column = rcInfo.Column;
            constraint.ColumnSpan = spanInfo.ColumnSpan;
            constraint.Row = rcInfo.Row;
            constraint.RowSpan = spanInfo.RowSpan;
        }

				#endregion //SetGridPositions

				#region SetCellValue

        
#region Infragistics Source Cleanup (Region)



































































































































































































































































































#endregion // Infragistics Source Cleanup (Region)


                #endregion //SetCellValue

                // AS 3/3/09 Optimization
                #region SetFixedLocation






        internal void SetFixedLocation(FixedFieldLocation fixedLocation)
        {
            bool wasSuppressed = this.GetFlag(FieldFlags.SuppressFixedLocationInvalidate);
            this.SetFlag(FieldFlags.SuppressFixedLocationInvalidate, true);

            try
            {
                this.FixedLocation = fixedLocation;
            }
            finally
            {
                this.SetFlag(FieldFlags.SuppressFixedLocationInvalidate, wasSuppressed);
            }
        } 
                #endregion //SetFixedLocation

                #region SetIsGroupBy

        internal void SetSortingStatus(SortStatus sortStatus, bool isGroupBy)
        {
            if (this._sortStatus != sortStatus)
            {
                this._sortStatus = sortStatus;
                this.SetValue(Field.SortStatusPropertyKey, this._sortStatus);
            }
            if (this._isGroupBy != isGroupBy)
            {
                this._isGroupBy = isGroupBy;

                // SSP 6/14/10 TFS32985
                // The name of the property is IsGroupBy and not the IsGroupByProperty.
                // 
                //this.RaisePropertyChangedEvent("IsGroupByProperty");
                this.RaisePropertyChangedEvent( "IsGroupBy" );
            }
        }

                #endregion //SetIsGroupBy	

				// JM 04-20-11 TFS70852 Added.
				#region SetIsPrimaryInternal
		internal void SetIsPrimaryInternal(bool isPrimary)
		{
			this._isPrimary = isPrimary;
		}

				#endregion //SetIsPrimaryInternal

                #region ShouldSerialize

		/// <summary>
		/// Determines if any property value is set to a non-default value.
		/// </summary>
		/// <returns>Returns true if any property value is set to a non-default value.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerialize()
        {
            // always serialized fields that weren't auto-generated
            if (this._autoGenerated == false)
                return true;

			
#region Infragistics Source Cleanup (Region)









#endregion // Infragistics Source Cleanup (Region)

			if (this.ShouldSerializeSettings() ||
				this.ShouldSerializeColumnSpan() ||
				this.ShouldSerializeColumn() ||
				this.ShouldSerializeDataType() ||
				this.ShouldSerializeIsExpandable() ||
				this.ShouldSerializeIsPrimary() ||
				this.ShouldSerializeLabel() ||
				this.ShouldSerializeName() ||
				this.ShouldSerializeRow() ||
				this.ShouldSerializeRowSpan() ||
				this.ShouldSerializeVisibility())
				return true;

			return GridUtilities.ShouldSerialize(this);
		}

                #endregion //ShouldSerialize	

                #region IsFilterCellEntryValid

        internal bool IsFilterCellEntryValid(object value, ComparisonOperator currentOperator, out Exception error)
        {
            error = null;

            if (GridUtilities.IsNullOrEmpty(value))
                return true;

            if (value is ICondition ||
                 value is SpecialFilterOperandBase ||
                 value is ICommand)
                return true;

            string eMsg = null;
            ValueConstraint constraint;

            CultureInfo culture = FilterConditionEvaluationContext.FilterValueEntry.GetCulture(this);
			string format = FilterConditionEvaluationContext.FilterValueEntry.GetFormat(this);

			// SSP 1/29/09
			// Moved the logic to verify operand for Top/Bottom operands into ComparisonCondition itself.
			// 
			if ( ! ComparisonCondition.IsCompareValueValid( currentOperator, value, culture, format, out error ) )
				return false;
			
#region Infragistics Source Cleanup (Region)






















#endregion // Infragistics Source Cleanup (Region)


			// SSP 1/29/09
			// Enclosed the existing code into the if block. Only check for type of the
			// operator is a quantitative comparison operator, like >, < etc...
			// 
			if ( ComparisonCondition.IsQuantitativeComparison( currentOperator )
				// SSP 3/2/12 TFS100185
				// If a filter evaluator is specified, consider any value valid.
				// 
				&& null == this.FilterEvaluatorResolved )
			{
				// SSP 10/23/09 TFS23134
				// If a XamComboEditor is being used to map values to display texts then we should
				// use string for filter value comparisons.
				// 
				//Type editAsType = this.EditAsTypeResolved;
				Type operandValueType = FilterConditionEvaluationContext.GetValueTypeForQuantitativeFilterComparison( this );

				constraint = new ValueConstraint( );

				if ( !constraint.Validate( value, operandValueType, ValueConstraintFlags.All, culture, format, ref eMsg ) )
				{
					error = new ArgumentException( eMsg );
					return false;
				}
			}

            return true;
        }

                #endregion //IsFilterCellEntryValid	
    
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                #region VerifyFixedState
        internal void VerifyFixedState()
        {
            bool isFixed = false;
            bool fixedButtonVis = false;
            FieldLayout fl = this.Owner;

            if (null != fl)
            {
                isFixed = this.FixedLocation != FixedFieldLocation.Scrollable;
                DataPresenterBase dp = fl.DataPresenter;

                if (null == dp || false == dp.IsFixedFieldsSupportedResolved)
                {
                    isFixed = false;
                }
                else if (this.AllowFixingResolved != AllowFieldFixing.No &&
                    GridUtilities.IncludesFixedButton(fl.GetFixedFieldUITypeResolved(isFixed, true)))
                {
                    fixedButtonVis = true;
                }
            }

            this.SetValue(IsFixedPropertyKey, isFixed ? KnownBoxes.TrueBox : DependencyProperty.UnsetValue);
            this.SetValue(FixedButtonVisibilityPropertyKey, fixedButtonVis ? KnownBoxes.VisibilityVisibleBox : DependencyProperty.UnsetValue);
        }
                #endregion //VerifyFixedState 

				#region VerifyLayoutVersion

		private void VerifyLayoutVersion()
		{
			// AS 7/7/09 TFS19145
			// Since we will not always bump the internal version number we need to 
			// consider the template version as well.
			//
			//int layoutVersion = this.Owner.InternalVersion;
			FieldLayout owner = _owner;
			int layoutVersion = owner != null ? owner.InternalVersion + owner.TemplateVersion : -1;

			if (this._layoutVersion != layoutVersion)
			{
				this._layoutVersion = layoutVersion;

				// JJD 5/3/07 - Optimization
				// Cache a key so that multiple field's can share a cell elment in the template record
				// Clear the cached key so a new one will be created with the new cached values
				this._cellElementKey = null;

                // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
                this._labelElementKey = null;
                this._filterCellElementKey = null;

				// clear the cellvalue and label presenter caches
				if (this._cachedCellValuePresenters != null)
					this._cachedCellValuePresenters.Clear();

				if (this._cachedLabelPresenters != null)
					this._cachedLabelPresenters.Clear();
			}
		}

				#endregion //VerifyLayoutVersion	
            
            #endregion //Internal Methods

            #region Private Methods

                #region CacheDataType

        // JJD 4/17/08 - optimization
        // cache the type and the underlying data type as well
        private void CacheDataType(Type dataType)
        {
            this._cachedDataType = dataType;

            Debug.Assert(dataType != null);

            // JJD 4/17/08 - optimization
            // cache the underlying data type as well
            this._cachedDataTypeUnderlying = Utilities.GetUnderlyingType(this._cachedDataType);
            
            // JJD 5/29/09 - TFS18063 
            // Clear the cached editAsTypeResolved values 
            this._cachedEditAsTypeResolved = null;
            this._cachedEditAsTypeResolvedUnderlying = null;
        }

                #endregion //CacheDataType	
    
				#region CreateDefaultDataTable
		private static Hashtable CreateDefaultDataTable()
		{
			Hashtable table = new Hashtable(20);

			Random random = new Random();
			table[typeof(DateTime)] = DateTime.MaxValue;
			table[typeof(System.DayOfWeek)] = DayOfWeek.Wednesday;

			// SSP 2/4/10 TFS26903
			// Use positive values for the default values in case a masked editor's mask
			// is set to not support negative values. Having the values be negative in that
			// case doesn't really cause any issues except a handled exception, we want to
			// avoid it.
			// 
			// ------------------------------------------------------------------------------
			
#region Infragistics Source Cleanup (Region)
















#endregion // Infragistics Source Cleanup (Region)


			table[typeof( int )] = int.MaxValue;
			table[typeof( uint )] = uint.MaxValue;
			table[typeof( short )] = short.MaxValue;
			table[typeof( ushort )] = ushort.MaxValue;
			table[typeof( long )] = long.MaxValue;
			table[typeof( ulong )] = ulong.MaxValue;
			// AS 4/26/07 Performance
			// When a masked editor is used, the float/double values result
			// in an exponential when converted to a string which causes
			// a mask character exception so we'll use large values that do
			// not result in an exponential. For the decimal, I think we want
			// a larger value than -1; I think I meant to use MinValue.
			//
			table[typeof( float )] = 9999.8888f; //float.MinValue;
			table[typeof( double )] = 999999.8999999999d; //double.MinValue;
			table[typeof( decimal )] = 9999999.8999999999m; //decimal.MinusOne;
			table[typeof( byte )] = byte.MaxValue;
			table[typeof( sbyte )] = sbyte.MaxValue;
			// ------------------------------------------------------------------------------

			table[typeof( string )] = "Text";
			table[typeof( Color )] = Colors.White;
			table[typeof( bool )] = false;

			return table;
		} 
				#endregion //CreateDefaultDataTable

				#region GetAllowCellVirtualizationResolved
		private bool GetAllowCellVirtualizationResolved(Orientation? orientation)
		{
			DataPresenterBase layoutOwner = null;
            if (this._owner != null )
                layoutOwner = this._owner.DataPresenter;

            // JJD 10/02/08
            // In reports we don't need to virtualize cells
            if (layoutOwner != null && layoutOwner.IsReportControl)
                 return false;

			bool? allowCellVirtualization = null;

			if (this._settings != null)
				allowCellVirtualization = this._settings.AllowCellVirtualization;

			if (allowCellVirtualization == null && this._owner != null)
			{

				if (this._owner.HasFieldSettings)
				{
					// get the Field layout settings
					allowCellVirtualization = this._owner.FieldSettings.AllowCellVirtualization;
				}

				if (allowCellVirtualization == null && layoutOwner != null && layoutOwner.HasFieldSettings)
				{
					// get the DataPresenterBase setting
					allowCellVirtualization = layoutOwner.FieldSettings.AllowCellVirtualization;
				}
			}

			if (allowCellVirtualization.HasValue && allowCellVirtualization.Value == false)
				return false;

			if (null != this._owner &&
				this._owner.TemplateDataRecordCache.EditorAllowsVirtualization(this, orientation) == false)
			{
				// AS 3/2/11 TFS66933
				// Added if block. Basically we added a way for the developer to tell us to virtualize 
				// the field anyway even though we can't get to an editor or if the editor thinks it 
				// size is based on the value.
				//
				if (!this.GetResolvedValue<bool?>(FieldSettings.ForceCellVirtualizationProperty, null, false).Value) 
					return false;
			}

            
#region Infragistics Source Cleanup (Region)









#endregion // Infragistics Source Cleanup (Region)


            
#region Infragistics Source Cleanup (Region)





#endregion // Infragistics Source Cleanup (Region)

 
            return true;
		} 
				#endregion //GetAllowCellVirtualizationResolved

				#region GetDefaultDataForType
		// AS 4/15/09 Field.(Get|Set)CellValue
        // Needed to make this internal since now the DataRecord is accessing it.
        //
		//private static object GetDefaultDataForType(Type type)
		// JJD 1/4/12 - TFS98294 - Optimization
		// Added dataType paramater
		//internal static object GetDefaultDataForType(Type type)
		internal static object GetDefaultDataForType(Type type, Type dataType)
		{
			if (null == Field.sampleData)
			{
				Field.sampleData = CreateDefaultDataTable();
			}

            // JJD 2/20/09 - Optimization
            // Don't need to call ContainsKey since the indexer of the HashTable
            // will return null if the key isn't found
            //if (Field.sampleData.ContainsKey(type))
            //    return Field.sampleData[type];

			// JJD 1/4/12 - TFS98294 - Optimization
			// If the data type is different and the edit as type is 'string'
			// the use the default value based on the data type and convert
			// it to a string. This prevents first chance exceptions when trying
			// to convert the default value for string (i.e. 'Text') back
			// to the data type, e.g. 'Int32'
			object defvalue =null;
			if (dataType != null &&
				dataType != type &&
				type == typeof(string))
			{
				defvalue = Field.sampleData[dataType];

				if (defvalue != null)
					defvalue = defvalue.ToString();
			}
			
			// JJD 1/4/12 - TFS98294 - Optimization
			// if we don't have a default value at this point revert
			// to using the sample data appropriate to the edit as type
            //return Field.sampleData[type];
			if ( defvalue == null )
				defvalue = Field.sampleData[type];

			return defvalue;
			//return null;
		} 
				#endregion //GetDefaultDataForType

				// AS 3/13/07 BR21065
				// Moved from the DefaultCellHeight and added the ability to get
				// the height of the label within the template cell.
				//
				#region GetDefaultHeight

        // AS 2/20/09 NA 2009 Vol 1/TFS14038
        // Changed to a constant.
        //
        internal const double FallbackDefaultHeight = 32d;

		private double GetDefaultHeight(bool isLabel)
		{
			if (this._owner != null)
			{
				// AS 6/22/09 NA 2009.2 Field Sizing
				//DataPresenterBase dp = this._owner.DataPresenter;
				//
				//if (dp != null)
				//{
				//	if (dp.IsAutoFitHeight)
				//		return double.NaN;
				//}
				if (_owner.IsAutoFitHeight)
				{
					// AS 8/11/09 TFS18985
					// For a horizontal layout, we want to default the preferred size to 
					// a small value so the weights are treated more like star values 
					// but still allow for the standard grid bag layout behavior of 
					// being able to distribute the preferred size first and then adjust 
					// based on the overage/underage.
					//
					if (_owner.IsHorizontal && GetWidthOrHeight(false).IsStar)
						return 0;

					return double.NaN;
				}

                // AS 2/20/09
                // We always virtualize now so this check isn't needed.
                //
				//if (this._owner.CanUseVirtualizedCellAreaTemplate)
				{
					// if this is the template record then use the content size
					if (this._owner.TemplateDataRecordCache.IsInitializingCache)
                        // AS 2/20/09
                        // We should be considering the EditAsType and not the DataType.
                        //
						//return GetDefaultDataForType(this.DataType) == null ? 32d : double.NaN;
						// JJD 1/4/12 - TFS98294 - Optimization
						// Added dataType paramater
						//return GetDefaultDataForType(this.EditAsTypeResolved) == null ? FallbackDefaultHeight : double.NaN;
                        return GetDefaultDataForType(this.EditAsTypeResolved, this.DataType) == null ? FallbackDefaultHeight : double.NaN;

					
					if (this._owner.StyleGenerator != null && this._owner.StyleGenerator.IsGeneratingTemplates)
                        return this._owner.IsHorizontal ? FallbackDefaultHeight : double.NaN;

					if (isLabel)
					{
						double labelHeight = this._owner.TemplateDataRecordCache.GetLabelPresenterHeight(this);

						// AS 3/14/07
						// Cannot compare to NaN. Also, we should only get a NaN if there is
						// no label in which case return 0 as the height.
						//
						//if (labelHeight != double.NaN)
						if (false == double.IsNaN(labelHeight))
							return labelHeight;

                        // JJD 4/23/08 - BR28386 - regression fix
                        // return 0 to allow actual measure to be used. In order for this to work properly in
                        // all scenarios we had to also return false from AllowLabelVirtualizationResolved
                        // if the field's LabelMaxHeight or LabelMinHeight values are explicity set. 
                        // AS 2/22/08 BR28386
						//return 0;
                        return 0;
					}
					// AS 2/22/08 BR28386
					// If there is no cell/label then do not return 0. Instead, just return
					// the default that we used to use - 32.
					//
					// // if the cell can be virtualized then use the height from the dummy record
					//if (this.GetAllowCellVirtualizationResolved(Orientation.Vertical))
                    // AS 2/20/09 NA 2009 Vol 1/TFS14038
                    // Previously we would not use the template cell size if the field didn't allow virtualization.
                    // Instead we just returned 32. This meant that something like a summaryrecord would end up 
                    // being taller if there was a field that didn't allow virtualization. While its possible the 
                    // template height is data dependant, it is more likely that the template cell could still provide
                    // a reasonable height. So we will use the template size always as we do with the label.
                    //
					//else if (this.GetAllowCellVirtualizationResolved(Orientation.Vertical))
                    else
					{
						// AS 3/14/07
						// If the cell can be virtualized but we cannot get a height for it
						// then it must not be in the layout so return 0.
						//
						//return this._owner.TemplateDataRecordCache.GetCellValuePresenterHeight(this);
						double cellHeight = this._owner.TemplateDataRecordCache.GetCellValuePresenterHeight(this);

                        // AS 2/20/09 NA 2009 Vol 1/TFS14038
                        bool canVirtualize = this.GetAllowCellVirtualizationResolved(Orientation.Vertical);

						if (false == double.IsNaN(cellHeight))
                        {
                            // AS 2/20/09 NA 2009 Vol 1/TFS14038
                            // In case the height is data dependant, we'll impose a reasonable minimum.
                            //
                            if (false == canVirtualize)
							{
								// MD 9/10/10 - TFS37596
								// To impose a minimum, we should use a Max operation, not a Min.
                                //cellHeight = Math.Min(16, cellHeight);
								cellHeight = Math.Max(16, cellHeight);
							}

							return cellHeight;
                        }

                        // AS 2/20/09 NA 2009 Vol 1/TFS14038
                        // I'm not sure what scenario would cause this but to reduce the chance of introducing
                        // an issue, if we get here we will do what we would have done in the past and return 
                        // 32.
                        //
                        if (false == canVirtualize)
                            return FallbackDefaultHeight;

                        // JJD 4/23/08 - BR28386 - regression fix
                        // return 0 to allow actual measure to be used. In order for this to work properly in
                        // all scenarios we had to also return false from GetAllowCellVirtualizationResolved
                        // if the field's CellMaxHeight or CellMinHeight values are explicity set. This will 
                        // then prevent us from getting in here since the cell then can't be virtualized.
						// AS 2/22/08 BR28386
						//return 0;
                        return 0;
					}
				}
			}

            // AS 2/20/09 NA 2009 Vol 1/TFS14038
            //return 32d;
            return FallbackDefaultHeight;
		} 
				#endregion //GetDefaultHeight

				#region GetDefaultWidth

		internal const double FallbackDefaultWidth = 120d;

		// AS 10/9/09 NA 2010.1 - CardView
		// Moved here from the DefaultCellWidth so we can handle labels separately.
		//
		private double GetDefaultWidth(bool isLabel)
		{
			// AS 12/21/08 NA 2009 Vol 1 - Fixed Fields
			// To try and preserve some of the previous TemplateColumnDefinition
			// functionality, we will use the column definition width as the 
			// default width.
			//
			double extent = FallbackDefaultWidth;

			// AS 8/11/09 TFS18985
			// For a vertical layout, we want to default the preferred size to 
			// a small value so the weights are treated more like star values 
			// but still allow for the standard grid bag layout behavior of 
			// being able to distribute the preferred size first and then adjust 
			// based on the overage/underage.
			//
			if (_owner != null && _owner.IsAutoFitWidth && !_owner.IsHorizontal)
			{
				if (GetWidthOrHeight(true).IsStar)
					return 0;
			}

			TemplateDataRecordCache cache = this._owner != null ? this._owner.TemplateDataRecordCache : null;

			if (null != cache)
			{
				// AS 10/9/09 NA 2010.1 - CardView
				// In a card view we want the labels to only be as wide as they need to be.
				//
				if (isLabel && null != _owner && _owner.CellPresentation == CellPresentation.CardView)
				{
					extent = cache.GetLabelPresenterWidth(this);
					return extent;
				}

				extent = cache.GetDefaultCellWidth(this, extent);
			}

			return extent;
		} 
				#endregion //GetDefaultWidth

                // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                #region GetFlag
        private bool GetFlag(FieldFlags flag)
        {
            return (flag & _fieldFlags) != 0;
        } 
                #endregion //GetFlag

                #region OnSettingsPropertyChanged

        private void OnSettingsPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
			// AS 5/12/10 Sl-WPF Sharing
			// NestedPropertyChangedEventArgs is obsolete.
			//
            //this.RaisePropertyChangedEvent("Settings", sender, e);

			// SSP 4/23/08 - Summaries Functionality
			// Added infrastructure so field, field layout and the data presenter can each process
			// change in field settings of any of these objects.
			// --------------------------------------------------------------------------------------
			
#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)

			FieldLayout fieldLayout = this.Owner;
			DataPresenterBase presenter = null != fieldLayout ? fieldLayout.DataPresenter : null;
			Field.ProcessFieldSettingsPropertyChanged( e, _settings, this, null != presenter, null != fieldLayout, this, fieldLayout, presenter );
			// --------------------------------------------------------------------------------------
        }

                #endregion //OnSettingsPropertyChanged	

				// AS 12/10/07 BR25223
				#region ProcessSizeChange
        // AS 12/3/08 TFS11189
        // Changed param name from isColumn to isWidth to be consistent with the info provided.
        // We will determine if its column or not based on the owner state.
        //
		//private void ProcessSizeChange(bool isCell, bool isColumn, SizeChangeType changeType, double value)
		private void ProcessSizeChange(bool isCell, bool isWidth, SizeChangeType changeType, double value)
		{
			if (this._owner != null && this._owner.StyleGenerator != null)
			{
                
#region Infragistics Source Cleanup (Region)
























































#endregion // Infragistics Source Cleanup (Region)

                this.BumpLayoutItemVersion();
			}
		}
				#endregion //ProcessSizeChange

                // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
                #region SetFlag
        private void SetFlag(FieldFlags flag, bool value)
        {
            if (value)
                _fieldFlags |= flag;
            else
                _fieldFlags &= ~flag;
        } 
                #endregion //SetFlag

				#region VerifyRecordFilterRelatedCache

		// SSP 12/10/08 - NAS9.1 Record Filtering
		// 
		private void VerifyRecordFilterRelatedCache( )
		{
			if ( _isFilterRecordCacheDirty )
			{
				_isFilterRecordCacheDirty = false;
                
				// By default display the operator with the operand.
				//
				_cachedDefaultFilterOperatorVisibility = Visibility.Visible;

				Type editAsType = this.EditAsTypeResolved;
				Type editAsTypeUnderying = Utilities.GetUnderlyingType( editAsType );

				_cachedDefaultFilterOperatorDropDownItems = ComparisonCondition.GetCompatibleComparisonOperators(
					editAsType, out _cachedDefaultFilterOperatorDefaultValue );
				
				if ( ( this.IsEditAsTypeNumeric || typeof( DateTime ) == editAsTypeUnderying )
					
					
					
					
					)
				{
					_cachedDefaultFilterOperandUIType = FilterOperandUIType.Combo;
				}
				else if ( typeof( bool ) == editAsTypeUnderying )
				{
					_cachedDefaultFilterOperandUIType = FilterOperandUIType.UseFieldEditor;
                    _cachedDefaultFilterOperatorVisibility = Visibility.Collapsed;
				}
				else
				{
					_cachedDefaultFilterOperandUIType = FilterOperandUIType.Combo;
				}

				// SSP 5/12/05 BR03904
				// If the user explicitly set the default operator then always include it in the filter
				// operator drop down list even if it's not appropriate for the column's data type.
				//
				ComparisonOperatorFlags defaultOperator = ComparisonCondition.GetComparisonOperatorFlag( this.FilterOperatorDefaultValueResolved );
				_cachedDefaultFilterOperatorDropDownItems |= defaultOperator;

				// If number of items in the filter operator drop down is 1 or less then hide the filter
				// operator button.
				//
				ComparisonOperatorFlags filterDropDownItemsResolvedFlags = this.FilterOperatorDropDownItemsResolved;
				ComparisonOperator[] filterDropDownItemsResolvedList = ComparisonCondition.GetComparisonOperators( filterDropDownItemsResolvedFlags );
				int numOfOperatorOptions = filterDropDownItemsResolvedList.Length;
				if ( numOfOperatorOptions <= 1 )
					_cachedDefaultFilterOperatorVisibility = Visibility.Collapsed;

				// If they explicitly set the FilterDropDownItems, then the default operator that we select should
				// be one of them. For example, if they set the drop-down operators to "Equals | NotEquals", we
				// shouldn't use "StartsWith" as the default operator. It should be one of Equals or NotEquals.
				// 
				if ( 0 == ( ComparisonCondition.GetComparisonOperatorFlag( _cachedDefaultFilterOperatorDefaultValue ) & filterDropDownItemsResolvedFlags ) )
					_cachedDefaultFilterOperatorDefaultValue = ComparisonCondition.GetCompatibleComparisonOperator( editAsType, filterDropDownItemsResolvedFlags );

                // JJD 1/20/9 - NA 2009 vol 1 - Filtering in reports
                DataPresenterBase dp = this._owner != null ? this._owner.DataPresenter : null;
                if (dp != null && dp.IsReportControl)
                {
                    _cachedDefaultFilterOperatorVisibility = Visibility.Collapsed;
                    _cachedDefaultFilterOperandUIType = FilterOperandUIType.None;
                }

				this.RaisePropertyChangedEvent( "FilterOperatorDropDownItemsResolved" );
				this.RaisePropertyChangedEvent( "FilterOperatorDefaultValueResolved" );
				this.RaisePropertyChangedEvent( "FilterOperandUITypeResolved" );
				this.RaisePropertyChangedEvent( "FilterOperatorVisibilityResolved" );
 			}
		}

				#endregion // VerifyRecordFilterRelatedCache

			#endregion //Private Methods

		#endregion //Methods

		#region private class ResizeValues

		private class ResizeValues
        {
            internal double LabelResizeWidth = double.NaN;
            internal double LabelResizeHeight = double.NaN;
            internal double CellResizeWidth = double.NaN;
            internal double CellResizeHeight = double.NaN;
        }

        #endregion //private class ResizeValues

		#region FieldResizeInfo Class [Private]

		
		
		
		internal class FieldResizeInfo
		{
			#region Member Vars

			private Field _field;
			// AS 7/30/09 NA 2009.2 Field Sizing
			//private double _labelWidth = double.NaN, _labelHeight = double.NaN;
			//private double _cellWidth = double.NaN, _cellHeight = double.NaN;
			private FieldSize _labelWidth;
			private FieldSize _labelHeight;
			private FieldSize _cellWidth;
			private FieldSize _cellHeight;

			#endregion // Member Vars

			#region Constructor

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="field"></param>
			internal FieldResizeInfo( Field field )
			{
				GridUtilities.ValidateNotNull( field );

				_field = field;

				// AS 7/30/09 NA 2009.2 Field Sizing
				_labelWidth = _labelHeight = _cellWidth = _cellHeight = FieldSize.Empty;
			}

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="field"></param>
            /// <param name="initializeFrom"></param>
			internal FieldResizeInfo( Field field, FieldResizeInfo initializeFrom ) : this(field)
			{
                GridUtilities.ValidateNotNull(initializeFrom);

				this._cellHeight    = initializeFrom._cellHeight;
				this._cellWidth     = initializeFrom._cellWidth;
				this._labelHeight   = initializeFrom._labelHeight;
				this._labelWidth    = initializeFrom._labelWidth;
			}

			#endregion // Constructor

			#region Base class overrides

			public override int GetHashCode()
			{
				return _field.GetHashCode() 
					| _cellHeight.GetHashCode()
					| _cellWidth.GetHashCode()
					| _labelHeight.GetHashCode()
					| _labelWidth.GetHashCode()
					;
			}

			// AS 5/29/09 NA 2009.2 Undo/Redo
			public override bool Equals(object obj)
			{
				FieldResizeInfo other = obj as FieldResizeInfo;
				return null != other
					&& _field == other._field
					&& _cellHeight.Equals(other._cellHeight)
					&& _cellWidth.Equals(other._cellWidth)
					&& _labelHeight.Equals(other._labelHeight)
					&& _labelWidth.Equals(other._labelWidth)
					;
			} 
			#endregion //Base class overrides

			#region Properties

			#region CellHeight

			// AS 7/30/09 NA 2009.2 Field Sizing
			//internal double CellHeight
			//{
			//    get
			//    {
			//        return _cellHeight;
			//    }
			//    set
			//    {
			//        if (_cellHeight != value)
			//        {
			//            _cellHeight = value;
			//
			//            // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
			//            //_field.RaisePropertyChangedEvent("CellHeightResolved");
			//            OnPropertyChanged("CellHeightResolved");
			//        }
			//    }
			//}

			#endregion // CellHeight

			#region CellWidth

			// AS 7/30/09 NA 2009.2 Field Sizing
			//internal double CellWidth
			//{
			//    get
			//    {
			//        return _cellWidth;
			//    }
			//    set
			//    {
			//        if (_cellWidth != value)
			//        {
			//            _cellWidth = value;
			//
			//            // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
			//            //_field.RaisePropertyChangedEvent( "CellWidthResolved" );
			//            OnPropertyChanged("CellWidthResolved");
			//        }
			//    }
			//}

			#endregion // CellWidth

			// AS 5/29/09 NA 2009.2 Undo/Redo
			#region Field
			internal Field Field
			{
				get { return _field; }
			} 
			#endregion //Field

			#region LabelHeight

			// AS 7/30/09 NA 2009.2 Field Sizing
			//internal double LabelHeight
			//{
			//    get
			//    {
			//        return _labelHeight;
			//    }
			//    set
			//    {
			//        if (_labelHeight != value)
			//        {
			//            _labelHeight = value;
			//
			//            // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
			//            //_field.RaisePropertyChangedEvent( "LabelHeightResolved" );
			//            OnPropertyChanged("LabelHeightResolved");
			//        }
			//    }
			//}

			#endregion // LabelHeight

			#region LabelWidth

			// AS 7/30/09 NA 2009.2 Field Sizing
			//internal double LabelWidth
			//{
			//    get
			//    {
			//        return _labelWidth;
			//    }
			//    set
			//    {
			//        if (_labelWidth != value)
			//        {
			//            _labelWidth = value;
			//
			//            // AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
			//            //_field.RaisePropertyChangedEvent( "LabelWidthResolved" );
			//            OnPropertyChanged("LabelWidthResolved");
			//        }
			//    }
			//}

			#endregion // LabelWidth

			#endregion //Properties

			#region Methods

			// AS 7/31/09 NA 2009.2 Field Sizing
			#region ClearAuto
			internal void ClearAuto(bool label, bool width)
			{
				FieldSize size = GetSize(label, width);

				if (size.HasAutoModeSize)
					SetSize(label, width, FieldSize.Empty);
			}
			#endregion //ClearAuto

			// AS 7/30/09 NA 2009.2 Field Sizing
			#region ClearExplicit
			internal void ClearExplicit(bool label, bool width)
			{
				FieldSize size = GetSize(label, width);

				if (size.HasExplicitSize)
					SetSize(label, width, FieldSize.Empty);
			} 
			#endregion //ClearExplicit

			// AS 5/29/09 NA 2009.2 Undo/Redo
			#region Clone
			public FieldResizeInfo Clone()
			{
				return (FieldResizeInfo)this.MemberwiseClone();
			} 
			#endregion //Clone

			// AS 7/30/09 NA 2009.2 Field Sizing
			#region GetSize
			internal FieldSize GetSize(bool label, bool width)
			{
				if (label)
					return width ? _labelWidth : _labelHeight;
				else
					return width ? _cellWidth : _cellHeight;
			} 
			#endregion //GetSize

			// AS 5/29/09 NA 2009.2 Undo/Redo
			#region InitializeFrom
			internal void InitializeFrom(FieldResizeInfo resizeInfo)
			{
				Debug.Assert(null != resizeInfo && resizeInfo._field == _field);

				if (this.Equals(resizeInfo))
					return;

				_cellHeight = resizeInfo._cellHeight;
				_cellWidth = resizeInfo._cellWidth;
				_labelHeight = resizeInfo._labelHeight;
				_labelWidth = resizeInfo._labelWidth;

				this.OnPropertyChanged("");
			} 
			#endregion //InitializeFrom

			// AS 12/17/08 NA 2009 Vol 1 - Fixed Fields
			#region OnPropertyChanged
			private void OnPropertyChanged(string propertyName)
			{
				_field.BumpLayoutItemVersion();
				_field.RaisePropertyChangedEvent(propertyName);
			}
			#endregion //OnPropertyChanged

			#region Reset

			internal void Reset()
			{
				// AS 7/30/09 NA 2009.2 Field Sizing
				// This method is used to clear user customizations so clear any value that 
				// is not an auto calculated value.
				//
				//this.CellWidth = double.NaN;
				//this.CellHeight = double.NaN;
				//this.LabelWidth = double.NaN;
				//this.LabelHeight = double.NaN;
				ResetNonAutoMode(ref _cellHeight);
				ResetNonAutoMode(ref _cellWidth);
				ResetNonAutoMode(ref _labelHeight);
				ResetNonAutoMode(ref _labelWidth);
			}

			#endregion // Reset

			// AS 7/30/09 NA 2009.2 Field Sizing
			#region ResetNonAutoMode
			private static void ResetNonAutoMode(ref FieldSize size)
			{
				if (size.Type != ItemSizeType.AutoMode)
					size = new FieldSize(double.NaN);
			} 
			#endregion //ResetNonAutoMode

			#region RestrictHelper

			internal void Restrict(bool label, bool width, double min, double max)
			{
				FieldSize size = GetSize(label, width);

				double newValue = RestrictHelper(size.Value, min, max);

				if (!newValue.Equals(size.Value))
					SetSize(label, width, new FieldSize(newValue, size.Type));
			}

			internal static double RestrictHelper(double val, double min, double max)
			{
				if (double.IsNaN(val))
					return val;

				if (!double.IsNaN(min))
					val = Math.Max(min, val);

				if (!double.IsNaN(max))
					val = Math.Min(max, val);

				return val;
			}

			#endregion // RestrictHelper

			// AS 7/30/09 NA 2009.2 Field Sizing
			#region SetSize
			internal void SetSize(bool label, bool width, FieldSize size)
			{
				if (label)
				{
					if (width)
						SetSize(ref _labelWidth, size, "LabelWidthResolved");
					else
						SetSize(ref _labelHeight, size, "LabelHeightResolved");
				}
				else
				{
					if (width)
						SetSize(ref _cellWidth, size, "CellWidthResolved");
					else
						SetSize(ref _cellHeight, size, "CellHeightResolved");
				}
			}

			private void SetSize(ref FieldSize member, FieldSize newValue, string propertyName)
			{
				if (!member.Equals(newValue))
				{
					// bump if going to/from auto mode
					if (member.IsAuto != newValue.IsAuto && null != _field._owner)
						_field._owner.BumpLayoutManagerVersion();

					member = newValue;
					this.OnPropertyChanged(propertyName);
				}
			}
			#endregion //GetSize

			#endregion //Methods
		}

		#endregion // FieldResizeInfo Class [Private]

		#region internal class FieldGridPosition

		// JJD 5/1/07 - Optimization
		// Changed from struct to class to prevent excessive boxig operations
        //internal struct FieldGridPosition
        internal class FieldGridPosition
        {
            internal int Row;
            internal int Column;
            internal int RowSpan;
            internal int ColumnSpan;

            public override string ToString()
            {
                return string.Format("{0},{1},{2},{3}", this.Row, this.Column, this.RowSpan, this.ColumnSpan);
            }

			// SSP 6/30/09 - NAS9.2 Field Chooser
			// 
			/// <summary>
			/// Returns true if any of the Row, Column, RowSpan and ColumnSpan values are non-zero.
			/// </summary>
			internal bool IsEmpty
			{
				get
				{
					
					
					
					
					return 0 == this.Row && 0 == this.Column && 0 == this.RowSpan && 0 == this.ColumnSpan;
				}
			}
		}
    
        #endregion //internal class FieldGridPosition

        // JJD 7/25/08 - BR35098 added
        #region private class DefaultValueMarker

        private class DefaultValueMarker
        {
            internal static DefaultValueMarker Instance = new DefaultValueMarker();

            public override string ToString()
            {
                return string.Empty;
            }
        }

        #endregion //private class DefaultValueMarker	
    
        // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
        #region FieldFlags
        [Flags()]
        private enum FieldFlags
        {
            CellVirtualized = 0x1,
            LabelVirtualized = 0x2,
            FilterCellVirtualized = 0x4,
            IsInLayout = 0x8,
            // AS 3/3/09 Optimization
            SuppressFixedLocationInvalidate = 0x10,
        } 
        #endregion //FieldFlags

		// AS 12/10/07 BR25223
		#region SizeChangeType enum
		private enum SizeChangeType
		{
			Min,
			Max,
			Size,
		}
		#endregion //SizeChangeType enum

		#region ISelectableItem Members

        bool ISelectableItem.IsDraggable
        {
            get 
			{
				// SSP 5/20/09 TFS17816
				// 

				return null != _owner && AllowFieldMoving.No != _owner.AllowFieldMovingResolved;



				
#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)

			}
 
        }

        bool ISelectableItem.IsSelectable
        {
            get { return true; } 
        }

        bool ISelectableItem.IsSelected
        {
            get { return this.IsSelected; } 
        }

        bool ISelectableItem.IsTabStop
        {
            get { return false; } 
        }

        #endregion
    }

    #endregion //Field class

	#region UnboundField class

	/// <summary>
    /// Added to a FieldLayout's Fields collection to specify additional fields that are not in the underlying DataSource. 
    /// </summary>
	/// <remarks>
	/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an overall explanation of how everything works together.</p>
	/// <p class="body">Refer to the <a href="xamData_Assigning_a_FieldLayout.html">Assigning a FieldLayout</a> topic in the Developer's Guide for an example of adding an <see cref="UnboundField"/> to a <see cref="FieldLayout"/>.</p>
	/// </remarks>
	/// <seealso cref="Field.IsUnbound"/>
	/// <seealso cref="UnboundCell"/>
	/// <seealso cref="Field"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
    /// <seealso cref="FieldLayout"/>
    /// <seealso cref="FieldLayoutSettings"/>
    /// <seealso cref="FieldSettings"/>
    /// <seealso cref="FieldLayout.Fields"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayouts"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldSettings"/>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase.DefaultFieldLayout"/>
	public class UnboundField : Field
	{
        #region Private Members

        // JJD 2/11/10 - TFS26644 - added
        private BindingBase _binding;

		// JJD 11/08/10 - TFS31178 - added
		private bool _isBoundToRootProperty;

        #endregion //Private Members	
    
		#region Constructors

		static UnboundField( )
		{
			// SSP 1/30/07 BR19529
			// Default the data type to string on unbound fields.
			// 
			Field.DataTypeProperty.OverrideMetadata( typeof( UnboundField ), new FrameworkPropertyMetadata( typeof( string ) ) );
			Field.IsUnboundPropertyKey.OverrideMetadata( typeof( UnboundField ), new FrameworkPropertyMetadata( KnownBoxes.TrueBox ) );
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="UnboundField"/> class
		/// </summary>
		public UnboundField()
		{
		}

		#endregion //Constructors

		#region Base class overrides

            // JJD 9/10/08 - added clone support for printing
            #region InitializeFrom

        internal override void InitializeFrom(Field source)
        {
            UnboundField sourceFld = source as UnboundField;

            base.InitializeFrom(source);

            this.BindingMode = sourceFld.BindingMode;
            this.BindingPath = sourceFld.BindingPath;

            // JJD 2/11/10 - TFS26644 
            // Added Binding property
            this.Binding = sourceFld.Binding;
        }

            #endregion //InitializeFrom	
    
			#region IsUnbound

		/// <summary>
		/// Returns true (read-only)
		/// </summary>
		/// <seealso cref="Field.IsUnboundProperty"/>
		/// <seealso cref="UnboundField"/>
		/// <seealso cref="DataItemPresenter.IsUnbound"/>
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		public override bool IsUnbound
		{
			get
			{
				return true;
			}
		}

			#endregion //IsUnbound

		#endregion //Base class overrides	
    
		#region Properties

            // JJD 2/11/10 - TFS26644 - added
            #region Binding

        private static void OnBindingRelatedPropertyChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            UnboundField ufld = target as UnboundField;

            BindingBase binding = ufld.Binding;

            if (binding != null)
                ufld.ValidateBindingSetting(binding);

			// JJD 11/08/10 - TFS31178 - added
			ufld.InitializeIsBoundToRootProperty();
		}

        // JJD 2/11/10 - TFS26644 - added
        private void ValidateBindingSetting(BindingBase binding)
        {
            if (binding != null)
            {
                string errorProp = null;

                if (this.BindingPath != null)
                    errorProp = "BindingPath";
                else if ( !Object.Equals( this.BindingMode, BindingModeProperty.DefaultMetadata.DefaultValue ))
                    errorProp = "BindingMode";

                if ( errorProp != null )
                    throw new InvalidOperationException(DataPresenterBase.GetString( "LE_InvalidOperationException_26B", errorProp ) );
            }


        }
		
        /// <summary>
        /// Gets/sets a binding that will be used to bind each <see cref="CellValuePresenter"/>'s Value property
        /// </summary>
        /// <example>
        /// <para>
        /// The following sample shows the proper syntax for binding an <see cref="UnboundField"/> in xaml.
        /// </para>
        /// <code>
        /// <DataPresenterBase.FieldLayouts>
        /// 
        ///	  <FieldLayout>
        ///     <FieldLayout.Fields>
        ///
        ///			<UnboundField Name="Foo" Binding="{Binding Path=City}">
        ///
        ///         </UnboundField>
        ///
        ///      </FieldLayout.Fields>
        ///
        ///   </FieldLayout>
        ///
        /// </DataPresenterBase.FieldLayouts>
        ///</code>
        /// </example>
        /// <remarks>
        /// <para class="note"><b>Note:</b> <see cref="Binding"/> and either <see cref="BindingPath"/> or <see cref="BindingMode"/> are mutually exclusive and an attempt to set both will trigger an <see cref="InvalidOperationException"/>.</para>
        /// </remarks>
        /// <exception cref="InvalidOperationException">If this property is set and either <see cref="BindingPath"/> or <see cref="BindingMode"/> have been specified.</exception>
        /// <seealso cref="BindingPath"/>
        /// <seealso cref="BindingMode"/>
        //[Description("Gets/sets a binding that will be used to bind each CellValuePresenter's Value property")]
        //[Category("Data")]
        [DefaultValue(null)]
        [Bindable(false)]
        public BindingBase Binding
        {
            get
            {
                return this._binding;
            }
            set
            {
                if (this._binding != value)
                {
                    this.ValidateBindingSetting(value);

                    this._binding = value;
					
					// JJD 11/08/10 - TFS31178 - added
					this.InitializeIsBoundToRootProperty();

                    this.RaisePropertyChangedEvent("Binding");
                }
            }
        }

            #endregion //Binding
	
			#region BindingMode

		/// <summary>
		/// Identifies the <see cref="BindingMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty BindingModeProperty = DependencyProperty.Register("BindingMode",
            typeof(BindingMode), typeof(UnboundField), new FrameworkPropertyMetadata(BindingMode.OneWay, new PropertyChangedCallback(OnBindingRelatedPropertyChanged)));

		/// <summary>
		/// Gets/sets a value that indicates the direction on the data flow in the binding.
		/// </summary>
		/// <example>
		/// <para>
		/// The following sample shows the proper syntax for binding an <see cref="UnboundField"/> in xaml.
		/// </para>
		/// <code>
		/// <DataPresenterBase.FieldLayouts>
		/// 
		///	  <FieldLayout>
		///     <FieldLayout.Fields>
		///
		///			<UnboundField Name="Foo" Row="0" Column="0" BindingPath="City" BindingMode="TwoWay">
		///
		///           <Field.Settings>
		///
		///             <FieldSettings CellContentAlignment="ValueOnly" CellValuePresenterStyle="{StaticResource Card.City}"/>
		///
		///           </Field.Settings>
		///
		///         </UnboundField>
		///
		///      </FieldLayout.Fields>
		///
		///   </FieldLayout>
		///
		/// </DataPresenterBase.FieldLayouts>
		///</code>
		/// </example>
        /// <remarks>
        /// <para class="note"><b>Note:</b> <see cref="Binding"/> and either <see cref="BindingPath"/> or <see cref="BindingMode"/> are mutually exclusive and an attempt to set both will trigger an <see cref="InvalidOperationException"/>.</para>
        /// </remarks>
        /// <exception cref="InvalidOperationException">If this property and <see cref="Binding"/> have both been specified.</exception>
        /// <seealso cref="BindingModeProperty"/>
		/// <seealso cref="BindingPathProperty"/>
		/// <seealso cref="Binding"/>
		/// <seealso cref="BindingPath"/>
		//[Description("Gets/sets a value that indicates the direction on the data flow in the binding.")]
		//[Category("Data")]
		[DefaultValue(BindingMode.OneWay)]
		public BindingMode BindingMode
		{
			get
			{
				return (BindingMode)this.GetValue(UnboundField.BindingModeProperty);
			}
			set
			{
				this.SetValue(UnboundField.BindingModeProperty, value);
			}
		}

			#endregion //BindingMode

			#region BindingPath

		/// <summary>
		/// Identifies the <see cref="BindingPath"/> dependency property
		/// </summary>
		public static readonly DependencyProperty BindingPathProperty = DependencyProperty.Register("BindingPath",
            typeof(PropertyPath), typeof(UnboundField), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnBindingRelatedPropertyChanged)));

		/// <summary>
		/// Gets/sets the path to the binding source property.
		/// </summary>
		/// <example>
		/// <para>
		/// The following sample shows the proper syntax for binding an <see cref="UnboundField"/> in xaml.
		/// </para>
		/// <code>
		/// <DataPresenterBase.FieldLayouts>
		/// 
		///	  <FieldLayout>
		///     <FieldLayout.Fields>
		///
		///			<UnboundField Name="Foo" Row="0" Column="0" BindingPath="City" BindingMode="TwoWay">
		///
		///           <Field.Settings>
		///
		///             <FieldSettings CellContentAlignment="ValueOnly" CellValuePresenterStyle="{StaticResource Card.City}"/>
		///
		///           </Field.Settings>
		///
		///         </UnboundField>
		///
		///      </FieldLayout.Fields>
		///
		///   </FieldLayout>
		///
		/// </DataPresenterBase.FieldLayouts>
		///</code>
		/// </example>
        /// <remarks>
        /// <para class="note"><b>Note:</b> <see cref="Binding"/> and either <see cref="BindingPath"/> or <see cref="BindingMode"/> are mutually exclusive and an attempt to set both will trigger an <see cref="InvalidOperationException"/>.</para>
        /// </remarks>
        /// <exception cref="InvalidOperationException">If this property and <see cref="Binding"/> have both been specified.</exception>
        /// <seealso cref="BindingMode"/>
		/// <seealso cref="BindingModeProperty"/>
		/// <seealso cref="BindingPathProperty"/>
		/// <seealso cref="Binding"/>
		//[Description("Gets/sets the path to the binding source property.")]
		//[Category("Data")]
		[DefaultValue(null)]
		public PropertyPath BindingPath
		{
			get
			{
				return (PropertyPath)this.GetValue(UnboundField.BindingPathProperty);
			}
			set
			{
				this.SetValue(UnboundField.BindingPathProperty, value);
			}
		}

			#endregion //BindingPath

			#region BindingRetentionMode

		// SSP 3/22/10 - Optimizations
		// 

		/// <summary>
		/// Identifies the <see cref="BindingRetentionMode"/> dependency property.
		/// </summary>
		public static readonly DependencyProperty BindingRetentionModeProperty = DependencyProperty.Register(
			"BindingRetentionMode",
			typeof( BindingRetentionMode ),
			typeof( UnboundField ),
			new FrameworkPropertyMetadata( BindingRetentionMode.AutoRelease, FrameworkPropertyMetadataOptions.None )
		);

		/// <summary>
		/// Specifies whether the unbound field should auto-release binding objects or retain them after they are created.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// By default the unbound field creates a binding object for every unbound cell whose value is accessed and
		/// then discards it after evaluating the binding so minimize the memory usage. This however means that every
		/// time an unbound cell's value is accessed, it will have to re-create the binding object. Even though this
		/// preserves memory, it may have adverse performance impact since the binding has to be re-created every 
		/// time the unbound cell's value is needed. This adverse performance will be surfaced when a sort or
		/// group-by operation is performed on the unbound field with a lot of records. When this property is set to
		/// <i>Retain</i>, the bindings will be retained and successive sort, group-by or any other operations that
		/// require accessing values of all the unbound cells will be less performance intensive.
		/// </para>
		/// </remarks>
		/// <seealso cref="BindingPath"/>
		/// <seealso cref="Binding"/>
		/// <seealso cref="BindingMode"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter"/>
		[Description( "Specifies whether to auto-release binding objects or to retain them after they are created." )]
		[Category( "Behavior" )]
		[Bindable( true )]
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		public BindingRetentionMode BindingRetentionMode
		{
			get
			{
				return (BindingRetentionMode)this.GetValue( BindingRetentionModeProperty );
			}
			set
			{
				this.SetValue( BindingRetentionModeProperty, value );
			}
		}

			#endregion // BindingRetentionMode

			#region Internal Properties

				// JJD 11/08/10 - TFS31178 - added
				#region IsBoundToRootProperty

		internal bool IsBoundToRootProperty
		{
			get { return this._isBoundToRootProperty; }
		}

				#endregion //Internal Properties	
    
			#endregion //IsBoundToRootProperty	
    
		#endregion //Properties	

		#region Methods

			#region Private Methods

				// JJD 11/08/10 - TFS31178 - added
				#region InitializeIsBoundToRootProperty

		private void InitializeIsBoundToRootProperty()
		{
			this._isBoundToRootProperty = false;

			// get the propertypath for the binding
			PropertyPath ppath = this.BindingPath;

			if (ppath == null)
			{
				Binding binding = this.Binding as Binding;

				if (binding != null)
					ppath = binding.Path;
			}

			if (ppath != null)
			{
				string path = ppath.Path;

				if (path != null && path.Length > 0)
				{
					// make sure there is only one section to the path
					string[] sections = path.Split(new Char[] { '.', '[', '\0', '/' });

					this._isBoundToRootProperty = sections.Length == 1;
				}
			}
		}

				#endregion //InitializeIsBoundToRootProperty

			#endregion //Private Methods	
    
		#endregion //Methods	
                
	}

	#endregion //UnboundField class

	#region IGroupByEvaluator interface

    /// <summary>
    /// Interface to be used for determining how <see cref="DataRecord"/>s are grouped.
    /// </summary>
	/// <remarks>
	/// <para class="body">The GroupByEvaluator needs to be logically consistent with the sorted order of the <see cref="DataRecord"/>s which can be controlled via the <see cref="FieldSettings.GroupByComparer"/> or <see cref="FieldSettings.SortComparer"/> properties.</para>
	/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
	/// </remarks>
    /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
    /// <seealso cref="DataRecord"/>
    /// <seealso cref="Field.Settings"/>
    /// <seealso cref="FieldSettings.GroupByComparer"/>
    /// <seealso cref="FieldSettings.GroupByEvaluator"/>
    /// <seealso cref="FieldSettings.GroupByMode"/>
    /// <seealso cref="FieldSettings"/>
    /// <seealso cref="GroupByRecord"/>
    /// <seealso cref="FieldSettings.SortComparer"/>
    public interface IGroupByEvaluator
    {
        /// <summary>
        /// Returns the value that will be used to initialize a <see cref="Infragistics.Windows.DataPresenter.GroupByRecord"/>
        /// </summary>
        /// <param name="groupByRecord">The new group by record.</param>
        /// <param name="record">The first record to be included in a new group by record.</param>
        /// <returns>The value to use as the new group by record's <see cref="Infragistics.Windows.DataPresenter.GroupByRecord"/>.</returns>
        /// <remarks>
        /// <p>In order to keep the default value use the following code:</p>
        /// <p></p>
        /// <pre>
        /// public object GetGroupByValue( GroupByRecord groupByRecord, DataRecord record )
        /// {
        ///		return groupByRecord.Value;
        /// }
        /// </pre>
        /// </remarks>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="Field"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        object GetGroupByValue(GroupByRecord groupByRecord, DataRecord record);

        /// <summary>
        /// Method for determining if a record should be included in a <see cref="GroupByRecord"/>.
        /// </summary>
        /// <param name="groupByRecord">The group by record that contains other records.</param>
        /// <param name="record">The record to be tested</param>
        /// <returns>True if the record should be considered part of this group.</returns>
        /// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="Field"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
        bool DoesGroupContainRecord(GroupByRecord groupByRecord, DataRecord record);

		// JJD 2/23/07 - BR19943
		// Added SortComparer property to interface to handle situations where the groupby 
		// requires a logically consistent sort order. E.g. when grouping by text instead of value.
		/// <summary>
		/// The comparer to use for sorting the records.
		/// </summary>
		/// <value>Returns an object that implements IComparer or null to use the default sort comparer.</value>
		/// <remarks>The implementor should return null from this property to use the default comparer.
		/// <para></para>
		/// <p class="note">
		/// <b>Note:</b><see cref="Cell"/> objects are passed into the Compare method instead of values.
		/// </p>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/>
        /// <seealso cref="DataRecord"/>
        /// <seealso cref="Field"/>
        /// <seealso cref="Cell"/>
        /// <seealso cref="FieldSettings.GroupByComparer"/>
        /// <seealso cref="FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="FieldSettings.GroupByMode"/>
        /// <seealso cref="FieldSettings"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="FieldSettings.SortComparer"/>
		IComparer SortComparer { get; }
    }

    #endregion IGroupByEvaluator

	#region CellElementKey

	// JJD 5/3/07 - Optimization
	// Added CellElementKey to allow use to share cells from like Fields in the template record
	// AS 5/24/07 Optimization
	// It is better if we implement IEquatable to remove the necessity to do type casting.
	//
	//internal class CellElementKey
	internal class CellElementKey : IEquatable<CellElementKey>
	{
		#region Private Members

		private bool _isExpandable;
		private bool _isVertical;
		private Style _cellPresenterStyle;
		private Style _cellValuePresenterStyle;
		private Style _editorStyle;
		private CellContentAlignment _cellContentAlignment;
		private Type _editAsType;
		private Type _editorType;
        private bool _isPrinting;   // JJD 9/12/08 - added printing support
        private Field _field;       // JJD 9/21/08 - added printing support
		// AS 7/7/09 TFS19145
		// See CellElementKey ctor.
		//
		//double _cellHeight;
		//double _cellWidth;
        // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
        // Removed these. We will cache the LabelElementKey instead.
        //
        //double _labelHeight;
		//double _labelWidth;
        // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
        // Removed these as well. We only use the template cell to get
        // a preferred size. We don't use the Column/Row Span.
        //
        //int _columnSpan;
		//int _rowSpan;
		int _hashCode;

        // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
        LabelElementKey _labelKey;

		#endregion //Private Members

		internal CellElementKey(Field field)
		{
			// AS 7/7/09 TFS19145
			// This isn't used.
			//
			//Field.FieldGridPosition pos = field.GridPosition;
			FieldLayout				fl	= field.Owner;

			Debug.Assert(fl != null);

            // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
            bool isUsingCellPresenters = null != fl && fl.UseCellPresenters;

			this._isVertical				= fl == null || fl.IsHorizontal == false;
            // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
            // Removed these as well. We only use the template cell to get
            // a preferred size. We don't use the Column/Row Span.
            //
            //this._columnSpan				= pos.ColumnSpan;
			//this._rowSpan					= pos.RowSpan;
			this._isExpandable				= field.IsExpandableResolved;

            // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
            // Added if Block, the CellPresenterStyle shouldn't matter unless
            // we're using cell presenters.
            //
            if (isUsingCellPresenters)
    			this._cellPresenterStyle    = field.CellPresenterStyleResolved;

			this._cellValuePresenterStyle	= field.CellValuePresenterStyleResolved;
			this._editorStyle				= field.EditorStyleResolved;
			this._cellContentAlignment		= field.CellContentAlignmentResolved;
			this._editAsType				= field.EditAsTypeResolved;
			this._editorType				= field.EditorTypeResolved;
			// AS 7/7/09 TFS19145
			// I'm not sure why we felt we needed the explicit height/width as part of this 
			// key but it will cause problems now that we don't bump the version number for 
			// position changes because the cached cellplaceholder children will be cached with 
			// a different cell key. Since there really isn't a need to index off of this and 
			// because we don't even bump the version that would cause the key to be recreated 
			// when a resize occurs, I'm removing this part of the cell/label key.
			//
			//this._cellHeight				= field.GetCellHeightResolvedHelper(false);
			//this._cellWidth					= field.GetCellWidthResolvedHelper(false);

            // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
            // Removed these. We will cache the LabelElementKey instead.
            //
			//this._labelHeight				= field.GetLabelHeightResolvedHelper(false, false);
			//this._labelWidth				= field.GetLabelWidthResolvedHelper(false, false);

            if (isUsingCellPresenters)
                _labelKey                   = field.LabelElementKey;

            // JJD 9/12/08
            // Added printing support.
            // In printing we don't need to calc a hash code since we are using the the field's hashcode instead
            this._isPrinting                = fl.DataPresenter.IsReportControl;
            if (this._isPrinting)
            {
                this._field = field;
                return;
            }

			#region Calculate the hash code to cache

			if (this._isExpandable)
				this._hashCode = 1;

			if (this._cellPresenterStyle != null)
				this._hashCode += this._cellPresenterStyle.GetHashCode() / 20;

			if (this._cellValuePresenterStyle != null)
				this._hashCode += this._cellValuePresenterStyle.GetHashCode() / 20;

			if (this._editorStyle != null)
				this._hashCode += this._editorStyle.GetHashCode() / 20;

            // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
            // Removed these as well. We only use the template cell to get
            // a preferred size. We don't use the Column/Row Span.
            //
            //this._hashCode += (int)this._cellContentAlignment + this._columnSpan + this._rowSpan;
			this._hashCode += (int)this._cellContentAlignment;

			if (this._editAsType != null)
				this._hashCode += this._editAsType.GetHashCode() / 20;

			if (this._editorType != null)
				this._hashCode += this._editorType.GetHashCode() / 20;

			// AS 7/7/09 TFS19145
			// See CellElementKey ctor.
			//
			//if (!double.IsNaN(this._cellHeight))
			//	this._hashCode += this._cellHeight.GetHashCode() / 10;
			//
			//if (!double.IsNaN(this._cellWidth))
			//	this._hashCode += this._cellWidth.GetHashCode() / 10;

            
#region Infragistics Source Cleanup (Region)





#endregion // Infragistics Source Cleanup (Region)


            #endregion //Calculate the hash code to cache
        }

		#region Base class overrides

		public override bool Equals(object obj)
		{
			CellElementKey key = obj as CellElementKey;

			
#region Infragistics Source Cleanup (Region)





















#endregion // Infragistics Source Cleanup (Region)

			return this.Equals(key);
		}

		public override int GetHashCode()
		{
            // JJD 9/12/08
            // Added printing support
            // When we are printing we need to compare the fields themselves so use the field's hashcode
            if (this._isPrinting)
                return this._field.GetHashCode();

			return this._hashCode;
		}

		#endregion //Base class overrides	
	
		// AS 5/24/07 Optimization
		#region IEquatable<CellElementKey> Members

		public bool Equals(CellElementKey key)
		{
            if (key == null)
                return false;

            // JJD 9/21/08
            // Added printing support
            // When we are printing we need to compare the fields themselves 
            if (this._isPrinting)
                return this._field == key._field;

            return
                this._isVertical				== key._isVertical &&
                this._isExpandable              == key._isExpandable &&
                this._cellPresenterStyle        == key._cellPresenterStyle &&
                this._cellValuePresenterStyle   == key._cellValuePresenterStyle &&
                this._editorStyle               == key._editorStyle &&
                this._cellContentAlignment      == key._cellContentAlignment &&
                this._editAsType                == key._editAsType &&
                this._editorType                == key._editorType &&
                // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
                // The spans were removed.
                //
                //this._columnSpan				== key._columnSpan &&
                //this._rowSpan					== key._rowSpan &&
                // Call the Equals method instead of using the == operator
                // for double because the operator will return false if
                // both values are set to NaN,
				// AS 7/7/09 TFS19145
				// See CellElementKey ctor.
				//
				//this._cellHeight.Equals(key._cellHeight) &&
                //this._cellWidth.Equals(key._cellWidth) &&
                // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
                // We're not holding the label width/height.
                //
                //this._labelHeight.Equals(key._labelHeight) &&
                //this._labelWidth.Equals(key._labelWidth);			
                object.Equals(_labelKey, key._labelKey);
		}

		#endregion
	}

	#endregion //CellElementKey

    // AS 1/26/09 NA 2009 Vol 1 - Fixed Fields
    #region FilterCellElementKey
    internal class FilterCellElementKey : IEquatable<FilterCellElementKey>
    {
        #region Member Variables

        private Style _cellPresenterStyle;
        private Style _cellValuePresenterStyle;
        private Style _editorStyle;
        private Type _editAsType;
        private Type _editorType;
        private FilterOperandUIType _operandUIType;
        private Visibility _clearButtonVisibility;
        private Visibility _filterOperatorVisibility;
        private CellContentAlignment _cellContentAlignment;

        private bool _isPrinting;   // JJD 9/12/08 - added printing support
        private Field _field;       // JJD 9/21/08 - added printing support

        private int _hashCode;

        #endregion //Member Variables

        #region Constructor
        internal FilterCellElementKey(Field field)
        {
            FieldLayout fl = field.Owner;

            Debug.Assert(fl != null);

            bool isUsingCellPresenters = null != fl && fl.UseCellPresenters;

            _cellValuePresenterStyle = field.GetFieldSettingsStyleResolved(FieldSettings.FilterCellValuePresenterStyleProperty);

            if (isUsingCellPresenters)
                _cellPresenterStyle = field.CellPresenterStyleResolved;

            _editorStyle = field.GetFieldSettingsStyleResolved(FieldSettings.FilterCellEditorStyleProperty);
            _clearButtonVisibility = field.FilterClearButtonVisibilityResolved;
            _operandUIType = field.FilterOperandUITypeResolved;
            _editorType = field.FilterEditorTypeResolved;
            _editAsType = field.FilterEditAsTypeResolved;
            _filterOperatorVisibility = field.FilterOperatorVisibilityResolved;
            _cellContentAlignment = field.CellContentAlignmentResolved;

            _isPrinting = fl.DataPresenter.IsReportControl;
            _field = field;

            if (_isPrinting)
                return;

            _hashCode = _operandUIType.GetHashCode();

            if (null != _editorType)
                _hashCode += _editorType.GetHashCode();

            if (null != _editAsType)
                _hashCode += _editAsType.GetHashCode();
        }
        #endregion //Constructor

        #region Base class overrides

        public override bool Equals(object obj)
        {
            FilterCellElementKey key = obj as FilterCellElementKey;

            return this.Equals(key);
        }

        public override int GetHashCode()
        {
            // JJD 9/12/08
            // Added printing support
            // When we are printing we need to compare the fields themselves so use the field's hashcode
            if (this._isPrinting)
                return _field.GetHashCode();

            return this._hashCode;
        }

        public override string ToString()
        {
            return _field.ToString();
        }
        #endregion //Base class overrides

        #region IEquatable<FilterCellElementKey> Members

        public bool Equals(FilterCellElementKey key)
        {
            if (key == null)
                return false;

            // JJD 9/21/08
            // Added printing support
            // When we are printing we need to compare the fields themselves 
            if (_isPrinting)
                return _field == key._field;

            return _cellPresenterStyle == key._cellPresenterStyle
                && _cellValuePresenterStyle == key._cellValuePresenterStyle
                && _editorStyle == key._editorStyle
                && _editAsType == key._editAsType
                && _editorType == key._editorType
                && _operandUIType == key._operandUIType
                && _clearButtonVisibility == key._clearButtonVisibility
                && _filterOperatorVisibility == key._filterOperatorVisibility
                && _cellContentAlignment == key._cellContentAlignment
                ;
        }

        #endregion //IEquatable<FilterCellElementKey> Members
    } 
    #endregion //FilterCellElementKey

    #region LabelElementKey
    // AS 1/23/09 NA 2009 Vol 1 - Fixed Fields
    // Optimization - use the following element in a caching infrastructure
    // on the templatedatarecordcache similar to how we do that with cell(value)
    // presenters.
    //
    internal class LabelElementKey : IEquatable<LabelElementKey>
    {
        #region Member Variables

		// AS 7/7/09 TFS19145
		// See CellElementKey ctor.
		//
		//double _labelHeight;
        //double _labelWidth;
        Style _labelPresenterStyle;
		// AS 10/21/10 TFS26331
		// This flag was essentially used to determine if the field was
		// used as the key/hashcode/equals so changed the name since now 
		// we have another case where this is needed. Namely when we are 
		// using cell presenters and the label has wrapping on.
		//
        //bool _isPrinting;
		bool _useFieldAsKey;
		Field _field;
        int _lineCount;

        int _hashCode;

		// AS 7/9/09 TFS19237
		// We need to consider the cell contentalignment as part of the 
		// key since some labels may show a label and others may not.
		//
		private CellContentAlignment _cellContentAlignment;

        #endregion //Member Variables

        #region Constructor
        internal LabelElementKey(Field field)
        {
            FieldLayout fl = field.Owner;

            Debug.Assert(fl != null);

			// AS 7/7/09 TFS19145
			// See CellElementKey ctor.
			//
			//_labelHeight = field.GetLabelHeightResolvedHelper(false, false);
            //_labelWidth = field.GetLabelWidthResolvedHelper(false, false);
            _labelPresenterStyle = field.GetFieldSettingsStyleResolved(FieldSettings.LabelPresenterStyleProperty);
            _lineCount = field.LabelLineCount;

			// AS 7/9/09 TFS19237
			_cellContentAlignment = field.CellContentAlignmentResolved;

            // JJD 9/12/08
            // Added printing support.
            // In printing we don't need to calc a hash code since we are using the the field's hashcode instead
            _useFieldAsKey = fl.DataPresenter.IsReportControl;

			// AS 10/21/10 TFS26331
			if (fl.UseCellPresenters && field.LabelTextWrappingResolved != TextWrapping.NoWrap)
				_useFieldAsKey = true;

            if (this._useFieldAsKey)
            {
                this._field = field;
                return;
            }

			// AS 7/7/09 TFS19145
			// See CellElementKey ctor.
			//
			//if (!double.IsNaN(_labelHeight))
            //    _hashCode += _labelHeight.GetHashCode() / 10;
			//
            //if (!double.IsNaN(_labelWidth))
            //    _hashCode += _labelWidth.GetHashCode() / 10;

			// AS 7/9/09 TFS19237
			// It seems we never used to account for the line count and labelpresenter style
			// in the hashcode and now the new _cellContentAlignment as well.
			//
			_hashCode = _lineCount.GetHashCode();
			_hashCode += _labelPresenterStyle != null ? _labelPresenterStyle.GetHashCode() : 0;
			_hashCode += _cellContentAlignment.GetHashCode();
        }
        #endregion //Constructor

        #region Base class overrides
        public override int GetHashCode()
        {
            if (_useFieldAsKey)
                return _field.GetHashCode();

            return _hashCode;
        }

        public override bool Equals(object obj)
        {
            return obj is LabelElementKey && this.Equals((LabelElementKey)obj);
        }
        #endregion //Base class overrides

        #region IEquatable<LabelElementKey> Members

        public bool Equals(LabelElementKey other)
        {
            if (other == null)
                return false;

            // JJD 9/21/08
            // Added printing support
            // When we are printing we need to compare the fields themselves 
            if (_useFieldAsKey)
                return _field == other._field;

            return null != other &&
				// AS 7/7/09 TFS19145
				// See CellElementKey ctor.
				//
				//other._labelHeight.Equals(_labelHeight) &&
                //other._labelWidth.Equals(_labelWidth) &&
                other._labelPresenterStyle == _labelPresenterStyle &&
                other._lineCount == _lineCount

				// AS 7/9/09 TFS19237
				&& other._cellContentAlignment == _cellContentAlignment

                ;
        }

        #endregion
    } 
    #endregion //LabelElementKey

	#region FieldPosition Struct

	// SSP 1/6/09 TFS11860
	// Added FieldPosition structure.
	// 
	/// <summary>
	/// Data structure used by the Field's <see cref="Field.ActualPosition"/> property.
	/// </summary>
	/// <seealso cref="Field.ActualPosition"/>
	public struct FieldPosition
	{
		#region Members

		private int _column, _row, _columnSpan, _rowSpan;

		#endregion // Members

		#region Constructor

		/// <summary>
		/// Constructor. Initializes a new instance of <see cref="FieldPosition"/>.
		/// </summary>
		/// <param name="column"></param>
		/// <param name="row"></param>
		/// <param name="columnSpan"></param>
		/// <param name="rowSpan"></param>
		public FieldPosition( int column, int row, int columnSpan, int rowSpan )
		{
			_column = column;
			_row = row;
			// JM 05-04-10 TFS24462
			//_columnSpan = columnSpan;
			//_rowSpan = rowSpan;
			_columnSpan = columnSpan > 0 ? columnSpan : 1;
			_rowSpan = rowSpan > 0 ? rowSpan : 1;
		}

		#endregion // Constructor

		#region Properties

		#region Public Properties

		#region Row

		/// <summary>
		/// Logical row in the field layout that the field appears.
		/// </summary>
		public int Row
		{
			get
			{
				return _row;
			}
		}

		#endregion // Row

		#region Column

		/// <summary>
		/// Logical column in the field layout that the field appears.
		/// </summary>
		public int Column
		{
			get
			{
				return _column;
			}
		}

		#endregion // Column

		#region RowSpan

		/// <summary>
		/// Logical row span in the field layout that the field occupies.
		/// </summary>
		public int RowSpan
		{
			get
			{
				return _rowSpan;
			}
		}

		#endregion // RowSpan

		#region ColumnSpan

		/// <summary>
		/// Logical column span in the field layout that the field occupies.
		/// </summary>
		public int ColumnSpan
		{
			get
			{
				return _columnSpan;
			}
		}

		#endregion // ColumnSpan

		#endregion // Public Properties

		#endregion // Properties

        #region Methods

        #region Contains
        internal bool Contains(int row, int col)
        {
            if (_columnSpan > 0 && _rowSpan > 0)
            {
                return (_row <= row && row < _row + _rowSpan) &&
                    (_column <= col && col < _column + _columnSpan);
            }

            return false;
        }
        #endregion //Contains

		#region CreateHelper

		// SSP 5/2/11 TFS32038
		// 
		internal static FieldPosition CreateHelper( int col, int row, int colSpan, int rowSpan )
		{
			FieldPosition pos = new FieldPosition( );
			pos._column = col;
			pos._row = row;
			pos._columnSpan = colSpan;
			pos._rowSpan = rowSpan;

			return pos;
		} 

		#endregion // CreateHelper

        #endregion //Methods
	}

	#endregion // FieldPosition Struct

	// AS 7/30/09 NA 2009.2 Field Sizing
	#region FieldSize
	internal struct FieldSize : IEquatable<FieldSize>
	{
		#region Member Variables

		public double Value;
		public ItemSizeType Type;

		#endregion //Member Variables

		#region Constructors
		public FieldSize(double value)
			: this(value, ItemSizeType.Explicit)
		{
		}

		public FieldSize(double value, ItemSizeType type)
		{
			this.Value = value;
			this.Type = type;
		} 
		#endregion //Constructors

		#region Base class overrides
		public override int GetHashCode()
		{
			return this.Value.GetHashCode() | this.Type.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj is FieldSize)
				return this.Equals((FieldSize)obj);

			return false;
		}

		public override string ToString()
		{
			return string.Format("{0}: {1}", this.Type, this.Value);
		}
		#endregion //Base class overrides

		#region Properties
		public bool HasAutoModeSize
		{
			get { return this.Type == ItemSizeType.AutoMode && !double.IsNaN(this.Value); }
		}

		public bool HasExplicitSize
		{
			get { return this.Type != ItemSizeType.AutoMode && !double.IsNaN(this.Value); }
		}

		public bool IsAuto
		{
			get { return this.Type == ItemSizeType.AutoMode || this.Type == ItemSizeType.ExplicitAutoSize; }
		}

		public static FieldSize Empty
		{
			get { return new FieldSize(double.NaN); }
		}
		#endregion //Properties

		#region IEquatable<FieldSize> Members

		public bool Equals(FieldSize other)
		{
			return this.Type == other.Type &&
				this.Value.Equals(other.Value);
		}

		#endregion //IEquatable<FieldSize> Members
	} 
	#endregion //FieldSize
}

#region Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved
/* ---------------------------------------------------------------------*
*                           Infragistics, Inc.                          *
*              Copyright (c) 2001-2012 All Rights reserved               *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* THE SOURCE CODE CONTAINED HEREIN AND IN RELATED FILES IS PROVIDED     *
* TO THE REGISTERED DEVELOPER FOR THE PURPOSES OF EDUCATION AND         *
* TROUBLESHOOTING. UNDER NO CIRCUMSTANCES MAY ANY PORTION OF THE SOURCE *
* CODE BE DISTRIBUTED, DISCLOSED OR OTHERWISE MADE AVAILABLE TO ANY     *
* THIRD PARTY WITHOUT THE EXPRESS WRITTEN CONSENT OF INFRAGISTICS, INC. *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY INFRAGISTICS PRODUCT.    *
*                                                                       *
* THE REGISTERED DEVELOPER ACKNOWLEDGES THAT THIS SOURCE CODE           *
* CONTAINS VALUABLE AND PROPRIETARY TRADE SECRETS OF INFRAGISTICS,      *
* INC.  THE REGISTERED DEVELOPER AGREES TO EXPEND EVERY EFFORT TO       *
* INSURE ITS CONFIDENTIALITY.                                           *
*                                                                       *
* THE END USER LICENSE AGREEMENT (EULA) ACCOMPANYING THE PRODUCT        *
* PERMITS THE REGISTERED DEVELOPER TO REDISTRIBUTE THE PRODUCT IN       *
* EXECUTABLE FORM ONLY IN SUPPORT OF APPLICATIONS WRITTEN USING         *
* THE PRODUCT.  IT DOES NOT PROVIDE ANY RIGHTS REGARDING THE            *
* SOURCE CODE CONTAINED HEREIN.                                         *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* --------------------------------------------------------------------- *
*/
#endregion Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved