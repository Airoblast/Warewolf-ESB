#region using ...

using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Documents;
using System.Windows.Shapes;
using System.Windows.Navigation;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Automation;
using System.Windows.Automation.Provider;
using System.Windows.Threading;
using System.Diagnostics;
//using System.Windows.Events;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ComponentModel.Design.Serialization;
using System.Globalization;
using System.Reflection;
using System.Data;
using System.Xml;
using System.Windows.Markup;
//using Infragistics.Windows.Input;
using Infragistics.Shared;
using Infragistics.Windows.DataPresenter;
using Infragistics.Windows.Themes;
using Infragistics.Windows.Helpers;
using Infragistics.Windows.Resizing;
using Infragistics.Windows.Selection;
using Infragistics.Windows.Commands;
using Infragistics.Windows.Internal;
using Infragistics.Windows.Editors;
using Infragistics.Windows.Controls;
using Infragistics.Windows.DataPresenter.Events;
using Infragistics.Windows.Licensing;
using System.Windows.Automation.Peers;
using Infragistics.Windows.Automation.Peers.DataPresenter;
using System.Text;
using Infragistics.Windows.Controls.Events;
using Infragistics.Windows.Scrolling;
using Infragistics.Windows.Virtualization;
using System.Threading;
using System.Windows.Xps.Packaging;
using Infragistics.Windows;
using System.IO.Packaging;
using System.IO;
using System.Windows.Xps;
using Infragistics.Windows.Reporting;
using Infragistics.Controls.Layouts.Primitives;
using Infragistics.Windows.DataPresenter.Internal;
using Infragistics.Windows.Tiles;
using Infragistics.Collections;
using Infragistics.AutomationPeers;

using Infragistics.Windows.DataPresenter.Calculations;
using Infragistics.Controls;


#endregion //using ...

namespace Infragistics.Windows.DataPresenter
{
	/// <summary>
	/// Base class for the <see cref="XamDataGrid"/>, <see cref="XamDataCarousel"/> and <see cref="XamDataPresenter"/> controls.
	/// </summary>
	/// <remarks>
	/// <para class="body">The look of these controls can be easily changed by setting the <see cref="Theme"/> property. In addition, several styling points are exposed to allow fine grained control of the UI. Styles keyed by these types can be placed anywhere in the resource chain or can be specified directly through the control's object model via the properties described in the following list.
	/// <ul>
	/// <li><see cref="CellPresenter"/> is only used when labels are included with the <see cref="Cell"/>s (see <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.LabelLocation"/>). Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.CellPresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.CellPresenterStyleSelector"/> properties.</li>
	/// <li><see cref="CellValuePresenter"/> is used to represent a <see cref="Cell"/>'s value. Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.CellValuePresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.CellValuePresenterStyleSelector"/> properties.</li>
	/// <li><see cref="DataRecordCellArea"/> is used to represent a <see cref="DataRecord"/>'s cell area. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.DataRecordCellAreaStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.DataRecordCellAreaStyleSelector"/> properties.</li>
	/// <li><see cref="DataRecordPresenter"/> is used to represent a <see cref="DataRecord"/>. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.DataRecordPresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.DataRecordPresenterStyleSelector"/> properties.</li>
	/// <li><see cref="ExpandableFieldRecordPresenter"/> is used to represent a <see cref="ExpandableFieldRecord"/>. Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.ExpandableFieldRecordPresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.ExpandableFieldRecordPresenterStyleSelector"/> properties.</li>
	/// <li><see cref="ExpandedCellPresenter"/> is used to represent a <see cref="Cell"/>'s value where its associated <see cref="Field"/>'s <see cref="Field.DataType"/> does not implement the <see cref="System.Collections.IEnumerable"/> interface and its <see cref="Field.IsExpandable"/> property is set to true. Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.ExpandedCellStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.ExpandedCellStyleSelector"/> properties.</li>
    /// <li><see cref="FixedFieldButton"/> is used within a <see cref="LabelPresenter"/> to fix a <see cref="Field"/> to the near or far edge of the display. (see <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowFixing"/> and <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FixedFieldUIType"/> properties).</li>
    /// <li><see cref="FixedRecordButton"/> is used within a <see cref="RecordSelector"/> to fix a <see cref="Record"/> to the top or bottom of the list. (see <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/> and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FixedRecordUIType"/> properties)</li>
    /// <li><see cref="GroupByRecordPresenter"/> is used to represent a <see cref="GroupByRecord"/>. Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByRecordPresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByRecordPresenterStyleSelector"/> properties.</li>
    /// <li><see cref="GroupByArea"/> is used to represent an area at the top or bottom of the control (based on the <see cref="GroupByAreaLocation"/> property used for grouping <see cref="Field"/>s when the <see cref="GroupByAreaMode"/> property is set to <b>DefaultFieldLayoutOnly</b>.</li>
	/// <li><see cref="GroupByAreaFieldLabel"/> is used to represent a <see cref="Field"/> in the <see cref="GroupByArea"/>. Styles for this type can be specified through the <see cref="GroupByAreaFieldLabelStyle"/> and <see cref="GroupByAreaFieldLabelStyleSelector"/> properties.</li>
	/// <li><see cref="GroupByAreaFieldListBox"/> contains the <see cref="GroupByAreaFieldLabel"/>s in the <see cref="GroupByArea"/>. Styles for this type can only be specified in the resource chain.</li>
    /// <li><see cref="GroupByAreaMulti"/> is used to represent an area at the top or bottom of the control (based on the <see cref="GroupByAreaLocation"/> property used for grouping <see cref="Field"/>s when the <see cref="GroupByAreaMode"/> property is set to <b>MultipleFieldLayoutsFull</b> or <b>MultipleFieldLayoutsCompact</b>.</li>
	/// <li><see cref="HeaderPresenter"/> is only used when labels are in a separate header (see <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.LabelLocation"/>) and is not supported by <see cref="XamDataCarousel"/> or <see cref="XamDataPresenter"/> with a <see cref="XamDataPresenter.View"/> set to <see cref="CarouselView"/>. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.HeaderPresenterStyle"/> property.</li>
	/// <li><see cref="HeaderPrefixArea"/> is used within a <see cref="HeaderPresenter"/>. It represents the area analagous to record selectors in <see cref="DataRecordPresenter"/>s. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.HeaderPrefixAreaStyle"/> property.</li>
	/// <li><see cref="HeaderLabelArea"/> is used within a <see cref="HeaderPresenter"/>. It contains the <see cref="LabelPresenter"/>s for each <see cref="Field"/> and is analagous to the <see cref="DataRecordCellArea"/> in <see cref="DataRecordPresenter"/>s. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.HeaderLabelAreaStyle"/> property.</li>
	/// <li><see cref="LabelPresenter"/> is used to represent a <see cref="Field"/>'s <see cref="Field.Label"/>. Labels are either with the cells or in a separate header based on the view and the <see cref="Cell"/>s (see <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.LabelLocation"/>). Styles for this type can be specified through the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelPresenterStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelPresenterStyleSelector"/> properties.</li>
	/// <li><see cref="RecordListControl"/>s are created internally to display <see cref="RecordPresenter"/>s. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.RecordListControlStyle"/> property.</li>
	/// <li><see cref="RecordScrollTip"/> is used while dragging the thumb if the <see cref="ScrollingMode"/> property is left to its default value of <b>DeferredWithScrollTips</b> but it is not supported in <see cref="CarouselView"/>. Styles for this type can only be specified in the resource chain.</li>
	/// <li><see cref="RecordSelector"/> is used within a <see cref="DataRecordPresenter"/> to display the record's selection and activation status. Styles for this type can be specified through the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.RecordSelectorStyle"/> or <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.RecordSelectorStyleSelector"/> properties.</li>
	/// </ul>
	/// </para>
	/// <para class="body">In addition there are styling points that are specific to <see cref="XamDataCarousel"/> and <see cref="XamDataPresenter"/> in <see cref="CarouselView"/>. They are:
	/// <ul>
	/// <li><see cref="CarouselBreadcrumbControl"/> is used when drilling down through hierarchical data. It contains <see cref="CarouselBreadcrumb"/>s representing the parent <see cref="Record"/> drill down path. Styles for this type can only be specified in the resource chain.</li>
	/// <li><see cref="CarouselBreadcrumb"/> is used when drilling down through hierarchical data. It represents a parent <see cref="Record"/> in the drill down path. Styles for this type can only be specified in the resource chain.</li>
	/// <li><see cref="CarouselItem"/> wraps a <see cref="RecordPresenter"/>. Styles for this type can only be specified in the resource chain.</li>
	/// <li><see cref="CarouselPanelNavigator"/> displays buttons for navigating through the list of items.  Styles for this type can be specified through the <see cref="CarouselView"/>.<see cref="CarouselView.ViewSettings"/>.<see cref="CarouselViewSettings.CarouselPanelNavigatorStyle"/> property.</li>
	/// </ul>
	/// </para>
	/// <para></para>
	/// <para class="note"><b>Note: </b>An instance of a <see cref="Infragistics.Windows.Editors.ValueEditor"/> derived class is normally created and positioned inside 
	/// a <see cref="CellValuePresenter"/>'s visual tree within a <see cref="System.Windows.Controls.ContentPresenter"/> that has its name set to 'PART_EditorSite'. 
	/// The type of editor to use and its style can be specified via the <see cref="FieldSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldSettings.EditorType"/>, <see cref="Infragistics.Windows.DataPresenter.FieldSettings.EditAsType"/>, <see cref="Infragistics.Windows.DataPresenter.FieldSettings.EditorStyle"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.EditorStyleSelector"/> properties. These can also be specified on a cell by cell basis via the <see cref="Cell"/>'s <see cref="Cell.EditAsType"/>, <see cref="Cell.EditorType"/> and <see cref="Cell.EditorStyle"/> properties. These cell specific properties would normally be set from inside an <see cref="InitializeRecord"/> event handler.</para>
	/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how this control operates.</p>
	/// </remarks>
	/// <seealso cref="XamDataCarousel"/>
	/// <seealso cref="XamDataGrid"/>
	/// <seealso cref="XamDataPresenter"/>
	[ContentProperty("DataItems")]
	[TemplatePart(Name = "PART_ContentSiteGrid", Type = typeof(Grid))]
	
	//[ToolboxItem(false)]
	[StyleTypedProperty(Property = "GroupByAreaFieldLabelStyle", StyleTargetType = typeof(GroupByAreaFieldLabel))]	// AS 5/3/07
    
    
	
	[DesignTimeVisible(false)]	// JM 02-18-10 - DO NOT MOVE TO DESIGN ASSEMBLY!!!
	public abstract class DataPresenterBase : IGControlBase,
											  IResizeHost,
											  ISelectionHost,
											  ICommandHost,
											  IDeferredScrollHost,
		                                      IViewPanelInfo
											  // AS 6/16/09 NA 2009.2 Field Sizing
											  , IAutoResizeHost
											  // JJD 8/18/20 - TFS36399 - added IWeakEventListener
											  , IWeakEventListener

											 // JJD 03/08/12 - TFS101199 - Added touch support
											  , ISupportScrollHelper


                                              , IEmbeddedVisualPaginatorFactory

	{
		#region Private Members

		private ResizeController _resizeController;
		private SelectedItemHolder _selectedItems;
		private Grid _contentSiteGrid;
		private Grid _dataAreaGrid;
		private FrameworkElement _contentSiteDataAreaContent;
		private ItemsPanelTemplate _itemsPanel;
        // JJD 12/12/07 - BR28988
        // Removed ItemsControl wrapper since installing 3.5 version of the framework introduced
        // an error in the CollectionView implementation that brought down the app with
        // a FataExecutionEngineError that was untrappable. This happened when calling
        // EndEdit on a DataView data source after calling AddNew.
		//private ItemsControl _dataSourceWrapper;

        // JJD 12/14/07
        // Added member to keep track of changes to root list 
        private IEnumerable _dataSourceRootList;

        // JJD 12/14/07
        // Added collection of wrappers to bind to if datasource contains a list of lists
        private ObservableCollection<EnumerableObjectWrapper> _dataSourceRootChildListWrappers;

        // JJD 12/14/07
        // Added member to llisten for changes from the root list 
        private DataSourceRootListChangeListener _dataSourceRootListChangeListener;

		private RecordListControl _rootRecordListControl;
		private RecordListControl _currentRecordListControl;

        // JJD 11/21/08 - TFS6743/BR35763 
        // We don't need the _addChildCacheItemsControl to wrap our DataItems
        // we are now binding to that colleciton directly when the DataSource 
        // property is not set
        //private ItemsControl _addChildCacheItemsControl;

		private RecordManager _recordManager;
        // JJD 11/21/08 - TFS6743/BR35763 
        // allow any object as a logical child
        //internal void InternalAddLogicalChild(IFrameworkInputElement child)
        //private List<IFrameworkInputElement> _logicalChildren = new List<IFrameworkInputElement>();
        private List<object> _logicalChildren = new List<object>();
		private DataItemsCollection _dataItems;

		private FieldLayoutCollection _fieldLayouts;
		private FieldLayout _defaultLayout;
		private Record _activeRecord;
		private Cell _activeCell;
		private Record _pivotRecord;
		private Field _pivotField;
		private Cell _pivotCell;

		// AS 7/27/09 NA 2009.2 Field Sizing
		//private CellValuePresenter _cellValuePresenterInEditMode;
		private EditModeHelper _editHelper;

		private Nullable<Point> _selectionPoint;
		private bool _snaking;
		private SelectedItemHolder _selectionSnapshot;
		private ISelectionStrategyFilter _selectionStrategyFilter;
		private StyleSelector _internalCellPresenterStyleSelector;
		private StyleSelector _internalCellValuePresenterStyleSelector;
		private StyleSelector _internalEditorStyleSelector;
		private StyleSelector _internalExpandedCellStyleSelector;
		private StyleSelector _internalLabelPresenterStyleSelector;
		private StyleSelector _internalHeaderPresenterStyleSelector;
		private StyleSelector _internalHeaderPrefixAreaStyleSelector;
		private StyleSelector _internalHeaderLabelAreaStyleSelector;
		private StyleSelector _internalRecordStyleSelector;
		private StyleSelector _internalRecordCellAreaStyleSelector;
		private StyleSelector _internalRecordSelectorStyleSelector;
		// AS 6/1/07 BR22770
		//private ResourceDictionary _styleCache;
		private DispatcherOperation _postRecordsInViewChangedOperation;

		// JJD 10/18/10 - TFS30715
		private DispatcherOperation _bumpScrollCountOperation;
		

		// JJD 03/08/12 - TFS101199 - Added touch support for scrolling
		internal TouchScrollHelper _scrollHelper;
		private double? _cachedHorizValue;
		private double? _cachedVertValue;
		
		// JJD 04/03/12 - TFS107578
		private double _previousFirstItemWidth = DEFAULT_RECORD_HEIGHT;
		private double _previousFirstItemHeight = DEFAULT_RECORD_HEIGHT;


		private bool _clearingActiveCell;
		private bool _dataSourceHasBeenCleared;
		private int _groupbyVersion;
		private int _renderVersion;

		// JM 09-26-07 BR26775 - no longer needed since the property that this supports has been changed to a DependencyProperty.
		//private int _scrollableRowCountVersion;

		// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
		// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
		// calculating scroll count.
		// 
		//private int _overallScrollCount;
		private int _cachedOverallScrollCount;
		internal bool _cachedOverallScrollCountDirty = true;

		private int _overallScrollPosition;

		// JJD 3/15/11 - TFS65143 - Optimization
		// Instead of having every element wire LayoutUpdated we can maintain a list of pending callbacks
		// and just wire LayoutUpdated on the DP
		private HashSet _layoutUpdatedCallbacks;

		private GroupByArea _groupByArea;

        // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
		private GroupByAreaMulti _groupByAreaMulti;

		private ViewBase _currentViewInternal = null;

        // AS 1/27/09
        // Optimization - only have 1 parameterless void delegate class defined.
        //
        //delegate void MethodDelegate();

		// JM 08-01-07 BR25314
		private bool	_forceClearActiveRecord;

        // JJD 1/10/08 - BR29572
        // added flag to keep track of whether we have initialized the RM's DataSource property
        private bool _isRecordManagerDataSourceInitialized;

        // JJD 1/14/08 
        // Handle receiving change notifications on other threads
        private DispatcherOperation _asyncChangePending;

        // JJD 7/21/08 - BR34098 - Optimization - added
        private bool _invalidateGeneratedStylesPending;

        // JJD 7/21/08 - BR34098 - Optimization - added
        private bool _haveAnyTemplatesBeenGenerated;

		// JM 04/09 CrossBandGrouping feature
		// Changed this to a DP so no longer need member variable
		//// JJD 2/19/09 - TFS13979
		//// Maintain an overall sort version that gets bumped whenever
		//// a sorting change is made on any field layout
		//private int _overallSortVersion;

        // JJD 3/5/08 - added support for Converter properies on Field
        private CultureInfo _defaultConverterCulture;

        // JJD 3/16/09 - Optimization
        // Maintain a queue of record presenters that are waiting to
        // have their nested content initailiazed
        private Queue<RecordPresenter> _recordsPendingNestedContentInitialization;

		// JM 08-04-08 Load/Save Customizations
		private CustomizationsManager	_customizationsManager;
		private bool					_isLoadingCustomizations;

        // JJD 12/21/09 - TFS25835 
        // The _nonRootCurrencyTrackingManagers contains the non-root rcd managers that
        // are wired into their respective collectionView's CurrentChanging/Changed events
        private WeakList<RecordManager> _nonRootCurrencyTrackingManagers;


		
		
		private FieldDragManager _fieldDragManager;


		// AS 3/23/10 TFS23753
		private MouseButtonEventArgs _previewMouseDownArgs;

		// SSP 1/7/09 - NAS9.1 Record Filtering
		// 
		internal Record _activeRecordWithPendingDirtyFilterState;

        // JJD 7/14/09 - TFS18784 - added
        private ISelectableItem _itemPendingScrollItemIntoView;
        private bool _bypassScrollIntoView;

		// SSP 3/3/09 TFS11407
		// 
		private Record _initializeRecordSuspendedFor = null;
		private List<Record> _initializeRecordSuspendedFor_List = null;
        
        // JJD 11/11/09 - TFS24665 - added
        private RecordPresenter _pendingActiveRecordPresenter;

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        private DataPresenterHistory _history;
        private ClipboardOperationInfo _clipboardOperationInfo;

		// AS 5/29/09 NA 2009.2 Undo/Redo
		private bool _initialResizeIsPending;

		// SSP 6/24/09 - NAS9.2 Field Chooser
		// 
		private ToolWindow _retainedFieldChooserWindow;
		internal WeakList<FieldChooser> _registeredFieldChoosers;

		// AS 6/26/09 NA 2009.2 Field Sizing
		private int _endEditOnScrollSuspendCount;				// counter used to suspend exiting edit mode on IsOkToScroll
		private List<FieldLayout> _fieldLayoutsAutoSizePending;	// list of field layouts with pending operations
		private int _fieldLayoutAutoSizeViewableCount;			// # of fields layouts with autosized field scoped to viewablerecords
		private int _fieldLayoutAutoSizeAllRecordsCount;		// # of fields layouts with autosized field scoped to all records
		private int _allRecordsAutoSizeMaxDepth = -1;			// deepest recordmanager depth of a field layout that has autosized fields scoped to all records
		private DispatcherOperation _pendingFieldAutoSize;		// dispatcher used to asynchronously process field layout auto size operations
		private bool _processingFieldAutoSize;					// flag used to track when we are processing auto size operations

		// AS 2/26/10 TFS28159
		private int _fieldLayoutAutoSizeRecordsInViewCount;		// # of fields layouts with autosized field scoped to records in view

        // MBS 7/24/09 - NA9.2 Excel Exporting
        private bool _isExporting;
        private bool _suppressExportingDataSourceException;

		// SSP 8/4/09 - NAS9.2 Enhanced grid view
		// Added _scrollCountRecalcVersion version number. Needed a way to cause all the record
		// collections to recalc the scroll counts.
		// 
		internal int _cachedScrollCountRecalcVersion;

		// SSP 2/1/10
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 
		internal List<VisibleDataBlock.VisibleDataBlockCache> _lastVisibleDataBlocks;
		private EventHandler<CellsInViewChangedEventArgs> _cellsInViewChangedEventHandler;
		internal bool _pendingRaiseCellsInViewChangedAsyncHelperHandler;

		// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
		private AsyncPageCommand _asyncCommand;
		private bool _isInPageUpDown;
		private KeyDownInfo _lastKeyDownInfo;

		// MD 8/20/10
		// We don't need the CVPCache anymore. We can get similar gains by caching the cell panel on the data record presenter.
		//// SSP 6/7/10 - Optimizations - TFS34031
		//// 
		//internal CVPCache _cvpCache;

		// MD 7/16/10 - TFS26592
		private SuppressedEventsCollection _suppressedEvents;

		// SSP 12/22/11 TFS67264 - Optimizations
		// This is used to check if we need to raise certain events.
		// 
		/// <summary>
		/// Indicates if the class type of the instance is not XamDataPresenter or XamDataGrid.
		/// </summary>
		internal readonly bool _isDerived;

		// SSP 12/22/11 TFS67264 - Optimizations
		// This is used to check if we need to raise certain events.
		// 
		internal bool? _cachedInitializeRecordEventSuppressed;

		// JJD 3/16/09 - Optimization
		private double _lastScrollDimensionExtent;

		private bool _cachedIsUndoEnabled; // AS 1/12/11 TFS59619

		private FixedAreaScrollHelper _fixedScrollHelper; // AS 4/12/11 TFS62951

		// AS 3/3/11 NA 2011.1 - Async Exporting
		private ExportHelper _exportHelper;

		internal Record _recordWhoseChangesAreBeingDiscarded;	// JM 10-10-11 TFS91236
		
		// JJD 04/13/12 - TFS108986 - Optimization
		// After a scroll operation we want to suspend summary calculations for a short period
		// of time (based on how many records have been scrolled) to avoid costly summary
		// calculation overhead in continuous scroll operations.
		internal DispatcherTimer _isScrollingTimer;	

		// AS 11/14/11 TFS91077
		private Size _lastMeasureSize;

		// JJD 3/23/12 - Metro theme support
		// Added properties to supply default RecordSelectorExtents from within a theme's style
		private double _cachedRecordSelectorExtent = double.NaN;
		private double _cachedRecordSelectorFixButtonExtent = double.NaN;
		private double _cachedRecordSelectorErrorIconExtent = double.NaN;

		#endregion //Private Members

		#region Static fields

		#endregion //Static fields

		#region Constants

		private const int ExpandRecordAnimationDuration = 1000;
		private const int CollapseRecordAnimationDuration = 700;

		// JJD 03/08/12 - TFS101199 - Added touch support

		private const double DEFAULT_RECORD_HEIGHT = 20;


		#endregion //Constants

		#region Constructors

		static DataPresenterBase()
		{
			// AS 5/9/08
			// register the groupings that should be applied when the theme property is changed
			ThemeManager.RegisterGroupings(typeof(DataPresenterBase), new string[] { PrimitivesGeneric.Location.Grouping, EditorsGeneric.Location.Grouping, DataPresenterGeneric.Location.Grouping });

			////			KeyboardNavigation.DirectionalNavigationProperty.OverrideMetadata(typeof(DataPresenterBase), new FrameworkPropertyMetadata(KeyboardNavigationMode.Cycle));


			//// Load our commands.  (Since our commands are defined as statics and static initializers are not called
			//// until the class is accessed, call the convenience method 'LoadCommands' which will access the class
			//// and force the loading of our static commands and register command bindings)
			//DataPresenterCommands.LoadCommands();
			KeyboardNavigation.ControlTabNavigationProperty.OverrideMetadata(typeof(DataPresenterBase), new FrameworkPropertyMetadata(KeyboardNavigationMode.None));
			KeyboardNavigation.DirectionalNavigationProperty.OverrideMetadata(typeof(DataPresenterBase), new FrameworkPropertyMetadata(KeyboardNavigationMode.None));
			KeyboardNavigation.TabNavigationProperty.OverrideMetadata(typeof(DataPresenterBase), new FrameworkPropertyMetadata(KeyboardNavigationMode.None));

			DeferredScrollService.RegisterDeferredScrollHost(typeof(DataPresenterBase));

			// hook the scroll changed event so we can dirty any virtualized records
			EventManager.RegisterClassHandler(typeof(DataPresenterBase), ScrollViewer.ScrollChangedEvent, new RoutedEventHandler(OnScrollViewerScrollChanged));

			// This will manage FocusWithinManager.IsFocusWithin property for this type.
			// 
			FocusWithinManager.RegisterType(typeof(DataPresenterBase));

			// AS 3/23/10 TFS23753
			EventManager.RegisterClassHandler(typeof(DataPresenterBase), FrameworkElement.RequestBringIntoViewEvent, new RequestBringIntoViewEventHandler(OnRequestBringIntoView));
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DataPresenterBase"/> class
		/// </summary>
		protected DataPresenterBase()
		{
			// SSP 12/22/11 TFS67264 - Optimizations
			// 
			_isDerived = typeof( XamDataGrid ) != this.GetType( ) && typeof( XamDataPresenter ) != this.GetType( );

			//FrameworkElement.FocusableProperty.OverrideMetadata(typeof(DataPresenterBase), new FrameworkPropertyMetadata((bool)false));
			//KeyboardNavigation.SetTabNavigation(this, KeyboardNavigationMode.None);
			//KeyboardNavigation.SetControlTabNavigation(this, KeyboardNavigationMode.None);
			//KeyboardNavigation.SetDirectionalNavigation(this, KeyboardNavigationMode.None);

			// JJD 5/16/07 
			// Since derived classes could override default values of any dependency property we
			// have to initialize the property cache variables to metadata default values.
			this._cachedAutoFit = (bool?)AutoFitProperty.GetMetadata(this).DefaultValue;
			this._cachedIsNestedDataDisplayEnabled = (bool)IsNestedDataDisplayEnabledProperty.GetMetadata(this).DefaultValue;
			this._cachedCellContainerGenerationMode = (CellContainerGenerationMode)CellContainerGenerationModeProperty.GetMetadata(this).DefaultValue;

			this._cachedIsUndoEnabled = (bool)this.GetValue(IsUndoEnabledProperty); // AS 1/12/11 TFS59619

			// MD 8/20/10
			// We don't need the CVPCache anymore. We can get similar gains by caching the cell panel on the data record presenter.
			//// SSP 6/7/10 - Optimizations - TFS34031
			//// 
			//_cvpCache = new CVPCache( this, new TimeSpan( 0, 0, 1 ), 100 );

			// JM BR31380 4-30-08
            this.Unloaded += new RoutedEventHandler(OnUnloaded);

            // JJD 5/6/09 - NA 2009 vol2 - Cross band grouping
            // Now tha we have made GroupByArea a writable property from a lazy create read-only property
            // we need to initialize the GroupByAreaProperty here.
            this.SetValue(GroupByAreaProperty, new GroupByArea(this));

			_fixedScrollHelper = new FixedAreaScrollHelper(this); // AS 1/18/11 TFS62951


			// JJD 03/08/12 - TFS101199 - Added touch support for scrolling
			this.SetCurrentValue(IsManipulationEnabledProperty, KnownBoxes.TrueBox);

			_scrollHelper = new TouchScrollHelper(this, this);

        }

		#endregion //Constructors

		#region Base class overrides

		#region Commands

		/// <summary>
		/// Gets the supported commands (read-only) 
		/// </summary>
		/// <value>A static instance of the <see cref="DataPresenterCommands"/> class.</value>
		/// <remarks>
		/// <p class="body">This class exposes properties that return all of the commands that the control understands. 
		/// </p>
		/// </remarks>
		internal protected override CommandsBase Commands
		{
			get { return DataPresenterCommands.Instance; }
		}

		#endregion //Commands

		#region MeasureOverride
		/// <summary>
		/// Invoked to measure the element and its children.
		/// </summary>
		/// <param name="constraint">The size that reflects the available size that this element can give to its children.</param>
		/// <returns>The <see cref="System.Windows.Size"/> that represents the desired size of the element.</returns>
		protected override Size MeasureOverride(Size constraint)
		{
			// AS 11/14/11 TFS91077
			if (constraint != _lastMeasureSize)
			{
				_lastMeasureSize = constraint;
				this.BumpGridMeasureVersion();
			}

			return base.MeasureOverride(constraint);
		}
		#endregion //MeasureOverride

		#region OnApplyTemplate

		/// <summary>
		/// Called when the template is applied
		/// </summary>
		public override void OnApplyTemplate()
		{
			base.OnApplyTemplate();

			this.VerifyContentSiteGrid();
		}

		#endregion //OnApplyTemplate

		#region OnCreateAutomationPeer
		/// <summary>
		/// Returns an automation peer that exposes the <see cref="DataPresenterBase"/> to UI Automation.
		/// </summary>
		/// <returns>A <see cref="Infragistics.Windows.Automation.Peers.DataPresenter.DataPresenterBaseAutomationPeer"/></returns>
		protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer()
		{
			return new DataPresenterBaseAutomationPeer(this);
		}
		#endregion //OnCreateAutomationPeer

		#region OnInitialized

		/// <summary>
		/// Called after the control has been initialized.
		/// </summary>
		protected override void OnInitialized(EventArgs e)
		{
            // JJD 5/6/09 - NA 2009 vol2 - Cross band grouping
            // Now that we have made GroupByArea a writable property from a lazy create read-only property
            // we need to make sure the groupbyarea created in the ctor is added to the logical tree
            if (this._groupByArea != null && this._groupByArea.Parent == null)
                this.InternalAddLogicalChild(this._groupByArea);

			base.OnInitialized(e);

            // JJD 12/21/07
            // Don't lazy create the settings objects at design time.
            // This will allow the VS2008 designer to work properly 
            if (!DesignerProperties.GetIsInDesignMode(this))
            {
                // JJD 01/05/10 - TFS25423
                // Instead of setting a local value for FieldLayoutSettings call coerceValue
                // which at runtime will always return a non-null value without stepping on
                // any settings supplied in a style
                //this.SetValue(FieldLayoutSettingsProperty, this.FieldLayoutSettings);
                //this.SetValue(FieldSettingsProperty, this.FieldSettings);
                this.CoerceValue(FieldLayoutSettingsProperty);
                this.CoerceValue(FieldSettingsProperty);
            }

			this.SetValue(ViewableRecordsPropertyKey, this.RecordManager.ViewableRecords);

            // JJD 12/08/08 - added IsSynchronizedWithCurrentItem property
            // Sync up with current item
            this.RecordManager.SetActiveRecordFromCurrentItem();

			// SSP 9/11/2011 Calc
			// 
			GridUtilities.NotifyCalcAdapter( this, this, "Initialized", null );
        }

		#endregion //OnInitialized

		#region LogicalChildren

		/// <summary>
		/// Returns an enumerator for the logical children of this control.
		/// </summary>
		protected override IEnumerator LogicalChildren
		{
			get { return this._logicalChildren.GetEnumerator(); }
		}

		#endregion //LogicalChildren

		// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
		#region OnKeyDown

		/// <summary>
		/// Called when the element has input focus and a key is pressed.
		/// </summary>
		/// <param name="e">An instance of KeyEventArgs that contains information about the key that was pressed.</param>
		protected override void OnKeyDown(KeyEventArgs e)
		{
			// JJD 3/1/11 - TFS66934 - Optimization 
			// Throttle pageup/down key messages that have been queued up 
			ModifierKeys modifiers = Keyboard.Modifiers;
			bool isInPageUpDown = (e.Key == Key.PageDown || e.Key == Key.PageUp || e.Key == Key.Down || e.Key == Key.Up);

			if (isInPageUpDown && 
				_lastKeyDownInfo != null &&
				_lastKeyDownInfo.Key == e.Key &&
				_lastKeyDownInfo.Modifiers == modifiers &&
				_lastKeyDownInfo.TickCount + 35 > Environment.TickCount)
			{
				e.Handled = true;
				return;
			}

			// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
			// Before calling the base set a flag so that we know we are in a pagedown or
			// pageup so we can defer calling UpdateLayout
			this._isInPageUpDown = isInPageUpDown;

			base.OnKeyDown(e);

			// reset the flag
			this._isInPageUpDown = false;

			// JJD 3/1/11 - TFS66934 - Optimization 
			// save the key info with a time stamp
			if (isInPageUpDown)
			{
				if (_lastKeyDownInfo == null)
					_lastKeyDownInfo = new KeyDownInfo(e.Key, modifiers);
				else
				{
					_lastKeyDownInfo.Key = e.Key;
					_lastKeyDownInfo.Modifiers = modifiers;
					_lastKeyDownInfo.TickCount = Environment.TickCount;
				}
			}
		}

		#endregion //OnKeyDown	

		// JJD 3/1/11 - TFS66934 - Optimization - added throttling logic to key down processing
		#region OnKeyUp

		/// <summary>
		/// Called when the element has input focus and a key is released.
		/// </summary>
		/// <param name="e">An instance of KeyEventArgs that contains information about the key that was pressed.</param>
		protected override void OnKeyUp(KeyEventArgs e)
		{
			_lastKeyDownInfo = null;
			base.OnKeyUp(e);
		}

		#endregion //OnKeyUp	
        
    
		#region OnLostMouseCapture

		
		
		/// <summary>
		/// Overridden. Called when mouse capture is lost.
		/// </summary>
		/// <param name="e">Associated event args.</param>
		protected override void OnLostMouseCapture( MouseEventArgs e )
		{
			base.OnLostMouseCapture( e );


			if ( null != _fieldDragManager )
			{
				// SSP 8/2/12 TFS118311
				// Enclosed the existing code into the if block. Apparently the selection strategy has logic
				// to release and recapture mouse when it auto-scrolls the control during drag operation.
				// This causes us to end the field dragging operation. Solution is to check 
				// IsReleasingMouseCapture property of the selection strategy which is temporarily set while
				// its releasing and recapturing the mouse.
				// 
				SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem( _fieldDragManager.DragField );
				if ( null == selectionStrategy || !selectionStrategy.IsReleasingMouseCapture )
				{
					_fieldDragManager.OnDragEnd( e, true );
				}

				// SSP 6/24/09 - NAS9.2 Field Chooser
				// Now the OnDragEnd call above manages the _fieldDragManager member var.
				// 
				//_fieldDragManager = null;
			}

		}

		#endregion // OnLostMouseCapture

		#region OnMouseMove

		
		
		/// <summary>
		/// Overridden. Called when mouse is moved.
		/// </summary>
		/// <param name="e">Associated mouse event args.</param>
		protected override void OnMouseMove( MouseEventArgs e )
		{
			base.OnMouseMove( e );


			if ( null != _fieldDragManager )
			{
				_fieldDragManager.OnMouseMove( e );
			}

		}

		#endregion // OnMouseMove

		#region OnMouseLeftButtonUp

		
		
		/// <summary>
		/// Overridden. Called when left mouse button is released.
		/// </summary>
		/// <param name="e">Mouse event args.</param>
		protected override void OnMouseLeftButtonUp( MouseButtonEventArgs e )
		{

			if ( null != _fieldDragManager )
			{
				_fieldDragManager.OnDragEnd( e, false );

				// SSP 6/24/09 - NAS9.2 Field Chooser
				// Now the OnDragEnd call above manages the _fieldDragManager member var.
				// 
				//_fieldDragManager = null;

				this.ReleaseMouseCapture( );
			}


			base.OnMouseLeftButtonUp( e );
		}

		#endregion // OnMouseLeftButtonUp

		// AS 3/23/10 TFS23753 - added
		#region OnPreviewMouseLeftButtonDown
		/// <summary>
		/// Invoked when the left mouse button is being pressed down within the element.
		/// </summary>
		/// <param name="e">Provides information about the preview mouse event being raised.</param>
		protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e)
		{
			// AS 3/23/10 TFS23753
			// Track the mouse event args so we can alter it if the grid (well the frameworkelement's 
			// base implemented in ongotfocus) makes a request to bring itself into view.
			//
			MouseButtonEventArgs oldArgs = _previewMouseDownArgs;
			_previewMouseDownArgs = e;
			try
			{
				base.OnPreviewMouseLeftButtonDown(e);
			}
			finally
			{
				_previewMouseDownArgs = oldArgs;
			}
		}
		#endregion //OnPreviewMouseLeftButtonDown

		#region OnRenderSizeChanged

		/// <summary>
		/// Called when the size has changed
		/// </summary>
		protected override void OnRenderSizeChanged(SizeChangedInfo info)
		{
			base.OnRenderSizeChanged(info);

			// bump the render version to notifiy any listeners
			this._renderVersion++;
			this.SetValue(RenderVersionPropertyKey, this._renderVersion);
		}

		#endregion //OnRenderSizeChanged

		#region OnPropertyChanged

		/// <summary>
		/// Called when a property has changed
		/// </summary>
		protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)
		{
			base.OnPropertyChanged(e);

			DependencyProperty property = e.Property;

			if (property == DataPresenterBase.SortRecordsByDataTypeProperty)
			{
				this.BumpSortVersion();
			}
            else if (property == DataPresenterBase.DataSourceProperty)
            {
                // JJD 12/14/07
                // set the internal property
                this.SetValue(DataSourceInternalPropertyKey, e.NewValue);
            }
            // JJD 12/14/07
            // Changed to do update logic on change of DataSourceInternal instead of DataSource
            // which allows us to refresh everything by ccoercing the DataSourceInternal property
            //else if (property == DataPresenterBase.DataSourceProperty)
            else if (property == DataPresenterBase.DataSourceInternalProperty)
            {
                // MBS 7/24/09 - NA9.2 Excel Exporting
                // We don't want to allow the user to assign the DataSource when we're in the middle of an exporting
                // operation, since we should be using the same data source as the original
                if (this.IsExporting && !this.SuppressExportingDataSourceException)
                    throw new InvalidOperationException(DataPresenterBase.GetString("LE_SetDataSourceDuringExport"));

                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set
                //if (e.NewValue != null &&
                    //this._addChildCacheItemsControl != null &&
                    //this._addChildCacheItemsControl.Items.Count > 0 &&
                    //e.NewValue != this._addChildCacheItemsControl.Items )
                if (e.NewValue != null &&
                    this._dataItems != null &&
                    this._dataItems.Count > 0 &&
                    // JJD 1/3/08 - BR29387
                    // Since we moved this logic into DataSourceInternal we need to
                    // account for the additem case where DataSourceInternal will
                    // be set to the _dataItems collection.
                    // So only throw the exception if it's not.
                    e.NewValue != this._dataItems )
                 {
                    throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_7"));
                }

                // [BR20825] 3/1/07
                FieldLayout oldDefaultFieldLayout = null;
                if (e.OldValue != null)
                {
                    // JJD 1/4/08 - BR25487
                    // We want to preserve the existing grouping criteria 
                    //this.ClearGroupBy();

                    oldDefaultFieldLayout = this.DefaultFieldLayout;

                    // JJD 5/8/07 - BR22677
                    // Make sure oldDefaultFieldLayout is not null
                    if (oldDefaultFieldLayout != null)
                        oldDefaultFieldLayout.IsDefault = false;

                    // JJD/21/07 - BR20239
                    // Set a flag so we know if the data source has been cleared
                    this._dataSourceHasBeenCleared = true;
                }

				// AS 5/12/09 NA 2009.2 Undo/Redo
				// We shouldn't be allowing undo/redo operations after the 
				// data source is changed. Not only would the records be different
				// but the field layouts may not be used in the new datasource.
				//
				this.ClearUndoHistory();

                // JJD 1/4/08 - BR25487
                // We want to preserve the existing grouping criteria 
                //this.ResetGroupBySettings();
                this.FieldLayouts.OnDataSourceChanged();

				// AS 8/5/09 NA 2009.2 Field Sizing
				// Reset the variable we use to track how many field layouts have autosized 
				// fields that traverse viewable records. This should be reset to 0 from the 
				// OnDataSourceChanged as each unregisters but just in case explicitly clear it.
				//
				Debug.Assert(_fieldLayoutAutoSizeViewableCount == 0);
				_fieldLayoutAutoSizeViewableCount = 0;

				// AS 8/6/09 NA 2009.2 Field Sizing
				_allRecordsAutoSizeMaxDepth = -1;
				this.ResetAllRecordsAutoSizeMaxDepth();

				// JJD 12/14/07
                // Now is called above in DataSource change
                // set the internal property
                //this.SetValue(DataSourceInternalPropertyKey, e.NewValue);

				#region Clear selection on data source change
				
				// JJD 04/19/12 - TFS104792
				// Moved logic to clear selection from below so that the clear happens before 
				// the call to InitializeRecordManagerDataSource. This covers a scenario
				// where a new record's IsSelected property is set to true inside the InitializeRecord
				// event.

				// AS 5/19/09 TFS17455
				// Whenever the data source changes, clear all the selected items.
				//
				if (e.OldValue != null)
				{
					// JJD 1/16/12 - TFS63720
					// Pass true in as new resetItemSelectionStates parameter
					//this.SelectedItems.InternalClearSelection(true, true, true);
					this.SelectedItems.InternalClearSelection(true, true, true, true);
				}

				#endregion //Clear selection on data source change	
    
                // initialize the datasource on the RecordManager 
                this.InitializeRecordManagerDataSource();

                // [BR20825] 3/1/07
                // JJD/21/07 - BR20239
                // Reset the default field layout if the datasource has been set to
                // a value after it has been cleared so we need to also perform this
                // logic if the _dataSourceHasBeenCleared flag was set.
                //if (oldDefaultFieldLayout != null && this.RecordManager.Unsorted.Count > 0)
                if (this._dataSourceHasBeenCleared == true && this.RecordManager.Unsorted.Count > 0)
                {
                    DataRecord record = this.RecordManager.Unsorted[0] as DataRecord;
                    if (record != null)
                        record.FieldLayout.IsDefault = true;

                    // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                    // use the BumpGroupByAreaStyleVersion method instead of the GroupByArea property
                    //this.GroupByArea.StyleVersionNumber++;
                    this.BumpGroupByAreaStyleVersion();
 
                    this._dataSourceHasBeenCleared = false;
                }

                if (this.DefaultFieldLayout != null)
                    this.OnProcessSortCriteria(this.DefaultFieldLayout);
            
                // JJD 12/14/07
                // Null out the collection of wrappers if we are no longer using them
                if (this._dataSourceRootChildListWrappers != null &&
                     e.NewValue != this._dataSourceRootChildListWrappers)
                    this._dataSourceRootChildListWrappers = null;

				// JJD 04/19/12 - TFS104792
				// Moved logic to clear selection above so that the clear happens before 
				// the call to InitializeRecordManagerDataSource. This covers a scenario
				// where a new record's IsSelected property is set to true inside the InitializeRecord
				// event.
				//// AS 5/19/09 TFS17455
				//// Whenever the data source changes, clear all the selected items.
				////
				//if (e.OldValue != null)
				//    // JJD 1/16/12 - TFS63720
				//    // Pass true in as new resetItemSelectionStates parameter
				//    //this.SelectedItems.InternalClearSelection(true, true, true);
				//    this.SelectedItems.InternalClearSelection(true, true, true, true);

				// JM 09-02-09 TFS21114
				// Whenever the data source changes, clear the ActiveRecord.
				//
				if (e.OldValue != null)
					this.ClearActiveRecord(true);
			}
            else if (property == DataPresenterBase.GroupByAreaLocationProperty)
            {
                this.VerifyGroupByAreaLocation();
            }
            else if (property == DataPresenterBase.GroupByAreaStyleProperty)
            {
                this.SetGroupByAreaStyle();
            }
            else if (property == DataPresenterBase.GroupByAreaFieldLabelStyleProperty ||
                     property == DataPresenterBase.GroupByAreaFieldLabelStyleSelectorProperty)
            {
                // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                // use the BumpGroupByAreaStyleVersion method instead of the GroupByArea property
                //this.GroupByArea.StyleVersionNumber++;
                this.BumpGroupByAreaStyleVersion();
            }
            else if (property == FieldSettingsProperty)
            {
                // unhook old event handler
				if (this._x_FieldSettings != null)
				{
					// JJD 8/18/20 - TFS36399 
					// Use PropertyChangedEventManager.RemoveListener instead 
					//this._x_FieldSettings.PropertyChanged -= new PropertyChangedEventHandler(this.OnFieldSettingsPropertyChanged);
					PropertyChangedEventManager.RemoveListener(this._x_FieldSettings, this, string.Empty);
				}

                this._x_FieldSettings = e.NewValue as FieldSettings;

                // hook into PropertyChanged event
				if (this._x_FieldSettings != null)
				{
					// JJD 8/18/20 - TFS36399 
					// Use PropertyChangedEventManager.AddListener instead so
					// we don't risk rooting the DP.
					//this._x_FieldSettings.PropertyChanged += new PropertyChangedEventHandler(this.OnFieldSettingsPropertyChanged);
					PropertyChangedEventManager.AddListener(this._x_FieldSettings, this, string.Empty);
				}

                // JJD 01/05/10 - TFS25423 
                // If the value has been cleared than call coerce since at runtime we want to always
                // reyurn a non-null value
                if (this._x_FieldSettings == null)
                    this.CoerceValue(FieldSettingsProperty);

                // JJD 7/21/08 - BR34098 - Optimization
                // Invalidate the generated styles asynchronously so that if alot of
                // changes are made in a tight loop that only one invalidation will take place
                //this.InvalidateGeneratedStyles(true, false);
                this.InvalidateGeneratedStylesAsync();
            }
            else if (property == FieldLayoutSettingsProperty)
            {
                // unhook old event handler
				if (this._x_FieldLayoutSettings != null)
				{
					// JJD 8/18/20 - TFS36399 
					// Use PropertyChangedEventManager.RemoveListener instead 
					//this._x_FieldLayoutSettings.PropertyChanged -= new PropertyChangedEventHandler(this.OnFieldLayoutSettingsPropertyChanged);
					PropertyChangedEventManager.RemoveListener(this._x_FieldLayoutSettings, this, string.Empty);
				}

                this._x_FieldLayoutSettings = e.NewValue as FieldLayoutSettings;

                // hook into PropertyChanged event
				if (this._x_FieldLayoutSettings != null)
				{
					// JJD 8/18/20 - TFS36399 
					// Use PropertyChangedEventManager.AddListener instead so
					// we don't risk rooting the DP.
					//this._x_FieldLayoutSettings.PropertyChanged += new PropertyChangedEventHandler(this.OnFieldLayoutSettingsPropertyChanged);
					PropertyChangedEventManager.AddListener(this._x_FieldLayoutSettings, this, string.Empty);
				}

                // JJD 01/05/10 - TFS25423 
                // If the value has been cleared than call coerce since at runtime we want to always
                // reyurn a non-null value
                if (this._x_FieldLayoutSettings == null)
                    this.CoerceValue(FieldLayoutSettingsProperty);

                // SSP 7/17/07 BR22919
                // Don't clear the group-by fields.
                // 
                //this.InvalidateGeneratedStyles(true, true);

                // JJD 7/21/08 - BR34098 - Optimization
                // Invalidate the generated styles asynchronously so that if alot of
                // changes are made in a tight loop that only one invalidation will take place
                //this.InvalidateGeneratedStyles(true, false);
                this.InvalidateGeneratedStylesAsync();
            }
            else if (property == CurrentViewProperty)
            {
                if (null != this._rootRecordListControl)
                {
                    AutomationPeer peer = UIElementAutomationPeer.FromElement(this._rootRecordListControl);

					// AS 4/13/11 TFS72669
					// Added if check - FromElement can return null
					//
					if (null != peer)
					{
						peer.InvalidatePeer();

						// AS 4/13/11 TFS72669
						AutomationPeerHelper.InvalidateChildren(peer);
					}
				}
            }
            else if (e.Property == FocusWithinManager.IsFocusWithinProperty)
            {
                this.OnIsFocusWithinChanged((bool)e.NewValue);
            }
            else if (e.Property == FrameworkElement.LanguageProperty)
            {
                // JJD 3/5/08 - added support for Converter properies on Field
                // When the language canges clear the cached default converter
                this._defaultConverterCulture = null;

                // JJD 4/26/10 - TFS30833
                // loop over all initialized fields and access their ConverterCultureResolved
                // property which will raise a PropertyCanged notificiation if appropriate
                if (this.IsInitialized)
                {
                    foreach (FieldLayout flout in this.FieldLayouts)
                    {
                        if (flout.IsInitialized && flout.IsInitialRecordLoaded)
                        {
                            foreach (Field fld in flout.Fields)
                            {
                                if (fld.Owner == flout)
                                {
                                    CultureInfo ci = fld.ConverterCultureResolved;
                                }
                            }
                        }
                    }
                }

                FieldLayout fl = this.DefaultFieldLayout;

                if (fl != null)
                {
                    // JJD 5/5/09 - NA 2009 vol 2 - Cross band grouping 
                    // Bump the sort versions and verify the sort
                    
                    
                    
                    
                    
                    

                    
                    
                    this.FieldLayouts.BumpSortVersions();
                    this.RecordManager.VerifySort();

                    this.InvalidateMeasure();

                    // JJD 3/13/07
                    // Invalidate the measure of the main panel
                    // JJD 3/14/07
                    // Check to make sure currentpanel is not null
                    if (this.CurrentPanel != null)
                        this.CurrentPanel.InvalidateMeasure();
                }
            }

            // JM 11-18-08 TFS10382
            else if (e.Property == FrameworkElement.VisibilityProperty)
            {
                if (this.CurrentPanel != null &&
                    (Visibility)e.OldValue == Visibility.Hidden &&
                    (Visibility)e.NewValue == Visibility.Visible)
                {
                    this.CurrentPanel.InvalidateMeasure();
                    this.CurrentPanel.InvalidateArrange();
                    this.CurrentPanel.UpdateLayout();
                }
            }
            // JM 12-02-08 TFS10879
            else if (e.Property == Control.TemplateProperty)
            {
                if (this._invalidateGeneratedStylesPending)
                    this.OnInvalidateGeneratedStyles();
            }
		}

		#endregion //OnPropertyChanged

		#endregion //Base class overrides

		#region Events

		#region AssigningFieldLayoutToItem

		/// <summary>
		/// Event ID for the <see cref="AssigningFieldLayoutToItem"/> routed event
		/// </summary>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		public static readonly RoutedEvent AssigningFieldLayoutToItemEvent =
			EventManager.RegisterRoutedEvent("AssigningFieldLayoutToItem", RoutingStrategy.Bubble, typeof(EventHandler<AssigningFieldLayoutToItemEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when an item from the <see cref="DataSource "/> is being associated with a <see cref="FieldLayout"/> that will define the layout of cells for this item within the <see cref="DataPresenterBase"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>
		/// <seealso cref="AssigningFieldLayoutToItemEvent"/>
		protected virtual void OnAssigningFieldLayoutToItem(AssigningFieldLayoutToItemEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.AssigningFieldLayoutToItemDirect != null)
				this.AssigningFieldLayoutToItemDirect(this, args);
		}

		internal void RaiseAssigningFieldLayoutToItem(AssigningFieldLayoutToItemEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.AssigningFieldLayoutToItemEvent;
			args.Source = this;
			this.OnAssigningFieldLayoutToItem(args);
		}

		/// <summary>
		/// Occurs when an item from the <see cref="DataSource "/> is being associated with a <see cref="FieldLayout"/> that will define the layout of cells for this item within the <see cref="DataPresenterBase"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="OnAssigningFieldLayoutToItem"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>
		/// <seealso cref="AssigningFieldLayoutToItemEvent"/>
		//[Description("Occurs when an item from the 'DataSource' is being associated with the 'FieldLayout' that will define the layout of the item within the 'DataPresenterBase'.")]
		//[Category("Behavior")]
		public event EventHandler<AssigningFieldLayoutToItemEventArgs> AssigningFieldLayoutToItem
		{
			add
			{
				base.AddHandler(DataPresenterBase.AssigningFieldLayoutToItemEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.AssigningFieldLayoutToItemEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs when an item from the <see cref="DataSource "/> is being associated with a <see cref="FieldLayout"/> that will define the layout of cells for this item within the <see cref="DataPresenterBase"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItemDirect"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="OnAssigningFieldLayoutToItem"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayout"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>
		public event EventHandler<AssigningFieldLayoutToItemEventArgs> AssigningFieldLayoutToItemDirect;

		#endregion //AssigningFieldLayoutToItem

		#region QuerySummaryResult

		// SSP 1/31/12 NAS12.1 External Sorting/Filtering/Grouping/Summaries
		// 

		/// <summary>
		/// Event ID for the <see cref="QuerySummaryResult"/> routed event
		/// </summary>
		/// <seealso cref="QuerySummaryResult"/>
		/// <seealso cref="OnQuerySummaryResult"/>
		/// <seealso cref="QuerySummaryResultEventArgs"/>
		[InfragisticsFeature( FeatureName = "External_ViewOperations", Version = "12.1" )]
		public static readonly RoutedEvent QuerySummaryResultEvent =
			EventManager.RegisterRoutedEvent( "QuerySummaryResult", RoutingStrategy.Bubble, typeof( EventHandler<QuerySummaryResultEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised when a summary result is calculated or recalculated.
		/// </summary>
		/// <seealso cref="QuerySummaryResult"/>
		[InfragisticsFeature( FeatureName = "External_ViewOperations", Version = "12.1" )]
		protected virtual void OnQuerySummaryResult( QuerySummaryResultEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper( args );
		}

		internal void RaiseQuerySummaryResult( QuerySummaryResultEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.QuerySummaryResultEvent;
			args.Source = this;
			this.OnQuerySummaryResult( args );
		}

		/// <summary>
		/// Occurs when a summary result is about to be calculated or recalculated.
		/// </summary>
		/// <remarks>
		/// <b>QuerySummaryResult</b> event is raised when the data presenter is about to
		/// calculate a summary result. You can use this event to calculate and provide the 
		/// summary value and prevent the data presenter from performing its own calculation.
		/// </remarks>
		/// <seealso cref="OnSummaryResultChanged"/>
		/// <seealso cref="DataPresenterBase.SummarySelectionControlClosed"/>
		[InfragisticsFeature( FeatureName = "External_ViewOperations", Version = "12.1" )]
		public event EventHandler<QuerySummaryResultEventArgs> QuerySummaryResult
		{
			add
			{
				base.AddHandler( DataPresenterBase.QuerySummaryResultEvent, value );
			}
			remove
			{
				base.RemoveHandler( DataPresenterBase.QuerySummaryResultEvent, value );
			}
		}

		#endregion // QuerySummaryResult

		#region CellActivated

		/// <summary>
		/// Event ID for the <see cref="CellActivated"/> routed event
		/// </summary>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="OnCellActivated"/>
		/// <seealso cref="CellActivatedEventArgs"/>
		public static readonly RoutedEvent CellActivatedEvent =
			EventManager.RegisterRoutedEvent("CellActivated", RoutingStrategy.Bubble, typeof(EventHandler<CellActivatedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Cell"/> has been activated
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="CellActivatedEvent"/>
		/// <seealso cref="CellActivatedEventArgs"/>
		protected virtual void OnCellActivated(CellActivatedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.CellActivatedDirect != null)
				this.CellActivatedDirect(this, args);
		}

		internal void RaiseCellActivated(CellActivatedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellActivatedEvent;
			args.Source = this;
			this.OnCellActivated(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Cell"/> has been made the <see cref="ActiveCell"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="OnCellActivated"/>
		/// <seealso cref="CellActivatedEvent"/>
		/// <seealso cref="CellActivatedEventArgs"/>
		//[Description("Occurs after a cell is activated")]
		//[Category("Behavior")]
		public event EventHandler<CellActivatedEventArgs> CellActivated
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellActivatedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellActivatedEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs after a <see cref="Cell"/> has been made the <see cref="ActiveCell"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="OnCellActivated"/>
		/// <seealso cref="CellActivatedEventArgs"/>
		public event EventHandler<CellActivatedEventArgs> CellActivatedDirect;

		#endregion //CellActivated

		#region CellActivating

		/// <summary>
		/// Event ID for the <see cref="CellActivating"/> routed event
		/// </summary>
		/// <seealso cref="CellActivating"/>
		/// <seealso cref="OnCellActivating"/>
		/// <seealso cref="CellActivatingEventArgs"/>
		public static readonly RoutedEvent CellActivatingEvent =
			EventManager.RegisterRoutedEvent("CellActivating", RoutingStrategy.Bubble, typeof(EventHandler<CellActivatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Cell"/> is activated
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="CellActivating"/>
		/// <seealso cref="CellActivatingEvent"/>
		/// <seealso cref="CellActivatingEventArgs"/>
		protected virtual void OnCellActivating(CellActivatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.CellActivatingDirect != null)
				this.CellActivatingDirect(this, args);
		}

		internal void RaiseCellActivating(CellActivatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellActivatingEvent;
			args.Source = this;
			this.OnCellActivating(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Cell"/> is activated
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="OnCellActivating"/>
		/// <seealso cref="CellActivatingEvent"/>
		/// <seealso cref="CellActivatingEventArgs"/>
		//[Description("Occurs before a cell is activated")]
		//[Category("Behavior")]
		public event EventHandler<CellActivatingEventArgs> CellActivating
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellActivatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellActivatingEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs before a <see cref="Cell"/> is activated
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="OnCellActivating"/>
		/// <seealso cref="CellActivatingEventArgs"/>
		public event EventHandler<CellActivatingEventArgs> CellActivatingDirect;

		#endregion //CellActivating

		#region CellChanged

		/// <summary>
		/// Event ID for the <see cref="CellChanged"/> routed event
		/// </summary>
		/// <seealso cref="CellChanged"/>
		/// <seealso cref="OnCellChanged"/>
		/// <seealso cref="CellChangedEventArgs"/>
		public static readonly RoutedEvent CellChangedEvent =
			EventManager.RegisterRoutedEvent("CellChanged", RoutingStrategy.Bubble, typeof(EventHandler<CellChangedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is in edit mode and the user modifies its value.
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once a <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeStarting"/>
		/// <seealso cref="CellChanged"/>
		/// <seealso cref="CellChangedEvent"/>
		/// <seealso cref="CellChangedEventArgs"/>
		protected virtual void OnCellChanged(CellChangedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseCellChanged(CellChangedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellChangedEvent;
			args.Source = this;
			this.OnCellChanged(args);
		}

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is in edit mode and the user modifies its value.
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once a <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeStarting"/>
		/// <seealso cref="OnCellChanged"/>
		/// <seealso cref="CellChangedEvent"/>
		/// <seealso cref="CellChangedEventArgs"/>
		//[Description("Occurs after a cell has been modified while in edit mode")]
		//[Category("Behavior")]
		public event EventHandler<CellChangedEventArgs> CellChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellChangedEvent, value);
			}
		}

		#endregion //CellChanged

		#region CellDeactivating

		/// <summary>
		/// Event ID for the <see cref="CellDeactivating"/> routed event
		/// </summary>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="OnCellDeactivating"/>
		/// <seealso cref="CellDeactivatingEventArgs"/>
		public static readonly RoutedEvent CellDeactivatingEvent =
			EventManager.RegisterRoutedEvent("CellDeactivating", RoutingStrategy.Bubble, typeof(EventHandler<CellDeactivatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Cell"/> is de-activated
		/// </summary>
		/// <remarks>
		/// <para class="body">If the <see cref="Cell"/> was in edit mode, i.e. its <see cref="Cell.IsInEditMode"/> property returned true, de-activating it either by setting the its <see cref="Cell.IsActive"/> property to false or by changing the <see cref="ActiveCell"/> or <see cref="ActiveRecord"/> property will cause it to end edit mode.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> You can cause the <see cref="ActiveCell"/> to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="CellDeactivatingEvent"/>
		/// <seealso cref="CellDeactivatingEventArgs"/>
		protected virtual void OnCellDeactivating(CellDeactivatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.CellDeactivatingDirect != null)
				this.CellDeactivatingDirect(this, args);
		}

		internal void RaiseCellDeactivating(CellDeactivatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellDeactivatingEvent;
			args.Source = this;
			this.OnCellDeactivating(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Cell"/> is deactivated
		/// </summary>
		/// <remarks>
		/// <para class="body">If the <see cref="Cell"/> was in edit mode, i.e. its <see cref="Cell.IsInEditMode"/> property returned true, de-activating it either by setting the its <see cref="Cell.IsActive"/> property to false or by changing the <see cref="ActiveCell"/> or <see cref="ActiveRecord"/> property will cause it to end edit mode.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> You can cause the <see cref="ActiveCell"/> to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="OnCellDeactivating"/>
		/// <seealso cref="CellDeactivatingEvent"/>
		/// <seealso cref="CellDeactivatingEventArgs"/>
		//[Description("Occurs before a cell is deactivated")]
		//[Category("Behavior")]
		public event EventHandler<CellDeactivatingEventArgs> CellDeactivating
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellDeactivatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellDeactivatingEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs before a <see cref="Cell"/> is deactivated
		/// </summary>
		/// <remarks>
		/// <para class="body">If the <see cref="Cell"/> was in edit mode, i.e. its <see cref="Cell.IsInEditMode"/> property returned true, de-activating it either by setting the its <see cref="Cell.IsActive"/> property to false or by changing the <see cref="ActiveCell"/> or <see cref="ActiveRecord"/> property will cause it to end edit mode.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> You can cause the <see cref="ActiveCell"/> to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="OnCellDeactivating"/>
		/// <seealso cref="CellDeactivatingEventArgs"/>
		public event EventHandler<CellDeactivatingEventArgs> CellDeactivatingDirect;

		#endregion //CellDeactivating

		#region CellsInViewChanged

		// SSP 2/2/10
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 
		/// <summary>
		/// Raised when cells that are currently in view have changed.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>CellsInViewChanged</b> event is raised when cells that are currently in view have changed.
		/// This can be a result of scrolling vertically or horizontally, resizing of the control, 
		/// change in data source etc...
		/// </para>
		/// </remarks>
		/// <seealso cref="CellsInViewChangedEventArgs"/>
		public event EventHandler<CellsInViewChangedEventArgs> CellsInViewChanged
		{
			add
			{
				_cellsInViewChangedEventHandler = (EventHandler<CellsInViewChangedEventArgs>)Delegate.Combine( _cellsInViewChangedEventHandler, value );
			}
			remove
			{
				_cellsInViewChangedEventHandler = (EventHandler<CellsInViewChangedEventArgs>)Delegate.Remove( _cellsInViewChangedEventHandler, value );
			}
		}

		internal void RaiseCellsInViewChanged( CellsInViewChangedEventArgs eventArgs )
		{
			if ( null != _cellsInViewChangedEventHandler )
				_cellsInViewChangedEventHandler( this, eventArgs );
		}

		#endregion // CellsInViewChanged

		#region CellUpdating

		/// <summary>
		/// Event ID for the <see cref="CellUpdating"/> routed event
		/// </summary>
		/// <seealso cref="CellUpdating"/>
		/// <seealso cref="OnCellUpdating"/>
		/// <seealso cref="CellUpdatingEventArgs"/>
		public static readonly RoutedEvent CellUpdatingEvent =
			EventManager.RegisterRoutedEvent("CellUpdating", RoutingStrategy.Bubble, typeof(EventHandler<CellUpdatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when a <see cref="Cell"/>'s value is about to be updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">When the value is updated by the user as a result of ending edit mode on the <see cref="ActiveCell"/> after changes were made, the sequence of events is <see cref="EditModeEnding"/>, <see cref="EditModeValidationError"/> (for validation errors generated by the editor), <b>CellUpdating</b>, <see cref="CellUpdated"/> or <see cref="DataError"/> (for exceptions thrown by the <see cref="DataSource"/>) and finally <see cref="EditModeEnded"/>.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="DataError"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="CellUpdating"/>
		/// <seealso cref="CellUpdatingEvent"/>
		/// <seealso cref="CellUpdatingEventArgs"/>
		protected virtual void OnCellUpdating(CellUpdatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseCellUpdating(CellUpdatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellUpdatingEvent;
			args.Source = this;
			this.OnCellUpdating(args);
		}

		/// <summary>
		/// Occurs when a <see cref="Cell"/>'s value is about to be updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">When the value is updated by the user as a result of ending edit mode on the <see cref="ActiveCell"/> after changes were made, the sequence of events is <see cref="EditModeEnding"/>, <see cref="EditModeValidationError"/> (for validation errors generated by the editor), <b>CellUpdating</b>, <see cref="CellUpdated"/> or <see cref="DataError"/> (for exceptions thrown by the <see cref="DataSource"/>) and finally <see cref="EditModeEnded"/>.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="DataError"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="OnCellUpdating"/>
		/// <seealso cref="CellUpdated"/>
		/// <seealso cref="CellUpdatingEvent"/>
		/// <seealso cref="CellUpdatingEventArgs"/>
		//[Description("Occurs when a cell is about to be updated.")]
		//[Category("Data")]
		public event EventHandler<CellUpdatingEventArgs> CellUpdating
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellUpdatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellUpdatingEvent, value);
			}
		}

		#endregion //CellUpdating

		#region CellUpdated

		/// <summary>
		/// Event ID for the <see cref="CellUpdated"/> routed event
		/// </summary>
		/// <seealso cref="CellUpdated"/>
		/// <seealso cref="OnCellUpdated"/>
		/// <seealso cref="CellUpdatedEventArgs"/>
		public static readonly RoutedEvent CellUpdatedEvent =
			EventManager.RegisterRoutedEvent("CellUpdated", RoutingStrategy.Bubble, typeof(EventHandler<CellUpdatedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Cell"/> has been updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">When the value is updated by the user as a result of ending edit mode on the <see cref="ActiveCell"/> after changes were made, the sequence of events is <see cref="EditModeEnding"/>, <see cref="EditModeValidationError"/> (for validation errors generated by the editor), <see cref="CellUpdating"/>, <b>CellUpdated</b> or <see cref="DataError"/> (for exceptions thrown by the <see cref="DataSource"/>) and finally <see cref="EditModeEnded"/>.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="DataError"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="CellUpdated"/>
		/// <seealso cref="CellUpdatedEvent"/>
		/// <seealso cref="CellUpdatedEventArgs"/>
		protected virtual void OnCellUpdated(CellUpdatedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseCellUpdated(CellUpdatedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.CellUpdatedEvent;
			args.Source = this;
			this.OnCellUpdated(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Cell"/>'s value has been updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">When the value is updated by the user as a result of ending edit mode on the <see cref="ActiveCell"/> after changes were made, the sequence of events is <see cref="EditModeEnding"/>, <see cref="EditModeValidationError"/> (for validation errors generated by the editor), <see cref="CellUpdating"/>, <b>CellUpdated</b> or <see cref="DataError"/> (for exceptions thrown by the <see cref="DataSource"/>) and finally <see cref="EditModeEnded"/>.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="DataError"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="OnCellUpdated"/>
		/// <seealso cref="CellUpdating"/>
		/// <seealso cref="CellUpdatedEvent"/>
		/// <seealso cref="CellUpdatedEventArgs"/>
		//[Description("Occurs after a cell has been updated.")]
		//[Category("Data")]
		public event EventHandler<CellUpdatedEventArgs> CellUpdated
		{
			add
			{
				base.AddHandler(DataPresenterBase.CellUpdatedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.CellUpdatedEvent, value);
			}
		}

		#endregion //CellUpdated

        // AS 4/14/09 NA 2009.2 ClipboardSupport
        #region ClipboardCopying

        /// <summary>
        /// Event ID for the <see cref="ClipboardCopying"/> routed event
        /// </summary>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="OnClipboardCopying"/>
        /// <seealso cref="ClipboardCopyingEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedEvent ClipboardCopyingEvent =
            EventManager.RegisterRoutedEvent("ClipboardCopying", RoutingStrategy.Bubble, typeof(EventHandler<ClipboardCopyingEventArgs>), typeof(DataPresenterBase));

        /// <summary>
        /// Raises the <see cref="ClipboardCopying"/> event
        /// </summary>
        /// <param name="args">Provides information for the event being raised</param>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="ClipboardCopyingEvent"/>
        /// <seealso cref="ClipboardCopyingEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        protected virtual void OnClipboardCopying(ClipboardCopyingEventArgs args)
        {
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
        }

        internal void RaiseClipboardCopying(ClipboardCopyingEventArgs args)
        {
            args.RoutedEvent = DataPresenterBase.ClipboardCopyingEvent;
            args.Source = this;
            this.OnClipboardCopying(args);
        }

        /// <summary>
        /// Occurs when the <see cref="DataPresenterCommands.Copy"/> or <see cref="DataPresenterCommands.Cut"/> command is executed and the cell values will be placed on the clipboard.
        /// </summary>
        /// <remarks>
        /// <para class="body">This event can be used to provide the formatted values that will be placed on the clipboard.</para>
        /// </remarks>
        /// <seealso cref="ClipboardCopyingEvent"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="OnClipboardCopying"/>
        /// <seealso cref="ClipboardCopyingEventArgs"/>
        //[Description("Occurs when the 'Copy' or 'Cut' command is executed and the cell values will be placed on the clipboard.")]
        //[Category("Behavior")]
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public event EventHandler<ClipboardCopyingEventArgs> ClipboardCopying
        {
            add
            {
                base.AddHandler(DataPresenterBase.ClipboardCopyingEvent, value);
            }
            remove
            {
                base.RemoveHandler(DataPresenterBase.ClipboardCopyingEvent, value);
            }
        }

        #endregion //ClipboardCopying

        // AS 4/14/09 NA 2009.2 ClipboardSupport
        #region ClipboardOperationError

        /// <summary>
        /// Event ID for the <see cref="ClipboardOperationError"/> routed event
        /// </summary>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="OnClipboardOperationError"/>
        /// <seealso cref="ClipboardOperationErrorEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedEvent ClipboardOperationErrorEvent =
            EventManager.RegisterRoutedEvent("ClipboardOperationError", RoutingStrategy.Bubble, typeof(EventHandler<ClipboardOperationErrorEventArgs>), typeof(DataPresenterBase));

        /// <summary>
        /// Raises the <see cref="ClipboardOperationError"/> event
        /// </summary>
        /// <param name="args">Provides information for the event being raised</param>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="ClipboardOperationErrorEvent"/>
        /// <seealso cref="ClipboardOperationErrorEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        protected virtual void OnClipboardOperationError(ClipboardOperationErrorEventArgs args)
        {
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
        }

        internal void RaiseClipboardOperationError(ClipboardOperationErrorEventArgs args)
        {
            args.RoutedEvent = DataPresenterBase.ClipboardOperationErrorEvent;
            args.Source = this;
            this.OnClipboardOperationError(args);
        }

        /// <summary>
        /// Occurs when an error is encountered during a clipboard operation.
        /// </summary>
        /// <remarks>
        /// <para class="body">This event occurs while processing a clipboard operation such as a 
        /// cut, copy, paste or delete if an exception is encountered. When the event 
        /// is raised for a specific <see cref="ClipboardOperationErrorEventArgs.Cell"/>, the 
        /// <see cref="ClipboardOperationErrorEventArgs.Action"/> can be used to determine whether 
        /// and how the processing should continue. In addition, the event can be used to control 
        /// what error message, if any, is provided to the end-user.
        /// </para>
        /// </remarks>
        /// <seealso cref="ClipboardOperationErrorEvent"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="OnClipboardOperationError"/>
        /// <seealso cref="ClipboardOperationErrorEventArgs"/>
        //[Description("Occurs when an error is encountered during a clipboard operation.")]
        //[Category("Behavior")]
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public event EventHandler<ClipboardOperationErrorEventArgs> ClipboardOperationError
        {
            add
            {
                base.AddHandler(DataPresenterBase.ClipboardOperationErrorEvent, value);
            }
            remove
            {
                base.RemoveHandler(DataPresenterBase.ClipboardOperationErrorEvent, value);
            }
        }

        #endregion //ClipboardOperationError

        // AS 4/14/09 NA 2009.2 ClipboardSupport
        #region ClipboardPasting

        /// <summary>
        /// Event ID for the <see cref="ClipboardPasting"/> routed event
        /// </summary>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="OnClipboardPasting"/>
        /// <seealso cref="ClipboardPastingEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedEvent ClipboardPastingEvent =
            EventManager.RegisterRoutedEvent("ClipboardPasting", RoutingStrategy.Bubble, typeof(EventHandler<ClipboardPastingEventArgs>), typeof(DataPresenterBase));

        /// <summary>
        /// Raises the <see cref="ClipboardPasting"/> event
        /// </summary>
        /// <param name="args">Provides information for the event being raised</param>
        /// <seealso cref="ClipboardPasting"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="ClipboardPastingEvent"/>
        /// <seealso cref="ClipboardPastingEventArgs"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        protected virtual void OnClipboardPasting(ClipboardPastingEventArgs args)
        {
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
        }

        internal void RaiseClipboardPasting(ClipboardPastingEventArgs args)
        {
            args.RoutedEvent = DataPresenterBase.ClipboardPastingEvent;
            args.Source = this;
            this.OnClipboardPasting(args);
        }

        /// <summary>
        /// Occurs when the <see cref="DataPresenterCommands.Paste"/> command is executed and the cell values will be updated based on the values in the clipboard.
        /// </summary>
        /// <remarks>
        /// <para class="body">This event can be used to provide the parsed values that should be used to update the associated cells.</para>
        /// </remarks>
        /// <seealso cref="ClipboardPastingEvent"/>
        /// <seealso cref="ClipboardCopying"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
        /// <seealso cref="ClipboardOperationError"/>
        /// <seealso cref="OnClipboardPasting"/>
        /// <seealso cref="ClipboardPastingEventArgs"/>
        //[Description("Occurs when an error is encountered during a clipboard operation.")]
        //[Category("Behavior")]
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public event EventHandler<ClipboardPastingEventArgs> ClipboardPasting
        {
            add
            {
                base.AddHandler(DataPresenterBase.ClipboardPastingEvent, value);
            }
            remove
            {
                base.RemoveHandler(DataPresenterBase.ClipboardPastingEvent, value);
            }
        }

        #endregion //ClipboardPasting

        #region CustomFilterSelectionControlOpening

        // SSP 12/12/08 - NAS9.1 Record Filtering
		// 

		/// <summary>
		/// Event ID for the <see cref="CustomFilterSelectionControlOpening"/> routed event
		/// </summary>
		/// <seealso cref="CustomFilterSelectionControlOpening"/>
		public static readonly RoutedEvent CustomFilterSelectionControlOpeningEvent =
			EventManager.RegisterRoutedEvent( "CustomFilterSelectionControlOpening", RoutingStrategy.Bubble,
				typeof( EventHandler<CustomFilterSelectionControlOpeningEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before the UI for entering custom filter criteria for a field is displayed. 
		/// You can cancel this event and display your own UI.
		/// </summary>
		/// <seealso cref="CustomFilterSelectionControlOpening"/>
		protected virtual void OnCustomFilterSelectionControlOpening( CustomFilterSelectionControlOpeningEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseCustomFilterSelectionControlOpening( CustomFilterSelectionControlOpeningEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.CustomFilterSelectionControlOpeningEvent;
			args.Source = this;
			this.OnCustomFilterSelectionControlOpening( args );
		}

		/// <summary>
		/// Raised before the UI for entering custom filter criteria for a field is displayed. 
		/// You can cancel this event and display your own UI.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>CustomFilterSelectionControlOpening</b> is raised before the user interface for entering custom filter criteria 
		/// is displayed. This happens when the user selects '(Custom)' entry from the filter drop-down.
		/// To enable the filtering functionality, set the
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> and
		/// <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> properties.
		/// </para>
		/// <para class="body">
		/// Note that you can cancel this event in which case the UI will not be displayed. This lets you display
		/// your own UI for letting the user enter custom filter criteria. Also note that you can use the
		/// <see cref="RecordFilterDropDownPopulating"/> event to remove the '(Custom)' entry from the filter
		/// drop-down list or add any other custom filter entries.
		/// </para>
		/// </remarks>
		/// <seealso cref="CustomFilterSelectionControlOpening"/>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="RecordFilterChanging"/>
		/// <seealso cref="RecordFilterChanged"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>
		//[Description( "Raised before the UI for entering custom filter criteria is displayed." )]
		//[Category( "Behavior" )]
		public event EventHandler<CustomFilterSelectionControlOpeningEventArgs> CustomFilterSelectionControlOpening
		{
			add
			{
				base.AddHandler( CustomFilterSelectionControlOpeningEvent, value );
			}
			remove
			{
				base.RemoveHandler( CustomFilterSelectionControlOpeningEvent, value );
			}
		}

		#endregion // CustomFilterSelectionControlOpening

		#region DataError

		/// <summary>
		/// Event ID for the <see cref="DataError"/> routed event
		/// </summary>
		/// <seealso cref="DataError"/>
		/// <seealso cref="OnDataError"/>
		/// <seealso cref="DataErrorEventArgs"/>
		public static readonly RoutedEvent DataErrorEvent =
			EventManager.RegisterRoutedEvent("DataError", RoutingStrategy.Bubble, typeof(EventHandler<DataErrorEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when an exception is thrown by the DataSource.
		/// </summary>
		/// <remarks>
		/// <para class="body">An exception can be thrown by the <see cref="DataSource"/> when reading or updating a <see cref="Cell"/>s value, deleting an existing <see cref="DataRecord"/> or adding a new one.</para>
		/// </remarks>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.DeleteSelectedDataRecords"/>
		/// <seealso cref="DataError"/>
		/// <seealso cref="DataErrorEvent"/>
		/// <seealso cref="DataErrorEventArgs"/>
		protected virtual void OnDataError(DataErrorEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseDataError(DataRecord record, Field field, Exception exception, DataErrorOperation operation, string message)
		{
			this.RaiseDataError(record, field, exception, operation, message, false);
		}
		internal void RaiseDataError(DataRecord record, Field field, Exception exception, DataErrorOperation operation, string message, bool defaultCancelValue)
		{
			// AS 5/5/09 NA 2009.2 ClipboardSupport
			// I added a helper class to hold the dataerror information so the clipboard classes 
			// could get handed back an object with the error information so it could raise its
			// own events.
			//
			//DataErrorEventArgs args = new DataErrorEventArgs(record, field, exception, operation, message);
			DataErrorInfo info = new DataErrorInfo(record, field, exception, operation, message);
			this.RaiseDataError(info, defaultCancelValue);
		}

		internal void RaiseDataError(DataErrorInfo info)
		{
			RaiseDataError(info, false);
		}

		internal void RaiseDataError(DataErrorInfo info, bool defaultCancelValue)
		{
			DataErrorEventArgs args = new DataErrorEventArgs(info);

			args.Cancel = defaultCancelValue;
			args.RoutedEvent = DataPresenterBase.DataErrorEvent;
			args.Source = this;
			this.OnDataError(args);

			if (args.Cancel == true)
				return;

			// Display messagebox
			//
			this.DisplayDataError(args.Message, DataPresenterBase.GetString("DataErrorMessageTitle"), MessageBoxButton.OK, MessageBoxImage.Information, true);

		}

		delegate void DataErrorMessageDelegate(string message, string title, MessageBoxButton buttons, MessageBoxImage image, bool processAsyncOnException);

		private void DisplayDataError(string message, string title, MessageBoxButton buttons, MessageBoxImage image, bool processAsyncOnException)
		{
			try
			{
                // AS 10/23/08 TFS9546
				//MessageBox.Show(Window.GetWindow(this),
                Utilities.ShowMessageBox(this,
					message,
					title,
					buttons,
					image);
			}
			catch (Exception)
			{
				if (processAsyncOnException == true)
				{
					if (!this.Dispatcher.HasShutdownStarted)
						this.Dispatcher.BeginInvoke(DispatcherPriority.Render, new DataErrorMessageDelegate(this.DisplayDataError), message, new object[] { title, buttons, image, false });
				}
			}
		}

		/// <summary>
		/// Occurs when an exception is thrown by the DataSource.
		/// </summary>
		/// <remarks>
		/// <para class="body">An exception can be thrown by the <see cref="DataSource"/> when reading or updating a <see cref="Cell"/>s value, deleting an existing <see cref="DataRecord"/> or adding a new one.</para>
		/// </remarks>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.DeleteSelectedDataRecords"/>
		/// <seealso cref="OnDataError"/>
		/// <seealso cref="DataErrorEvent"/>
		/// <seealso cref="DataErrorEventArgs"/>
		//[Description("Occurs when an exception is thrown when reading or writing cell data")]
		//[Category("Behavior")]
		public event EventHandler<DataErrorEventArgs> DataError
		{
			add
			{
				base.AddHandler(DataPresenterBase.DataErrorEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.DataErrorEvent, value);
			}
		}

		#endregion //DataError

		// JM 6/12/09 NA 2009.2 DataValueChangedEvent
		#region DataValueChanged

		/// <summary>
		/// Event ID for the <see cref="DataValueChanged"/> routed event
		/// </summary>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="OnDataValueChanged"/>
		/// <seealso cref="DataValueChangedEventArgs"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public static readonly RoutedEvent DataValueChangedEvent =
			EventManager.RegisterRoutedEvent("DataValueChanged", RoutingStrategy.Bubble, typeof(EventHandler<DataValueChangedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Raises the <see cref="DataValueChanged"/> event
		/// </summary>
		/// <param name="args">Provides information for the event being raised</param>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="DataValueChangedEvent"/>
		/// <seealso cref="DataValueChangedEventArgs"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		protected virtual void OnDataValueChanged(DataValueChangedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.DataValueChangedDirect != null)
				this.DataValueChangedDirect(this, args);
		}

		internal void RaiseDataValueChanged(DataValueChangedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.DataValueChangedEvent;
			args.Source = this;
			this.OnDataValueChanged(args);
		}

		/// <summary>
		/// Occurs when a <see cref="Cell"/> value has changed for a <see cref="Field"/> whose <see cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/> property has been set to true.
		/// </summary>
		/// <remarks>
		/// <para class="body">This event can be used to change the visual appearance of the associated <see cref="CellValuePresenter"/> to notify the end-user that the value has changed.</para>
		/// </remarks>
		/// <seealso cref="DataValueChangedEvent"/>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="DataValueChangedEvent"/>
		/// <seealso cref="DataValueChangedEventArgs"/>
		//[Description("Occurs when a Cell value has changed for a Field whose FieldSettings.DataValueChangedNotificationsActive property has been set to true.")]
		//[Category("Behavior")]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public event EventHandler<DataValueChangedEventArgs> DataValueChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.DataValueChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.DataValueChangedEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs when a <see cref="Cell"/> value has changed for a <see cref="Field"/> whose <see cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/> property has been set to true.
		/// </summary>
		/// <remarks>
		/// <para class="body">This event can be used to change the visual appearance of the associated <see cref="CellValuePresenter"/> to notify the end-user that the value has changed.</para>
		/// </remarks>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="DataValueChangedEventArgs"/>
		public event EventHandler<DataValueChangedEventArgs> DataValueChangedDirect;

		#endregion //DataValueChanged

		#region EditModeEnded

		/// <summary>
		/// Event ID for the <see cref="EditModeEnded"/> routed event
		/// </summary>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="OnEditModeEnded"/>
		/// <seealso cref="EditModeEndedEventArgs"/>
		public static readonly RoutedEvent EditModeEndedEvent =
			EventManager.RegisterRoutedEvent("EditModeEnded", RoutingStrategy.Bubble, typeof(EventHandler<EditModeEndedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after the <see cref="ActiveCell"/> has ended edit mode
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEndedEvent"/>
		/// <seealso cref="EditModeEndedEventArgs"/>
		protected virtual void OnEditModeEnded(EditModeEndedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseEditModeEnded(EditModeEndedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.EditModeEndedEvent;
			args.Source = this;
			this.OnEditModeEnded(args);
		}

		/// <summary>
		/// Occurs after the <see cref="ActiveCell"/> has ended edit mode
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEndedEvent"/>
		/// <seealso cref="EditModeEndedEventArgs"/>
		//[Description("Occurs when the control has just exited edit mode")]
		//[Category("Behavior")]
		public event EventHandler<EditModeEndedEventArgs> EditModeEnded
		{
			add
			{
				base.AddHandler(DataPresenterBase.EditModeEndedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.EditModeEndedEvent, value);
			}
		}

		#endregion //EditModeEnded

		#region EditModeEnding

		/// <summary>
		/// Event ID for the <see cref="EditModeEnding"/> routed event
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="OnEditModeEnding"/>
		/// <seealso cref="EditModeEndingEventArgs"/>
		public static readonly RoutedEvent EditModeEndingEvent =
			EventManager.RegisterRoutedEvent("EditModeEnding", RoutingStrategy.Bubble, typeof(EventHandler<EditModeEndingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is about to end edit mode
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEndingEvent"/>
		/// <seealso cref="EditModeEndingEventArgs"/>
		protected virtual void OnEditModeEnding(EditModeEndingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseEditModeEnding(EditModeEndingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.EditModeEndingEvent;
			args.Source = this;
			this.OnEditModeEnding(args);
		}

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is about to end edit mode
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeEnding"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeEndingEvent"/>
		/// <seealso cref="EditModeEndingEventArgs"/>
		//[Description("Occurs when the control is about to exit edit mode")]
		//[Category("Behavior")]
		public event EventHandler<EditModeEndingEventArgs> EditModeEnding
		{
			add
			{
				base.AddHandler(DataPresenterBase.EditModeEndingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.EditModeEndingEvent, value);
			}
		}

		#endregion //EditModeEnding

		#region EditModeStarted

		/// <summary>
		/// Event ID for the <see cref="EditModeStarted"/> routed event
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnEditModeStarted"/>
		/// <seealso cref="EditModeStartedEventArgs"/>
		public static readonly RoutedEvent EditModeStartedEvent =
			EventManager.RegisterRoutedEvent("EditModeStarted", RoutingStrategy.Bubble, typeof(EventHandler<EditModeStartedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after the <see cref="ActiveCell"/> has entered edit mode
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStartedEvent"/>
		/// <seealso cref="EditModeStartedEventArgs"/>
		protected virtual void OnEditModeStarted(EditModeStartedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseEditModeStarted(EditModeStartedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.EditModeStartedEvent;
			args.Source = this;
			this.OnEditModeStarted(args);
		}

		/// <summary>
		/// Occurs after the <see cref="ActiveCell"/> has entered edit mode
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeStarted"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStartedEvent"/>
		/// <seealso cref="EditModeStartedEventArgs"/>
		//[Description("Occurs when the control has just entered edit mode")]
		//[Category("Behavior")]
		public event EventHandler<EditModeStartedEventArgs> EditModeStarted
		{
			add
			{
				base.AddHandler(DataPresenterBase.EditModeStartedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.EditModeStartedEvent, value);
			}
		}

		#endregion //EditModeStarted

		#region EditModeStarting

		/// <summary>
		/// Event ID for the <see cref="EditModeStarting"/> routed event
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnEditModeStarting"/>
		/// <seealso cref="EditModeStartingEventArgs"/>
		public static readonly RoutedEvent EditModeStartingEvent =
			EventManager.RegisterRoutedEvent("EditModeStarting", RoutingStrategy.Bubble, typeof(EventHandler<EditModeStartingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is about to enter edit mode
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStartingEvent"/>
		/// <seealso cref="EditModeStartingEventArgs"/>
		protected virtual void OnEditModeStarting(EditModeStartingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseEditModeStarting(EditModeStartingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.EditModeStartingEvent;
			args.Source = this;
			this.OnEditModeStarting(args);
		}

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> is about to enter edit mode
		/// </summary>
		/// <remarks>
		/// <para class="body">Before a <see cref="Cell"/> can be edited it must first be activated by either setting its <see cref="Cell.IsActive"/> property to true or by setting the control's <see cref="ActiveCell"/> property.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> property returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="OnEditModeStarting"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands.StartEditMode"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/>
		/// <seealso cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeStartingEvent"/>
		/// <seealso cref="EditModeStartingEventArgs"/>
		//[Description("Occurs when the control is about to enter edit mode")]
		//[Category("Behavior")]
		public event EventHandler<EditModeStartingEventArgs> EditModeStarting
		{
			add
			{
				base.AddHandler(DataPresenterBase.EditModeStartingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.EditModeStartingEvent, value);
			}
		}

		#endregion //EditModeStarting

		#region EditModeValidationError

		/// <summary>
		/// Event ID for the <see cref="EditModeValidationError"/> routed event
		/// </summary>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnEditModeValidationError"/>
		/// <seealso cref="EditModeValidationErrorEventArgs"/>
		public static readonly RoutedEvent EditModeValidationErrorEvent =
			EventManager.RegisterRoutedEvent("EditModeValidationError", RoutingStrategy.Bubble, typeof(EventHandler<EditModeValidationErrorEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> has an input validation error
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// This event is raised when the user attempts to end the edit mode on <see cref="ActiveCell"/> after entering
		/// an invalid value. The default behavior is to display an error message and not end the
		/// edit mode on the cell. You can change this default behavior by setting the 
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.InvalidValueBehavior"/> property on <see cref="FieldSettings"/> 
		/// or by hooking into this event and setting various properties on the associated event args
		/// to control the behavior, including what to display in the error message.
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.InvalidValueBehavior"/>
		/// <seealso cref="EditModeStarting"/>
		/// <seealso cref="EditModeStarted"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="EditModeValidationErrorEventArgs"/>
		protected virtual void OnEditModeValidationError(EditModeValidationErrorEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseEditModeValidationError(EditModeValidationErrorEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.EditModeValidationErrorEvent;
			args.Source = this;
			this.OnEditModeValidationError(args);
		}

		/// <summary>
		/// Occurs when the <see cref="ActiveCell"/> has an input validation error
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// This event is raised when the user attempts to end the edit mode on <see cref="ActiveCell"/> after entering
		/// an invalid value. The default behavior is to display an error message and not end the
		/// edit mode on the cell. You can change this default behavior by setting the 
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.InvalidValueBehavior"/> property on <see cref="FieldSettings"/> 
		/// or by hooking into this event and setting various properties on the associated event args
		/// to control the behavior, including what to display in the error message.
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> To end edit mode you can call the <see cref="ActiveCell"/>'s <see cref="Cell.EndEditMode()"/> method, change the <see cref="ActiveCell"/>, change the <see cref="ActiveRecord"/> or call <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.EndEditModeAndAcceptChanges"/> or <see cref="DataPresenterCommands.EndEditModeAndDiscardChanges"/> commands.</para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.InvalidValueBehavior"/>
		/// <seealso cref="OnEditModeValidationError"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeValidationError"/>
		/// <seealso cref="EditModeValidationErrorEvent"/>
		/// <seealso cref="EditModeValidationErrorEventArgs"/>
		//[Description("Occurs when there is a cell input validation error")]
		//[Category("Behavior")]
		public event EventHandler<EditModeValidationErrorEventArgs> EditModeValidationError
		{
			add
			{
				base.AddHandler(DataPresenterBase.EditModeValidationErrorEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.EditModeValidationErrorEvent, value);
			}
		}

		#endregion //EditModeValidationError

		#region ExecutingCommand

		/// <summary>
		/// Event ID for the <see cref="ExecutingCommand"/> routed event
		/// </summary>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="OnExecutingCommand"/>
		/// <seealso cref="ExecutingCommandEventArgs"/>
		public static readonly RoutedEvent ExecutingCommandEvent =
			EventManager.RegisterRoutedEvent("ExecutingCommand", RoutingStrategy.Bubble, typeof(EventHandler<ExecutingCommandEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a command is executed.
		/// </summary>
		/// <remarks><para class="body">This event is cancellable.</para></remarks>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="ExecutedCommand"/>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutingCommandEvent"/>
		/// <seealso cref="ExecutingCommandEventArgs"/>
		protected virtual void OnExecutingCommand(ExecutingCommandEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.ExecutingCommandDirect != null)
				this.ExecutingCommandDirect(this, args);
		}

		internal bool RaiseExecutingCommand(ExecutingCommandEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.ExecutingCommandEvent;
			args.Source = this;
			this.OnExecutingCommand(args);

			return args.Cancel == false;
		}

		/// <summary>
		/// Occurs before a command is executed
		/// </summary>
		/// <remarks><para class="body">This event is cancellable.</para></remarks>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnExecutingCommand"/>
		/// <seealso cref="ExecutingCommandEvent"/>
		/// <seealso cref="ExecutingCommandEventArgs"/>
		//[Description("Occurs before a command is performed")]
		//[Category("Behavior")]
		public event EventHandler<ExecutingCommandEventArgs> ExecutingCommand
		{
			add
			{
				base.AddHandler(DataPresenterBase.ExecutingCommandEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.ExecutingCommandEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs before a command is executed
		/// </summary>
		/// <remarks><para class="body">This event is cancellable.</para></remarks>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnExecutingCommand"/>
		/// <seealso cref="ExecutingCommandEventArgs"/>
		public event EventHandler<ExecutingCommandEventArgs> ExecutingCommandDirect;

		#endregion //ExecutingCommand

		#region ExecutedCommand

		/// <summary>
		/// Event ID for the <see cref="ExecutedCommand"/> routed event
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="ExecutedCommand"/>
		/// <seealso cref="OnExecutedCommand"/>
		/// <seealso cref="ExecutedCommandEventArgs"/>
		public static readonly RoutedEvent ExecutedCommandEvent =
			EventManager.RegisterRoutedEvent("ExecutedCommand", RoutingStrategy.Bubble, typeof(EventHandler<ExecutedCommandEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a command is executed
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutedCommand"/>
		/// <seealso cref="ExecutedCommandEvent"/>
		/// <seealso cref="ExecutedCommandEventArgs"/>
		protected virtual void OnExecutedCommand(ExecutedCommandEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.ExecutedCommandDirect != null)
				this.ExecutedCommandDirect(this, args);
		}

		internal void RaiseExecutedCommand(ExecutedCommandEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.ExecutedCommandEvent;
			args.Source = this;
			this.OnExecutedCommand(args);
		}

		/// <summary>
		/// Occurs after a command is executed
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnExecutedCommand"/>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutedCommandEvent"/>
		/// <seealso cref="ExecutedCommandEventArgs"/>
		//[Description("Occurs after a command is performed")]
		//[Category("Behavior")]
		public event EventHandler<ExecutedCommandEventArgs> ExecutedCommand
		{
			add
			{
				base.AddHandler(DataPresenterBase.ExecutedCommandEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.ExecutedCommandEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs after a command is executed
		/// </summary>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnExecutedCommand"/>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutedCommandEventArgs"/>
		public event EventHandler<ExecutedCommandEventArgs> ExecutedCommandDirect;

		#endregion //ExecutedCommand

		#region FieldChooserOpening

		// SSP 6/3/09 - NAS9.2 Field Chooser
		// 

		/// <summary>
		/// Event ID for the <see cref="FieldChooserOpening"/> routed event
		/// </summary>
		/// <seealso cref="FieldChooserOpening"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public static readonly RoutedEvent FieldChooserOpeningEvent =
			EventManager.RegisterRoutedEvent( "FieldChooserOpening", RoutingStrategy.Bubble,
				typeof( EventHandler<FieldChooserOpeningEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before the data presenter displays a FieldChooser.
		/// </summary>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		protected virtual void OnFieldChooserOpening( FieldChooserOpeningEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseFieldChooserOpening( FieldChooserOpeningEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.FieldChooserOpeningEvent;
			args.Source = this;
			this.OnFieldChooserOpening( args );
		}

		/// <summary>
		/// Raised before the data presenter displays a FieldChooser.
		/// </summary>
		/// <seealso cref="FieldChooserOpening"/>
		/// <seealso cref="ShowFieldChooser(FieldLayout,bool,bool,string)"/>
		//[Description( "Raised before the data presenter displays a FieldChooser" )]
		//[Category( "Behavior" )]
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public event EventHandler<FieldChooserOpeningEventArgs> FieldChooserOpening
		{
			add
			{
				base.AddHandler( FieldChooserOpeningEvent, value );
			}
			remove
			{
				base.RemoveHandler( FieldChooserOpeningEvent, value );
			}
		}

		#endregion // FieldChooserOpening

		#region FieldLayoutInitializing

		/// <summary>
		/// Event ID for the <see cref="FieldLayoutInitializing"/> routed event
		/// </summary>
		public static readonly RoutedEvent FieldLayoutInitializingEvent =
			EventManager.RegisterRoutedEvent("FieldLayoutInitializing", RoutingStrategy.Bubble, typeof(EventHandler<FieldLayoutInitializingEventArgs>), typeof(DataPresenterBase));

		internal void RaiseFieldLayoutInitializingEvent(FieldLayout layout)
		{
			FieldLayoutInitializingEventArgs args = new FieldLayoutInitializingEventArgs(layout);
			args.RoutedEvent = DataPresenterBase.FieldLayoutInitializingEvent;
			args.Source = this;
			this.OnFieldLayoutInitializing(args);
		}

		/// <summary>
		/// Occurs before a <see cref="FieldLayout"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="FieldLayoutInitialized"/>
		/// <seealso cref="FieldLayoutInitializingEvent"/>
		/// <seealso cref="FieldLayoutInitializedEvent"/>
		protected virtual void OnFieldLayoutInitializing(FieldLayoutInitializingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		/// <summary>
		/// Occurs before a <see cref="FieldLayout"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="FieldLayoutInitialized"/>
		/// <seealso cref="FieldLayoutInitializingEvent"/>
		/// <seealso cref="FieldLayoutInitializedEvent"/>
		//[Description("Occurs when a FieldLayout object is being initialized")]
		//[Category("Behavior")]
		public event EventHandler<FieldLayoutInitializingEventArgs> FieldLayoutInitializing
		{
			add
			{
				base.AddHandler(DataPresenterBase.FieldLayoutInitializingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.FieldLayoutInitializingEvent, value);
			}
		}

		#endregion //FieldLayoutInitializing

		#region FieldLayoutInitialized

		/// <summary>
		/// Event ID for the <see cref="FieldLayoutInitialized"/> routed event
		/// </summary>
		public static readonly RoutedEvent FieldLayoutInitializedEvent =
			EventManager.RegisterRoutedEvent("FieldLayoutInitialized", RoutingStrategy.Bubble, typeof(EventHandler<FieldLayoutInitializedEventArgs>), typeof(DataPresenterBase));

		internal void RaiseFieldLayoutInitializedEvent(FieldLayout layout)
		{
			FieldLayoutInitializedEventArgs args = new FieldLayoutInitializedEventArgs(layout);
			args.RoutedEvent = DataPresenterBase.FieldLayoutInitializedEvent;
			args.Source = this;
			this.OnFieldLayoutInitialized(args);
		}

		/// <summary>
		/// Occurs after a FieldLayout has been initialized
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="FieldLayoutInitializing"/>
		/// <seealso cref="FieldLayoutInitializingEvent"/>
		/// <seealso cref="FieldLayoutInitializedEvent"/>
		protected virtual void OnFieldLayoutInitialized(FieldLayoutInitializedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		/// <summary>
		/// Occurs after a <see cref="FieldLayout"/> has been initialized
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="FieldLayoutInitializing"/>
		/// <seealso cref="FieldLayoutInitializingEvent"/>
		/// <seealso cref="FieldLayoutInitializedEvent"/>
		//[Description("Occurs after a FieldLayout object has been initialized")]
		//[Category("Behavior")]
		public event EventHandler<FieldLayoutInitializedEventArgs> FieldLayoutInitialized
		{
			add
			{
				base.AddHandler(DataPresenterBase.FieldLayoutInitializedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.FieldLayoutInitializedEvent, value);
			}
		}

		#endregion //FieldLayoutInitialized

		#region FieldPositionChanged

		
		
		/// <summary>
		/// Event ID for the <see cref="FieldPositionChanged"/> routed event
		/// </summary>
		/// <seealso cref="FieldPositionChanged"/>
		/// <seealso cref="OnFieldPositionChanged"/>
		/// <seealso cref="FieldPositionChangedEventArgs"/>
		public static readonly RoutedEvent FieldPositionChangedEvent =
			EventManager.RegisterRoutedEvent( "FieldPositionChanged", RoutingStrategy.Bubble, typeof( EventHandler<FieldPositionChangedEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised after a field is moved by dragging and dropping it at a different position
		/// in the field layout.
		/// </summary>
		/// <seealso cref="FieldPositionChanged"/>
		protected virtual void OnFieldPositionChanged( FieldPositionChangedEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseFieldPositionChanged( FieldPositionChangedEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.FieldPositionChangedEvent;
			args.Source = this;
			this.OnFieldPositionChanged( args );
		}

		/// <summary>
		/// Occurs after a field is moved by dragging and dropping it at a different position
		/// in the field layout.
		/// </summary>
		/// <remarks>
		/// <b>FieldPositionChanged</b> is raised after a field is moved by dragging and 
		/// dropping it at a different position in the field layout.
		/// </remarks>
		/// <seealso cref="OnFieldPositionChanged"/>
		/// <seealso cref="DataPresenterBase.FieldPositionChanged"/>
		//[Description( "Occurs when a field is repositioned via drag-and-drop." )]
		//[Category( "Behavior" )]
		public event EventHandler<FieldPositionChangedEventArgs> FieldPositionChanged
		{
			add
			{
				base.AddHandler( DataPresenterBase.FieldPositionChangedEvent, value );
			}
			remove
			{
				base.RemoveHandler( DataPresenterBase.FieldPositionChangedEvent, value );
			}
		}

		#endregion //FieldPositionChanged

		#region FieldPositionChanging

		
		
		/// <summary>
		/// Event ID for the <see cref="FieldPositionChanging"/> routed event
		/// </summary>
		/// <seealso cref="FieldPositionChanging"/>
		/// <seealso cref="OnFieldPositionChanging"/>
		/// <seealso cref="FieldPositionChangingEventArgs"/>
		public static readonly RoutedEvent FieldPositionChangingEvent =
			EventManager.RegisterRoutedEvent( "FieldPositionChanging", RoutingStrategy.Bubble, typeof( EventHandler<FieldPositionChangingEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised when a field is moved by dragging and dropping it at a different position
		/// in the field layout.
		/// </summary>
		/// <seealso cref="FieldPositionChanging"/>
		protected virtual void OnFieldPositionChanging( FieldPositionChangingEventArgs args )
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseFieldPositionChanging( FieldPositionChangingEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.FieldPositionChangingEvent;
			args.Source = this;
			this.OnFieldPositionChanging( args );
		}

		/// <summary>
		/// Occurs when a field is moved by dragging and dropping it at a different position
		/// in the field layout.
		/// </summary>
		/// <remarks>
		/// <b>FieldPositionChanging</b> is raised when a field is moved by dragging and 
		/// dropping it at a different position in the field layout.
		/// </remarks>
		/// <seealso cref="OnFieldPositionChanging"/>
		/// <seealso cref="DataPresenterBase.FieldPositionChanged"/>
		//[Description( "Occurs when a field is repositioned via drag-and-drop." )]
		//[Category( "Behavior" )]
		public event EventHandler<FieldPositionChangingEventArgs> FieldPositionChanging
		{
			add
			{
				base.AddHandler( DataPresenterBase.FieldPositionChangingEvent, value );
			}
			remove
			{
				base.RemoveHandler( DataPresenterBase.FieldPositionChangingEvent, value );
			}
		}

		#endregion //FieldPositionChanging

		#region Grouping

		/// <summary>
		/// Event ID for the <see cref="Grouping"/> routed event
		/// </summary>
		/// <seealso cref="Grouping"/>
		/// <seealso cref="OnGrouping"/>
		/// <seealso cref="GroupingEventArgs"/>
		public static readonly RoutedEvent GroupingEvent =
			EventManager.RegisterRoutedEvent("Grouping", RoutingStrategy.Bubble, typeof(EventHandler<GroupingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when records are about to be grouped as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="FieldSortDescription.IsGroupBy"/>
		/// <seealso cref="Grouping"/>
		/// <seealso cref="GroupingEvent"/>
		/// <seealso cref="GroupingEventArgs"/>
		protected virtual void OnGrouping(GroupingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseGrouping(GroupingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.GroupingEvent;
			args.Source = this;
			this.OnGrouping(args);
		}

		/// <summary>
		/// Occurs when records are about to be grouped as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
		/// </remarks>
		/// <seealso cref="OnGrouping"/>
		/// <seealso cref="Grouped"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="FieldSortDescription.IsGroupBy"/>
		/// <seealso cref="GroupingEvent"/>
		/// <seealso cref="GroupingEventArgs"/>
		//[Description("Occurs when records are about to be grouped as the result of a user action.")]
		//[Category("Behavior")]
		public event EventHandler<GroupingEventArgs> Grouping
		{
			add
			{
				base.AddHandler(DataPresenterBase.GroupingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.GroupingEvent, value);
			}
		}

		#endregion //Grouping

		#region Grouped

		/// <summary>
		/// Event ID for the <see cref="Grouped"/> routed event
		/// </summary>
		/// <seealso cref="Grouped"/>
		/// <seealso cref="OnGrouped"/>
		/// <seealso cref="GroupedEventArgs"/>
		public static readonly RoutedEvent GroupedEvent =
			EventManager.RegisterRoutedEvent("Grouped", RoutingStrategy.Bubble, typeof(EventHandler<GroupedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after records have been grouped as the result of a user action.
		/// </summary>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="FieldSortDescription.IsGroupBy"/>
		/// <seealso cref="Grouped"/>
		/// <seealso cref="GroupedEvent"/>
		/// <seealso cref="GroupedEventArgs"/>
		protected virtual void OnGrouped(GroupedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseGrouped(GroupedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.GroupedEvent;
			args.Source = this;
			this.OnGrouped(args);
		}

		/// <summary>
		/// Occurs after records have been grouped as the result of a user action.
		/// </summary>
		/// <seealso cref="OnGrouped"/>
		/// <seealso cref="Grouping"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="FieldSortDescription.IsGroupBy"/>
		/// <seealso cref="GroupedEvent"/>
		/// <seealso cref="GroupedEventArgs"/>
		//[Description("Occurs after records have been grouped as the result of a user action.")]
		//[Category("Behavior")]
		public event EventHandler<GroupedEventArgs> Grouped
		{
			add
			{
				base.AddHandler(DataPresenterBase.GroupedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.GroupedEvent, value);
			}
		}

		#endregion //Grouped

		// JM 6/12/09 NA 2009.2 DataValueChangedEvent
		#region InitializeCellValuePresenter

		/// <summary>
		/// Event ID for the <see cref="InitializeCellValuePresenter"/> routed event
		/// </summary>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="OnInitializeCellValuePresenter"/>
		/// <seealso cref="InitializeCellValuePresenterEventArgs"/>
		/// <seealso cref="CellValuePresenter"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public static readonly RoutedEvent InitializeCellValuePresenterEvent =
			EventManager.RegisterRoutedEvent("InitializeCellValuePresenter", RoutingStrategy.Bubble, typeof(EventHandler<InitializeCellValuePresenterEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Raises the <see cref="InitializeCellValuePresenter"/> event
		/// </summary>
		/// <param name="args">Provides information for the event being raised</param>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="InitializeCellValuePresenterEventArgs"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		protected virtual void OnInitializeCellValuePresenter(InitializeCellValuePresenterEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.InitializeCellValuePresenterDirect != null)
				this.InitializeCellValuePresenterDirect(this, args);
		}

		internal void RaiseInitializeCellValuePresenter(InitializeCellValuePresenterEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.InitializeCellValuePresenterEvent;
			args.Source = this;
			this.OnInitializeCellValuePresenter(args);
		}

		/// <summary>
		/// Occurs when a <see cref="CellValuePresenter"/> element is created or reused to display the value of a <see cref="Cell"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">The <see cref="InitializeCellValuePresenterEventArgs.IsNew"/> property will be set to true if a new instance, or false if this is a recycled instance.</para>
		/// <para class="body">This event is only raised for <see cref="CellValuePresenter"/>s associated with a <see cref="Field"/> whose <see cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/> property has been set to true.</para>
		/// <para></para>
		/// <para class="note">When this event is raised the CellValuePresenter's <see cref="Infragistics.Windows.DataPresenter.CellValuePresenter.ValueHistory"/> 
		///  property will be initialized with a single history entry representing the initial data value for the cell.</para>
		/// </remarks>
		/// <seealso cref="InitializeCellValuePresenter"/>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="OnInitializeCellValuePresenter"/>
		/// <seealso cref="InitializeCellValuePresenterEventArgs"/>
		/// <seealso cref="CellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.CellValuePresenter.ValueHistory"/>
		//[Description("Occurs when a CellValuePresenter element is created or reused to display the value of a Cell.")]
		//[Category("Behavior")]
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_DataValueChangedEvent)]
		public event EventHandler<InitializeCellValuePresenterEventArgs> InitializeCellValuePresenter
		{
			add
			{
				base.AddHandler(DataPresenterBase.InitializeCellValuePresenterEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.InitializeCellValuePresenterEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs when a <see cref="CellValuePresenter"/> element is created or reused to display the value of a <see cref="Cell"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">The <see cref="InitializeCellValuePresenterEventArgs.IsNew"/> property will be set to true if a new instance, or false if this is a recycled instance.</para>
		/// <para class="body">This event is only raised for <see cref="CellValuePresenter"/>s associated with a <see cref="Field"/> whose <see cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/> property has been set to true.</para>
		/// <para></para>
		/// <para class="note">When this event is raised the CellValuePresenter's <see cref="Infragistics.Windows.DataPresenter.CellValuePresenter.ValueHistory"/> 
		///  property will be initialized with a single history entry representing the initial data value for the cell.</para>
		/// </remarks>
		/// <seealso cref="DataValueChanged"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedHistoryLimit"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedNotificationsActive"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.DataValueChangedScope"/>
		/// <seealso cref="OnInitializeCellValuePresenter"/>
		/// <seealso cref="InitializeCellValuePresenterEventArgs"/>
		/// <seealso cref="CellValuePresenter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.CellValuePresenter.ValueHistory"/>
		public event EventHandler<InitializeCellValuePresenterEventArgs> InitializeCellValuePresenterDirect;

		#endregion //InitializeCellValuePresenter

		#region InitializeRecord

		/// <summary>
		/// Event ID for the <see cref="InitializeRecord"/> routed event
		/// </summary>
		public static readonly RoutedEvent InitializeRecordEvent =
			EventManager.RegisterRoutedEvent("InitializeRecord", RoutingStrategy.Bubble, typeof(EventHandler<InitializeRecordEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when a <see cref="Record"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <b>InitializeRecord</b> event is raised.</para>
		/// </remarks>
		/// <para></para>
		/// <para class="note"><b>Note: </b>For <see cref="GroupByRecord"/>s and <see cref="ExpandableFieldRecord"/>s this event is raised as the records are created.</para>
		/// <seealso cref="Records"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="InitializeRecordEvent"/>
		internal protected virtual void OnInitializeRecord(InitializeRecordEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.InitializeRecordDirect != null)
				this.InitializeRecordDirect(this, args);
		}

		/// <summary>
		/// Occurs when a <see cref="Record"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body">Since <see cref="Record"/> is an abstract base class for <see cref="DataRecord"/>, <see cref="GroupByRecord"/> and <see cref="ExpandableFieldRecord"/> you may have to cast the <see cref="InitializeRecordEventArgs"/>'s <see cref="InitializeRecordEventArgs.Record"/> property to the appropiate derived class to access specific properties, e.g. the <see cref="DataRecord"/>'s <see cref="DataRecord.Cells"/> collection.</para>
		/// <para></para>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item between the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <b>InitializeRecord</b> event is raised.</para>
		/// <para></para>
		/// <para class="note">For <see cref="GroupByRecord"/>s and <see cref="ExpandableFieldRecord"/>s this event is raised as the records are created.</para>
		/// </remarks>
		/// <seealso cref="Records"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="InitializeRecordEvent"/>
		//[Description("Occurs when a record is initialized")]
		//[Category("Behavior")]
		public event EventHandler<InitializeRecordEventArgs> InitializeRecord
		{
			add
			{
				base.AddHandler(DataPresenterBase.InitializeRecordEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.InitializeRecordEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs when a <see cref="Record"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body">Since <see cref="Record"/> is an abstract base class for <see cref="DataRecord"/>, <see cref="GroupByRecord"/> and <see cref="ExpandableFieldRecord"/> you may have to cast the <see cref="InitializeRecordEventArgs"/>'s <see cref="InitializeRecordEventArgs.Record"/> property to the appropiate derived class to access specific properties, e.g. the <see cref="DataRecord"/>'s <see cref="DataRecord.Cells"/> collection.</para>
		/// <para></para>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item between the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <b>InitializeRecord</b> event is raised.</para>
		/// <para></para>
		/// <para class="note">For <see cref="GroupByRecord"/>s and <see cref="ExpandableFieldRecord"/>s this event is raised as the records are created.</para>
		/// </remarks>
		/// <seealso cref="Records"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AutoGenerateFields"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		public event EventHandler<InitializeRecordEventArgs> InitializeRecordDirect;

		// SSP 3/3/09 TFS11407
		// Added reInitialize parameter. Added code to raise InitializeRecord event 
		// whenever a cell value changes.
		// 
		//internal void RaiseInitializeRecord(Record record)
		// AS 2/11/11 NA 2011.1 Word Writer
		//internal void RaiseInitializeRecord( Record record, bool reInitialize )
		// JJD 11/17/11 - TFS78651 
		// Added sortValueChanged
		//internal virtual void RaiseInitializeRecord( Record record, bool reInitialize )
		internal virtual void RaiseInitializeRecord( Record record, bool reInitialize, bool sortvalueChanged )
		{
			// SSP 12/22/11 TFS67264 - Optimizations
			// This is used to check if we need to raise certain events.
			// 
			// --------------------------------------------------------------------------------------
			if ( !_cachedInitializeRecordEventSuppressed.HasValue )
				_cachedInitializeRecordEventSuppressed = this.IsEventSuppressed( InitializeRecordEvent );

			if ( _cachedInitializeRecordEventSuppressed.Value && !_isDerived && null == this.InitializeRecordDirect )
				return;
			// --------------------------------------------------------------------------------------

            // JJD 9/3/09
            // We shouldn't be calling this method for HeaderRecords but if we
            // do then prevent the event from being raised here.
            if (record is HeaderRecord)
                return;

			// SSP 3/3/09 TFS11407
			// Since now we will be raising InitializeRecord when a cell value changes, we
			// need to have anti-recursion mechanism so setting cell values from within
			// InitializeRecord doesn't cause InitializeRecord to get raised again 
			// recursively.
			// 
			bool alreadySuspended = this.SuspendInitializeRecordFor( record );
			if ( alreadySuspended )
				return;

			try
			{
				
				
				
				// JJD 11/17/11 - TFS78651 
				// Added sortValueChanged
				//InitializeRecordEventArgs args = new InitializeRecordEventArgs( record, reInitialize );
				InitializeRecordEventArgs args = new InitializeRecordEventArgs( record, reInitialize, sortvalueChanged);

				args.RoutedEvent = DataPresenterBase.InitializeRecordEvent;
				args.Source = this;
				this.OnInitializeRecord( args );
			}
			finally
			{
				this.ResumeInitializeRecordFor( record );
			}
		}

		#endregion //InitializeRecord

		#region InitializeTemplateAddRecord

		/// <summary>
		/// Event ID for the <see cref="InitializeTemplateAddRecord"/> routed event
		/// </summary>
		public static readonly RoutedEvent InitializeTemplateAddRecordEvent =
			EventManager.RegisterRoutedEvent("InitializeTemplateAddRecord", RoutingStrategy.Bubble, typeof(EventHandler<InitializeTemplateAddRecordEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when a 'template add' <see cref="DataRecord"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body">Adding new records is disabled by default and is not supported by all views, e.g. <see cref="CarouselView"/> does not support adding records directly so its <see cref="CarouselView.IsAddNewRecordSupported"/> returns false. 
		/// Also, the <see cref="DataSource"/> needs to support adding records. This can be determined by checking the <see cref="RecordManager"/>'s <see cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/> property.</para>
		/// <para></para>
		/// <para class="body">To enable adding records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The location of the add record is specified via the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/> property. These template add records are included in the <see cref="ViewableRecords"/> collection.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="ViewableRecords"/>
		/// <seealso cref="ViewableRecordCollection"/>
		/// <seealso cref="Record.ViewableChildRecords"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="InitializeTemplateAddRecordEvent"/>
		internal protected virtual void OnInitializeTemplateAddRecord(InitializeTemplateAddRecordEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		/// <summary>
		/// Occurs when a 'template add' <see cref="DataRecord"/> is initialized
		/// </summary>
		/// <remarks>
		/// <para class="body">Adding new records is disabled by default and is not supported by all views, e.g. <see cref="CarouselView"/> does not support adding records directly so its <see cref="CarouselView.IsAddNewRecordSupported"/> returns false. 
		/// Also, the <see cref="DataSource"/> needs to support adding records. This can be determined by checking the <see cref="RecordManager"/>'s <see cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/> property.</para>
		/// <para></para>
		/// <para class="body">To enable adding records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The location of the add record is specified via the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/> property. These template add records are included in the <see cref="ViewableRecords"/> collection.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="ViewableRecords"/>
		/// <seealso cref="ViewableRecordCollection"/>
		/// <seealso cref="Record.ViewableChildRecords"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="InitializeTemplateAddRecordEvent"/>
		//[Description("Occurs when a template add DataRecord is initialized")]
		//[Category("Behavior")]
		public event EventHandler<InitializeTemplateAddRecordEventArgs> InitializeTemplateAddRecord
		{
			add
			{
				base.AddHandler(DataPresenterBase.InitializeTemplateAddRecordEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.InitializeTemplateAddRecordEvent, value);
			}
		}

		internal void RaiseInitializeTemplateAddRecord(DataRecord record)
		{
			InitializeTemplateAddRecordEventArgs args = new InitializeTemplateAddRecordEventArgs(record);
			args.RoutedEvent = DataPresenterBase.InitializeTemplateAddRecordEvent;
			args.Source = this;
			this.OnInitializeTemplateAddRecord(args);
		}

		#endregion //InitializeTemplateAddRecord

		#region RecordActivated

		/// <summary>
		/// Event ID for the <see cref="RecordActivated"/> routed event
		/// </summary>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="OnRecordActivated"/>
		/// <seealso cref="RecordActivatedEventArgs"/>
		public static readonly RoutedEvent RecordActivatedEvent =
			EventManager.RegisterRoutedEvent("RecordActivated", RoutingStrategy.Bubble, typeof(EventHandler<RecordActivatedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordActivatedEvent"/>
		/// <seealso cref="RecordActivatedEventArgs"/>
		protected virtual void OnRecordActivated(RecordActivatedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.RecordActivatedDirect != null)
				this.RecordActivatedDirect(this, args);
		}

		internal void RaiseRecordActivated(RecordActivatedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordActivatedEvent;
			args.Source = this;
			this.OnRecordActivated(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordActivated"/>
		/// <seealso cref="RecordActivatedEvent"/>
		/// <seealso cref="RecordActivatedEventArgs"/>
		//[Description("Occurs beford a Record is activated")]
		//[Category("Behavior")]
		public event EventHandler<RecordActivatedEventArgs> RecordActivated
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordActivatedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordActivatedEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs after a <see cref="Record"/> has been made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordActivated"/>
		/// <seealso cref="RecordActivatedEventArgs"/>
		public event EventHandler<RecordActivatedEventArgs> RecordActivatedDirect;

		#endregion //RecordActivated

		#region RecordActivating

		/// <summary>
		/// Event ID for the <see cref="RecordActivating"/> routed event
		/// </summary>
		/// <seealso cref="RecordActivating"/>
		/// <seealso cref="OnRecordActivating"/>
		/// <seealso cref="RecordActivatingEventArgs"/>
		public static readonly RoutedEvent RecordActivatingEvent =
			EventManager.RegisterRoutedEvent("RecordActivating", RoutingStrategy.Bubble, typeof(EventHandler<RecordActivatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Record"/> is made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="RecordActivating"/>
		/// <seealso cref="RecordActivatingEvent"/>
		/// <seealso cref="RecordActivatingEventArgs"/>
		protected virtual void OnRecordActivating(RecordActivatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.RecordActivatingDirect != null)
				this.RecordActivatingDirect(this, args);
		}

		internal void RaiseRecordActivating(RecordActivatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordActivatingEvent;
			args.Source = this;
			this.OnRecordActivating(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Record"/> is made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordActivating"/>
		/// <seealso cref="RecordActivatingEvent"/>
		/// <seealso cref="RecordActivatingEventArgs"/>
		//[Description("Occurs beford a Record is activated")]
		//[Category("Behavior")]
		public event EventHandler<RecordActivatingEventArgs> RecordActivating
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordActivatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordActivatingEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs before a <see cref="Record"/> is made the <see cref="ActiveRecord"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordActivating"/>
		/// <seealso cref="RecordActivatingEventArgs"/>
		public event EventHandler<RecordActivatingEventArgs> RecordActivatingDirect;

		#endregion //RecordActivating

		#region RecordAdding

		/// <summary>
		/// Event ID for the <see cref="RecordAdding"/> routed event
		/// </summary>
		/// <seealso cref="RecordAdding"/>
		/// <seealso cref="OnRecordAdding"/>
		/// <seealso cref="RecordAddingEventArgs"/>
		public static readonly RoutedEvent RecordAddingEvent =
			EventManager.RegisterRoutedEvent("RecordAdding", RoutingStrategy.Bubble, typeof(EventHandler<RecordAddingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the first edit of a template add record is made but before an item has been added to the <see cref="DataSource"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">As soon as the user types the first character while in edit mode of a cell in a template add record this event will be raised. If this event is not cancelled then the <see cref="System.ComponentModel.IBindingList"/>.<see cref="System.ComponentModel.IBindingList.AddNew"/> method will be called on the <see cref="DataSource"/> followed by the <see cref="RecordAdded"/> event.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If this event is cancelled by setting the <see cref="RecordAddingEventArgs"/>'s <see cref="CancelableRoutedEventArgs.Cancel"/> property to true then the <see cref="ActiveCell"/> will be forced out of edit mode and the changes discarded.</para>
		/// </remarks>
		/// <seealso cref="InitializeTemplateAddRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="RecordAdding"/>
		/// <seealso cref="RecordAddingEvent"/>
		/// <seealso cref="RecordAddingEventArgs"/>
		protected virtual void OnRecordAdding(RecordAddingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordAdding(RecordAddingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordAddingEvent;
			args.Source = this;
			this.OnRecordAdding(args);
		}

		/// <summary>
		/// Occurs when the first edit of a template add record is made but before an item has been added to the <see cref="DataSource"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">As soon as the user types the first character while in edit mode of a cell in a template add record this event will be raised. If this event is not cancelled then the <see cref="System.ComponentModel.IBindingList"/>.<see cref="System.ComponentModel.IBindingList.AddNew"/> method will be called on the <see cref="DataSource"/> followed by the <see cref="RecordAdded"/> event.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If this event is cancelled by setting the <see cref="RecordAddingEventArgs"/>'s <see cref="CancelableRoutedEventArgs.Cancel"/> property to true then the <see cref="ActiveCell"/> will be forced out of edit mode and the changes discarded.</para>
		/// </remarks>
		/// <seealso cref="InitializeTemplateAddRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="OnRecordAdding"/>
		/// <seealso cref="RecordAdded"/>
		/// <seealso cref="RecordAddingEvent"/>
		/// <seealso cref="RecordAddingEventArgs"/>
		//[Description("Occurs when a record is about to be added.")]
		//[Category("Data")]
		public event EventHandler<RecordAddingEventArgs> RecordAdding
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordAddingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordAddingEvent, value);
			}
		}

		#endregion //RecordAdding

		#region RecordAdded

		/// <summary>
		/// Event ID for the <see cref="RecordAdded"/> routed event
		/// </summary>
		/// <seealso cref="RecordAdded"/>
		/// <seealso cref="OnRecordAdded"/>
		/// <seealso cref="RecordAddedEventArgs"/>
		public static readonly RoutedEvent RecordAddedEvent =
			EventManager.RegisterRoutedEvent("RecordAdded", RoutingStrategy.Bubble, typeof(EventHandler<RecordAddedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the first edit of a template add record is made and after an item has been added to the <see cref="DataSource"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">As soon as the user types the first character while in edit mode of a cell in a template add record the <see cref="RecordAdding"/> event will be raised. If this event is not cancelled then the <see cref="System.ComponentModel.IBindingList"/>.<see cref="System.ComponentModel.IBindingList.AddNew"/> method will be called on the <see cref="DataSource"/> followed by the <b>RecordAdded</b> event.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the <see cref="RecordAdding"/> event is cancelled by setting the <see cref="RecordAddingEventArgs"/>'s <see cref="CancelableRoutedEventArgs.Cancel"/> property to true then the <see cref="ActiveCell"/> will be forced out of edit mode and the changes discarded.</para>
		/// </remarks>
		/// <seealso cref="InitializeTemplateAddRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="RecordAdded"/>
		/// <seealso cref="RecordAddedEvent"/>
		/// <seealso cref="RecordAddedEventArgs"/>
		protected virtual void OnRecordAdded(RecordAddedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordAdded(RecordAddedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordAddedEvent;
			args.Source = this;
			this.OnRecordAdded(args);
		}

		/// <summary>
		/// Occurs when the first edit of a template add record is made and after an item has been added to the <see cref="DataSource"/>.
		/// </summary>
		/// <remarks>
		/// <para class="body">As soon as the user types the first character while in edit mode of a cell in a template add record the <see cref="RecordAdding"/> event will be raised. If this event is not cancelled then the <see cref="System.ComponentModel.IBindingList"/>.<see cref="System.ComponentModel.IBindingList.AddNew"/> method will be called on the <see cref="DataSource"/> followed by the <b>RecordAdded</b> event.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the <see cref="RecordAdding"/> event is cancelled by setting the <see cref="RecordAddingEventArgs"/>'s <see cref="CancelableRoutedEventArgs.Cancel"/> property to true then the <see cref="ActiveCell"/> will be forced out of edit mode and the changes discarded.</para>
		/// </remarks>
		/// <seealso cref="InitializeTemplateAddRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsAddNew"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsAddRecord"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowAddNew"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AddNewRecordLocation"/>
		/// <seealso cref="OnRecordAdded"/>
		/// <seealso cref="RecordAdding"/>
		/// <seealso cref="RecordAddedEvent"/>
		/// <seealso cref="RecordAddedEventArgs"/>
		//[Description("Occurs after a record has been added.")]
		//[Category("Data")]
		public event EventHandler<RecordAddedEventArgs> RecordAdded
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordAddedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordAddedEvent, value);
			}
		}

		#endregion //RecordAdded

		#region RecordCollapsed

		/// <summary>
		/// Event ID for the <see cref="RecordCollapsed"/> routed event
		/// </summary>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="OnRecordCollapsed"/>
		/// <seealso cref="RecordCollapsedEventArgs"/>
		public static readonly RoutedEvent RecordCollapsedEvent =
			EventManager.RegisterRoutedEvent("RecordCollapsed", RoutingStrategy.Bubble, typeof(EventHandler<RecordCollapsedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been collapsed
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can collapse an expanded record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to false.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be collapsed by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.CollapseRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordCollapsedEvent"/>
		/// <seealso cref="RecordCollapsedEventArgs"/>
		protected virtual void OnRecordCollapsed(RecordCollapsedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordCollapsed(RecordCollapsedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordCollapsedEvent;
			args.Source = this;
			this.OnRecordCollapsed(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been collapsed
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can collapse an expanded record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to false.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be collapsed by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.CollapseRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="OnRecordCollapsed"/>
		/// <seealso cref="RecordCollapsedEvent"/>
		/// <seealso cref="RecordCollapsedEventArgs"/>
		//[Description("Occurs beford a Record is collapsed")]
		//[Category("Behavior")]
		public event EventHandler<RecordCollapsedEventArgs> RecordCollapsed
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordCollapsedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordCollapsedEvent, value);
			}
		}

		#endregion //RecordCollapsed

		#region RecordCollapsing

		/// <summary>
		/// Event ID for the <see cref="RecordCollapsing"/> routed event
		/// </summary>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="OnRecordCollapsing"/>
		/// <seealso cref="RecordCollapsingEventArgs"/>
		public static readonly RoutedEvent RecordCollapsingEvent =
			EventManager.RegisterRoutedEvent("RecordCollapsing", RoutingStrategy.Bubble, typeof(EventHandler<RecordCollapsingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Record"/> is collapsed
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can collapse an expanded record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to false.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be collapsed by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.CollapseRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="RecordCollapsingEvent"/>
		/// <seealso cref="RecordCollapsingEventArgs"/>
		protected virtual void OnRecordCollapsing(RecordCollapsingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordCollapsing(RecordCollapsingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordCollapsingEvent;
			args.Source = this;
			this.OnRecordCollapsing(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Record"/> is collapsed
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can collapse an expanded record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to false.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be collapsed by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.CollapseRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="OnRecordCollapsing"/>
		/// <seealso cref="RecordCollapsingEvent"/>
		/// <seealso cref="RecordCollapsingEventArgs"/>
		//[Description("Occurs beford a Record is collapsed")]
		//[Category("Behavior")]
		public event EventHandler<RecordCollapsingEventArgs> RecordCollapsing
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordCollapsingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordCollapsingEvent, value);
			}
		}

		#endregion //RecordCollapsing

		#region RecordDeactivating

		/// <summary>
		/// Event ID for the <see cref="RecordDeactivating"/> routed event
		/// </summary>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="OnRecordDeactivating"/>
		/// <seealso cref="RecordDeactivatingEventArgs"/>
		public static readonly RoutedEvent RecordDeactivatingEvent =
			EventManager.RegisterRoutedEvent("RecordDeactivating", RoutingStrategy.Bubble, typeof(EventHandler<RecordDeactivatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before the <see cref="ActiveRecord"/> is being cleared
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="RecordDeactivatingEvent"/>
		/// <seealso cref="RecordDeactivatingEventArgs"/>
		protected virtual void OnRecordDeactivating(RecordDeactivatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.RecordDeactivatingDirect != null)
				this.RecordDeactivatingDirect(this, args);
		}

		internal void RaiseRecordDeactivating(RecordDeactivatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordDeactivatingEvent;
			args.Source = this;
			this.OnRecordDeactivating(args);
		}

		/// <summary>
		/// Occurs before the <see cref="ActiveRecord"/> is being cleared
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordDeactivating"/>
		/// <seealso cref="RecordDeactivatingEvent"/>
		/// <seealso cref="RecordDeactivatingEventArgs"/>
		//[Description("Occurs beford a Record is activated")]
		//[Category("Behavior")]
		public event EventHandler<RecordDeactivatingEventArgs> RecordDeactivating
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordDeactivatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordDeactivatingEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs before the <see cref="ActiveRecord"/> is being cleared
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="EditModeEnding"/>
		/// <seealso cref="EditModeEnded"/>
		/// <seealso cref="OnRecordDeactivating"/>
		/// <seealso cref="RecordDeactivatingEventArgs"/>
		public event EventHandler<RecordDeactivatingEventArgs> RecordDeactivatingDirect;

		#endregion //RecordDeactivating

		#region RecordFilterChanged

		// SSP 12/12/08 - NAS9.1 Record Filtering
		// 

		/// <summary>
		/// Event ID for the <see cref="RecordFilterChanged"/> routed event
		/// </summary>
		/// <seealso cref="RecordFilterChanged"/>
		public static readonly RoutedEvent RecordFilterChangedEvent =
			EventManager.RegisterRoutedEvent( "RecordFilterChanged", RoutingStrategy.Bubble,
				typeof( EventHandler<RecordFilterChangedEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before any record filter criteria modifications by the user are applied.
		/// </summary>
		/// <seealso cref="RecordFilterChanged"/>
		protected virtual void OnRecordFilterChanged( RecordFilterChangedEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFilterChanged( RecordFilterChangedEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.RecordFilterChangedEvent;
			args.Source = this;
			this.OnRecordFilterChanged( args );
		}

		/// <summary>
		/// Raised when the user changes record filter criteria.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>RecordFilterChanged</b> is raised whenever the user enters new or modifies existing record filtering 
		/// criteria. This event is raised after the modified criteria is applied.
		/// </para>
		/// </remarks>
		/// <seealso cref="RecordFilterChanging"/>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>
		//[Description( "Raised when the user changes record filter criteria." )]
		//[Category( "Behavior" )]
		public event EventHandler<RecordFilterChangedEventArgs> RecordFilterChanged
		{
			add
			{
				base.AddHandler( RecordFilterChangedEvent, value );
			}
			remove
			{
				base.RemoveHandler( RecordFilterChangedEvent, value );
			}
		}

		#endregion // RecordFilterChanged

		#region RecordFilterChanging

		// SSP 12/12/08 - NAS9.1 Record Filtering
		// 

		/// <summary>
		/// Event ID for the <see cref="RecordFilterChanging"/> routed event
		/// </summary>
		/// <seealso cref="RecordFilterChanging"/>
		public static readonly RoutedEvent RecordFilterChangingEvent =
			EventManager.RegisterRoutedEvent( "RecordFilterChanging", RoutingStrategy.Bubble,
				typeof( EventHandler<RecordFilterChangingEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before any record filter criteria modifications by the user are applied.
		/// </summary>
		/// <seealso cref="RecordFilterChanging"/>
		protected virtual void OnRecordFilterChanging( RecordFilterChangingEventArgs args )
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFilterChanging( RecordFilterChangingEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.RecordFilterChangingEvent;
			args.Source = this;
			this.OnRecordFilterChanging( args );
		}

		/// <summary>
		/// Raised when the user changes record filter criteria.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>RecordFilterChanging</b> is raised whenever the user enters new or modifies existing record filtering 
		/// criteria. This event is raised right before the modified criteria is applied.
		/// </para>
		/// <para class="body">
		/// Note that you can cancel this event in which case the user modifications to the filter criteria will be discarded.
		/// Filter criteria will revert back to original filter criteria if any.
		/// </para>
		/// </remarks>
		/// <seealso cref="RecordFilterChanged"/>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>
		//[Description( "Raised when the user changes record filter criteria." )]
		//[Category( "Behavior" )]
		public event EventHandler<RecordFilterChangingEventArgs> RecordFilterChanging
		{
			add
			{
				base.AddHandler( RecordFilterChangingEvent, value );
			}
			remove
			{
				base.RemoveHandler( RecordFilterChangingEvent, value );
			}
		}

		#endregion // RecordFilterChanging

		// JJD 02/21/12 - TFS99332 - added
		#region RecordFilterDropDownItemInitializing

		/// <summary>
		/// Event ID for the <see cref="RecordFilterDropDownItemInitializing"/> routed event
		/// </summary>
		/// <seealso cref="RecordFilterDropDownItemInitializing"/>
		public static readonly RoutedEvent RecordFilterDropDownItemInitializingEvent =
			EventManager.RegisterRoutedEvent( "RecordFilterDropDownItemInitializing", RoutingStrategy.Bubble,
				typeof( EventHandler<RecordFilterDropDownItemInitializingEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Occurs when a record filter drop-down is being initialized.
		/// </summary>
		/// <remarks>
		/// <para class="note">
		/// <b>Note:</b> this event will only get raised when a filter condition is specified in code when the <see cref="FilterUIType"/> is set to 'Default' or 'FilterRecord' on FieldLayoutSettings. This allows the DisplayText and/or Image 
		/// of the FilterDrapDownItem to be modified before the item if displayed in the filter cell.
		/// </para>
		/// </remarks>
		/// <seealso cref="RecordFilterDropDownItemInitializing"/>
		protected virtual void OnRecordFilterDropDownItemInitializing( RecordFilterDropDownItemInitializingEventArgs args )
		{
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFilterDropDownItemInitializing( RecordFilterDropDownItemInitializingEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.RecordFilterDropDownItemInitializingEvent;
			args.Source = this;
			this.OnRecordFilterDropDownItemInitializing( args );
		}

		/// <summary>
		/// Occurs when a record filter drop-down is being initialized.
		/// </summary>
		/// <remarks>
		/// <para class="note">
		/// <b>Note:</b> this event will only get raised when a filter condition is specified in code when the <see cref="FilterUIType"/> is set to 'Default' or 'FilterRecord' on FieldLayoutSettings. This allows the DisplayText and/or Image 
		/// of the FilterDrapDownItem to be modified before the item if displayed in the filter cell.
		/// </para>
		/// </remarks>
		public event EventHandler<RecordFilterDropDownItemInitializingEventArgs> RecordFilterDropDownItemInitializing
		{
			add
			{
				base.AddHandler( RecordFilterDropDownItemInitializingEvent, value );
			}
			remove
			{
				base.RemoveHandler( RecordFilterDropDownItemInitializingEvent, value );
			}
		}

		#endregion // RecordFilterDropDownItemInitializing

		#region RecordFilterDropDownOpening

		// SSP 12/12/08 - NAS9.1 Record Filtering
		// 

		/// <summary>
		/// Event ID for the <see cref="RecordFilterDropDownOpening"/> routed event
		/// </summary>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		public static readonly RoutedEvent RecordFilterDropDownOpeningEvent =
			EventManager.RegisterRoutedEvent( "RecordFilterDropDownOpening", RoutingStrategy.Bubble,
				typeof( EventHandler<RecordFilterDropDownOpeningEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before record filter drop-down is opened but after <see cref="RecordFilterDropDownPopulating"/> event.
		/// </summary>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		protected virtual void OnRecordFilterDropDownOpening( RecordFilterDropDownOpeningEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFilterDropDownOpening( RecordFilterDropDownOpeningEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.RecordFilterDropDownOpeningEvent;
			args.Source = this;
			this.OnRecordFilterDropDownOpening( args );
		}

		/// <summary>
		/// Raised before record filter drop-down is opened but after <see cref="RecordFilterDropDownPopulating"/> event.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>RecordFilterDropDownOpening</b> is raised whenever the user drops down the filter drop-down in a filter cell
		/// or via the filter icon of a field label (see <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>).
		/// You can manipulate the list of items that will be displayed in the filter drop-down using the 
		/// <see cref="RecordFilterDropDownOpeningEventArgs.DropDownItems"/> property of the event args. 
		/// Also note that the <see cref="RecordFilterDropDownPopulating"/> is raised before this event.
		/// </para>
		/// </remarks>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>
		//[Description( "Raised before the filter drop-down is displayed." )]
		//[Category( "Behavior" )]
		public event EventHandler<RecordFilterDropDownOpeningEventArgs> RecordFilterDropDownOpening
		{
			add
			{
				base.AddHandler( RecordFilterDropDownOpeningEvent, value );
			}
			remove
			{
				base.RemoveHandler( RecordFilterDropDownOpeningEvent, value );
			}
		}

		#endregion // RecordFilterDropDownOpening

		#region RecordFilterDropDownPopulating

		// SSP 12/12/08 - NAS9.1 Record Filtering
		// 

		/// <summary>
		/// Event ID for the <see cref="RecordFilterDropDownPopulating"/> routed event
		/// </summary>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		public static readonly RoutedEvent RecordFilterDropDownPopulatingEvent =
			EventManager.RegisterRoutedEvent( "RecordFilterDropDownPopulating", RoutingStrategy.Bubble,
				typeof( EventHandler<RecordFilterDropDownPopulatingEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before record filter drop-down is opened but after <see cref="RecordFilterDropDownPopulating"/> event.
		/// </summary>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		protected virtual void OnRecordFilterDropDownPopulating( RecordFilterDropDownPopulatingEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFilterDropDownPopulating( RecordFilterDropDownPopulatingEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.RecordFilterDropDownPopulatingEvent;
			args.Source = this;
			this.OnRecordFilterDropDownPopulating( args );
		}

		/// <summary>
		/// Raised before the filter drop-down is populated by the data presenter, giving you a chance to populate 
		/// the filter drop-down with your own items.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>RecordFilterDropDownPopulating</b> is raised whenever the user drops down the filter drop-down in a filter cell
		/// or via the filter icon of a field label (see <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>).
		/// You can manipulate the list of items that will be displayed in the filter drop-down using the 
		/// <see cref="RecordFilterDropDownPopulatingEventArgs.DropDownItems"/> property of the event args.
		/// </para>
		/// </remarks>
		/// <seealso cref="RecordFilterDropDownPopulating"/>
		/// <seealso cref="RecordFilterDropDownOpening"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/>
		//[Description( "Raised before the filter drop-down is populated by the data presenter." )]
		//[Category( "Behavior" )]
		public event EventHandler<RecordFilterDropDownPopulatingEventArgs> RecordFilterDropDownPopulating
		{
			add
			{
				base.AddHandler( RecordFilterDropDownPopulatingEvent, value );
			}
			remove
			{
				base.RemoveHandler( RecordFilterDropDownPopulatingEvent, value );
			}
		}

		#endregion // RecordFilterDropDownPopulating

		#region RecordsDeleted

		/// <summary>
		/// Event ID for the <see cref="RecordsDeleted"/> routed event
		/// </summary>
		/// <seealso cref="RecordsDeleted"/>
		/// <seealso cref="OnRecordsDeleted"/>
		/// <seealso cref="RecordsDeletedEventArgs"/>
		public static readonly RoutedEvent RecordsDeletedEvent =
			EventManager.RegisterRoutedEvent("RecordsDeleted", RoutingStrategy.Bubble, typeof(EventHandler<RecordsDeletedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after one or more <see cref="DataRecord"/>s has been deleted.
		/// </summary>
		/// <remarks>
		/// <para class="body">Deleting <see cref="DataRecord"/>s is supported for <see cref="DataPresenterBase.DataSource"/>s that implement the <see cref="System.ComponentModel.IBindingList"/> interface and return true from its <see cref="System.ComponentModel.IBindingList.AllowRemove"/> property.  
		/// It is also supported for <see cref="DataPresenterBase.DataSource"/>s that only implement the <see cref="System.Collections.IList"/> interface and return false from both its <see cref="System.Collections.IList.IsReadOnly"/> and <see cref="System.Collections.IList.IsFixedSize"/> properties.</para>
		/// <para></para>
		/// <para class="body">Assuming deleting of <see cref="DataRecord"/>s is enabled then when the user selects one or more <see cref="DataRecord"/>s and presses the <b>Delete</b> key the <see cref="DataPresenterBase.RecordsDeleting"/> and <see cref="DataPresenterBase.RecordsDeleted"/> events will be raised. 
		/// <see cref="DataRecord"/>s can also be deleted programmatically by first selecting them (via the <see cref="Record.IsSelected"/> property or the <see cref="DataPresenterBase.SelectedItems"/> collection) and then calling <see cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands.DeleteSelectedDataRecords"/> command.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>Deleting records is enabled by default. To disable deleting records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property to false.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsDeleted"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsDelete"/>
		/// <seealso cref="RecordsDeleting"/>
		/// <seealso cref="RecordsDeleted"/>
		/// <seealso cref="RecordsDeletedEvent"/>
		/// <seealso cref="RecordsDeletedEventArgs"/>
		protected virtual void OnRecordsDeleted(RecordsDeletedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordsDeleted(RecordsDeletedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordsDeletedEvent;
			args.Source = this;
			this.OnRecordsDeleted(args);
		}

		/// <summary>
		/// Occurs after one or more <see cref="DataRecord"/>s has been deleted.
		/// </summary>
		/// <remarks>
		/// <para class="body">Deleting <see cref="DataRecord"/>s is supported for <see cref="DataPresenterBase.DataSource"/>s that implement the <see cref="System.ComponentModel.IBindingList"/> interface and return true from its <see cref="System.ComponentModel.IBindingList.AllowRemove"/> property.  
		/// It is also supported for <see cref="DataPresenterBase.DataSource"/>s that only implement the <see cref="System.Collections.IList"/> interface and return false from both its <see cref="System.Collections.IList.IsReadOnly"/> and <see cref="System.Collections.IList.IsFixedSize"/> properties.</para>
		/// <para></para>
		/// <para class="body">Assuming deleting of <see cref="DataRecord"/>s is enabled then when the user selects one or more <see cref="DataRecord"/>s and presses the <b>Delete</b> key the <see cref="DataPresenterBase.RecordsDeleting"/> and <see cref="DataPresenterBase.RecordsDeleted"/> events will be raised. 
		/// <see cref="DataRecord"/>s can also be deleted programmatically by first selecting them (via the <see cref="Record.IsSelected"/> property or the <see cref="DataPresenterBase.SelectedItems"/> collection) and then calling <see cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands.DeleteSelectedDataRecords"/> command.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>Deleting records is enabled by default. To disable deleting records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property to false.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsDeleted"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsDelete"/>
		/// <seealso cref="RecordsDeleting"/>
		/// <seealso cref="OnRecordsDeleted"/>
		/// <seealso cref="RecordsDeletedEvent"/>
		/// <seealso cref="RecordsDeletedEventArgs"/>
		//[Description("Occurs after one or more records has been deleted.")]
		//[Category("Data")]
		public event EventHandler<RecordsDeletedEventArgs> RecordsDeleted
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordsDeletedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordsDeletedEvent, value);
			}
		}

		#endregion //RecordsDeleted

		#region RecordsDeleting

		/// <summary>
		/// Event ID for the <see cref="RecordsDeleting"/> routed event
		/// </summary>
		/// <seealso cref="RecordsDeleting"/>
		/// <seealso cref="OnRecordsDeleting"/>
		/// <seealso cref="RecordsDeletingEventArgs"/>
		public static readonly RoutedEvent RecordsDeletingEvent =
			EventManager.RegisterRoutedEvent("RecordsDeleting", RoutingStrategy.Bubble, typeof(EventHandler<RecordsDeletingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when one or more <see cref="DataRecord"/>s is about to be deleted.
		/// </summary>
		/// <remarks>
		/// <para class="body">Deleting <see cref="DataRecord"/>s is supported for <see cref="DataPresenterBase.DataSource"/>s that implement the <see cref="System.ComponentModel.IBindingList"/> interface and return true from its <see cref="System.ComponentModel.IBindingList.AllowRemove"/> property.  
		/// It is also supported for <see cref="DataPresenterBase.DataSource"/>s that only implement the <see cref="System.Collections.IList"/> interface and return false from both its <see cref="System.Collections.IList.IsReadOnly"/> and <see cref="System.Collections.IList.IsFixedSize"/> properties.</para>
		/// <para></para>
		/// <para class="body">Assuming deleting of <see cref="DataRecord"/>s is enabled then when the user selects one or more <see cref="DataRecord"/>s and presses the <b>Delete</b> key the <see cref="DataPresenterBase.RecordsDeleting"/> and <see cref="DataPresenterBase.RecordsDeleted"/> events will be raised. 
		/// <see cref="DataRecord"/>s can also be deleted programmatically by first selecting them (via the <see cref="Record.IsSelected"/> property or the <see cref="DataPresenterBase.SelectedItems"/> collection) and then calling <see cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands.DeleteSelectedDataRecords"/> command.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>Deleting records is enabled by default. To disable deleting records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property to false.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsDeleted"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsDelete"/>
		/// <seealso cref="RecordsDeleted"/>
		/// <seealso cref="RecordsDeleting"/>
		/// <seealso cref="RecordsDeletingEvent"/>
		/// <seealso cref="RecordsDeletingEventArgs"/>
		protected virtual void OnRecordsDeleting(RecordsDeletingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordsDeleting(RecordsDeletingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordsDeletingEvent;
			args.Source = this;
			this.OnRecordsDeleting(args);
		}

		/// <summary>
		/// Occurs when one or more <see cref="DataRecord"/>s is about to be deleted.
		/// </summary>
		/// <remarks>
		/// <para class="body">Deleting <see cref="DataRecord"/>s is supported for <see cref="DataPresenterBase.DataSource"/>s that implement the <see cref="System.ComponentModel.IBindingList"/> interface and return true from its <see cref="System.ComponentModel.IBindingList.AllowRemove"/> property.  
		/// It is also supported for <see cref="DataPresenterBase.DataSource"/>s that only implement the <see cref="System.Collections.IList"/> interface and return false from both its <see cref="System.Collections.IList.IsReadOnly"/> and <see cref="System.Collections.IList.IsFixedSize"/> properties.</para>
		/// <para></para>
		/// <para class="body">Assuming deleting of <see cref="DataRecord"/>s is enabled then when the user selects one or more <see cref="DataRecord"/>s and presses the <b>Delete</b> key the <see cref="DataPresenterBase.RecordsDeleting"/> and <see cref="DataPresenterBase.RecordsDeleted"/> events will be raised. 
		/// <see cref="DataRecord"/>s can also be deleted programmatically by first selecting them (via the <see cref="Record.IsSelected"/> property or the <see cref="DataPresenterBase.SelectedItems"/> collection) and then calling <see cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands.DeleteSelectedDataRecords"/> command.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>Deleting records is enabled by default. To disable deleting records set the <see cref="FieldLayoutSettings"/>'s <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property to false.</para>
		/// </remarks>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.IsDeleted"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.DataSourceAllowsDelete"/>
		/// <seealso cref="RecordsDeleted"/>
		/// <seealso cref="OnRecordsDeleting"/>
		/// <seealso cref="RecordsDeletingEvent"/>
		/// <seealso cref="RecordsDeletingEventArgs"/>
		//[Description("Occurs when one or more records is about to be deleted.")]
		//[Category("Data")]
		public event EventHandler<RecordsDeletingEventArgs> RecordsDeleting
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordsDeletingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordsDeletingEvent, value);
			}
		}

		#endregion //RecordsDeleting

		#region RecordExpanded

		/// <summary>
		/// Event ID for the <see cref="RecordExpanded"/> routed event
		/// </summary>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="OnRecordExpanded"/>
		/// <seealso cref="RecordExpandedEventArgs"/>
		public static readonly RoutedEvent RecordExpandedEvent =
			EventManager.RegisterRoutedEvent("RecordExpanded", RoutingStrategy.Bubble, typeof(EventHandler<RecordExpandedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been expanded
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can expand a collapsed record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be expanded by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.ExpandRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordExpandedEvent"/>
		/// <seealso cref="RecordExpandedEventArgs"/>
		protected virtual void OnRecordExpanded(RecordExpandedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordExpanded(RecordExpandedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordExpandedEvent;
			args.Source = this;
			this.OnRecordExpanded(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Record"/> has been expanded
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can expand a collapsed record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be expanded by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.ExpandRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="OnRecordExpanded"/>
		/// <seealso cref="RecordExpandedEvent"/>
		/// <seealso cref="RecordExpandedEventArgs"/>
		//[Description("Occurs beford a Record is expanded")]
		//[Category("Behavior")]
		public event EventHandler<RecordExpandedEventArgs> RecordExpanded
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordExpandedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordExpandedEvent, value);
			}
		}

		#endregion //RecordExpanded

		#region RecordExpanding

		/// <summary>
		/// Event ID for the <see cref="RecordExpanding"/> routed event
		/// </summary>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="OnRecordExpanding"/>
		/// <seealso cref="RecordExpandingEventArgs"/>
		public static readonly RoutedEvent RecordExpandingEvent =
			EventManager.RegisterRoutedEvent("RecordExpanding", RoutingStrategy.Bubble, typeof(EventHandler<RecordExpandingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Record"/> is expanded
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can expand a collapsed record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be expanded by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.ExpandRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="RecordExpanding"/>
		/// <seealso cref="RecordExpandingEvent"/>
		/// <seealso cref="RecordExpandingEventArgs"/>
		protected virtual void OnRecordExpanding(RecordExpandingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordExpanding(RecordExpandingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordExpandingEvent;
			args.Source = this;
			this.OnRecordExpanding(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Record"/> is expanded
		/// </summary>
		/// <remarks>
		/// <para class="body">The user can expand a collapsed record if the <see cref="RecordPresenter"/>'s visual tree includes an expansion indicator. Programmatically this can be accomplished by setting the <see cref="Record"/>s <see cref="Record.IsExpanded"/> property to true.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>The <see cref="ActiveRecord"/> can also be expanded by calling the <see cref="ExecuteCommand(RoutedCommand)"/> method with the <see cref="DataPresenterCommands.ExpandRecord"/> command.</para>
		/// </remarks>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterCommands.CollapseRecord"/>
		/// <seealso cref="DataPresenterCommands.ExpandRecord"/>
		/// <seealso cref="RecordCollapsed"/>
		/// <seealso cref="RecordExpanded"/>
		/// <seealso cref="RecordCollapsing"/>
		/// <seealso cref="OnRecordExpanding"/>
		/// <seealso cref="RecordExpandingEvent"/>
		/// <seealso cref="RecordExpandingEventArgs"/>
		//[Description("Occurs beford a Record is expanded")]
		//[Category("Behavior")]
		public event EventHandler<RecordExpandingEventArgs> RecordExpanding
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordExpandingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordExpandingEvent, value);
			}
		}

		#endregion //RecordExpanding

        // JJD 6/8/09 NA 2009 Vol 2 - Fixed Records
        #region RecordFixedLocationChanged

		/// <summary>
		/// Event ID for the <see cref="RecordFixedLocationChanged"/> routed event
		/// </summary>
		/// <seealso cref="RecordFixedLocationChanged"/>
		/// <seealso cref="OnRecordFixedLocationChanged"/>
		/// <seealso cref="RecordFixedLocationChangedEventArgs"/>
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        public static readonly RoutedEvent RecordFixedLocationChangedEvent =
			EventManager.RegisterRoutedEvent("RecordFixedLocationChanged", RoutingStrategy.Bubble, typeof(EventHandler<RecordFixedLocationChangedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="Record"/>'s fixed state has changed.
		/// </summary>
		/// <remarks>
        /// <para class="body">Whether or not the user can change the fixed state of a record is determined by the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/> property. Programmatically a record's fix state can be set through the <see cref="Record"/>'s <see cref="Record.FixedLocation"/> property.</para>
		/// <para></para>
        /// <para class="note"><b>Note: </b>The <see cref="Record"/> can also be fixed/unfixed by calling the <see cref="ExecuteCommand(RoutedCommand, object)"/> method with either the <see cref="DataPresenterCommands.FixRecordTop"/>, <see cref="DataPresenterCommands.FixRecordBottom"/> or <see cref="DataPresenterCommands.UnfixRecord"/> command and passing in the record as the parameter.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterCommands.FixRecordTop"/>
		/// <seealso cref="DataPresenterCommands.FixRecordBottom"/>
		/// <seealso cref="DataPresenterCommands.UnfixRecord"/>
		/// <seealso cref="Record.FixedLocation"/>
		/// <seealso cref="RecordFixedLocationChanging"/>
		/// <seealso cref="RecordFixedLocationChanged"/>
		/// <seealso cref="RecordFixedLocationChangedEvent"/>
		/// <seealso cref="RecordFixedLocationChangedEventArgs"/>
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        protected virtual void OnRecordFixedLocationChanged(RecordFixedLocationChangedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFixedLocationChanged(RecordFixedLocationChangedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordFixedLocationChangedEvent;
			args.Source = this;
			this.OnRecordFixedLocationChanged(args);
		}

		/// <summary>
		/// Occurs after a <see cref="Record"/>'s fixed state has changed.
		/// </summary>
        /// <remarks>
        /// <para class="body">Whether or not the user can change the fixed state of a record is determined by the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/> property. Programmatically a record's fix state can be set through the <see cref="Record"/>s <see cref="Record.FixedLocation"/> property.</para>
        /// <para></para>
        /// <para class="note"><b>Note: </b>The <see cref="Record"/> can also be fixed/unfixed by calling the <see cref="ExecuteCommand(RoutedCommand, object)"/> method with either the <see cref="DataPresenterCommands.FixRecordTop"/>, <see cref="DataPresenterCommands.FixRecordBottom"/> or <see cref="DataPresenterCommands.UnfixRecord"/> command and passing in the record as the parameter.</para>
        /// </remarks>
        /// <seealso cref="DataPresenterCommands.FixRecordTop"/>
        /// <seealso cref="DataPresenterCommands.FixRecordBottom"/>
        /// <seealso cref="DataPresenterCommands.UnfixRecord"/>
        /// <seealso cref="Record.FixedLocation"/>
		/// <seealso cref="RecordFixedLocationChanging"/>
		/// <seealso cref="OnRecordFixedLocationChanged"/>
		/// <seealso cref="RecordFixedLocationChangedEvent"/>
		/// <seealso cref="RecordFixedLocationChangedEventArgs"/>
		//[Description("Occurs after a Record's fix state has changed.")]
		//[Category("Behavior")]
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        public event EventHandler<RecordFixedLocationChangedEventArgs> RecordFixedLocationChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordFixedLocationChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordFixedLocationChangedEvent, value);
			}
		}

		#endregion //RecordFixedLocationChanged

        // JJD 6/8/09 NA 2009 Vol 2 - Fixed Records
        #region RecordFixedLocationChanging

		/// <summary>
		/// Event ID for the <see cref="RecordFixedLocationChanging"/> routed event
		/// </summary>
		/// <seealso cref="RecordFixedLocationChanging"/>
		/// <seealso cref="OnRecordFixedLocationChanging"/>
		/// <seealso cref="RecordFixedLocationChangingEventArgs"/>
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        public static readonly RoutedEvent RecordFixedLocationChangingEvent =
			EventManager.RegisterRoutedEvent("RecordFixedLocationChanging", RoutingStrategy.Bubble, typeof(EventHandler<RecordFixedLocationChangingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs before a <see cref="Record"/> is expanded
		/// </summary>
        /// <remarks>
        /// <para class="body">Whether or not the user can change the fixed state of a record is determined by the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/> property. Programmatically a record's fix state can be set through the <see cref="Record"/>s <see cref="Record.FixedLocation"/> property.</para>
        /// <para></para>
        /// <para class="note"><b>Note: </b>The <see cref="Record"/> can also be fixed/unfixed by calling the <see cref="ExecuteCommand(RoutedCommand, object)"/> method with either the <see cref="DataPresenterCommands.FixRecordTop"/>, <see cref="DataPresenterCommands.FixRecordBottom"/> or <see cref="DataPresenterCommands.UnfixRecord"/> command and passing in the record as the parameter.</para>
        /// </remarks>
        /// <seealso cref="DataPresenterCommands.FixRecordTop"/>
        /// <seealso cref="DataPresenterCommands.FixRecordBottom"/>
        /// <seealso cref="DataPresenterCommands.UnfixRecord"/>
        /// <seealso cref="Record.FixedLocation"/>
        /// <seealso cref="RecordFixedLocationChanged"/>
		/// <seealso cref="RecordFixedLocationChanging"/>
		/// <seealso cref="RecordFixedLocationChangingEvent"/>
		/// <seealso cref="RecordFixedLocationChangingEventArgs"/>
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        protected virtual void OnRecordFixedLocationChanging(RecordFixedLocationChangingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordFixedLocationChanging(RecordFixedLocationChangingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordFixedLocationChangingEvent;
			args.Source = this;
			this.OnRecordFixedLocationChanging(args);
		}

		/// <summary>
		/// Occurs before a <see cref="Record"/>'s fix state has changed.
		/// </summary>
        /// <remarks>
        /// <para class="body">Whether or not the user can change the fixed state of a record is determined by the <see cref="FieldLayoutSettings"/>' <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/> property. Programmatically a record's fix state can be set through the <see cref="Record"/>s <see cref="Record.FixedLocation"/> property.</para>
        /// <para></para>
        /// <para class="note"><b>Note: </b>The <see cref="Record"/> can also be fixed/unfixed by calling the <see cref="ExecuteCommand(RoutedCommand, object)"/> method with either the <see cref="DataPresenterCommands.FixRecordTop"/>, <see cref="DataPresenterCommands.FixRecordBottom"/> or <see cref="DataPresenterCommands.UnfixRecord"/> command and passing in the record as the parameter.</para>
        /// </remarks>
        /// <seealso cref="DataPresenterCommands.FixRecordTop"/>
        /// <seealso cref="DataPresenterCommands.FixRecordBottom"/>
        /// <seealso cref="DataPresenterCommands.UnfixRecord"/>
        /// <seealso cref="Record.FixedLocation"/>
        /// <seealso cref="RecordFixedLocationChanged"/>
		/// <seealso cref="OnRecordFixedLocationChanging"/>
		/// <seealso cref="RecordFixedLocationChangingEvent"/>
		/// <seealso cref="RecordFixedLocationChangingEventArgs"/>
        //[Description("Occurs before a Record's fix state has changed.")]
		//[Category("Behavior")]
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_RecordFixing, Version = FeatureInfo.Version_9_2)]
        public event EventHandler<RecordFixedLocationChangingEventArgs> RecordFixedLocationChanging
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordFixedLocationChangingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordFixedLocationChangingEvent, value);
			}
		}

		#endregion //RecordFixedLocationChanging

		#region RecordsInViewChanged

		/// <summary>
		/// Event ID for the <see cref="RecordsInViewChanged"/> routed event
		/// </summary>
		/// <seealso cref="RecordsInViewChanged"/>
		/// <seealso cref="GetRecordsInView(bool)"/>
		/// <seealso cref="BringRecordIntoView(Record)"/>
		/// <seealso cref="BringCellIntoView(Cell)"/>
		/// <seealso cref="RecordPresenter.FromRecord(Record)"/>
		/// <seealso cref="CellValuePresenter.FromRecordAndField(DataRecord,Field)"/>
		/// <seealso cref="OnRecordsInViewChanged"/>
		/// <seealso cref="RecordsInViewChangedEventArgs"/>
		public static readonly RoutedEvent RecordsInViewChangedEvent =
			EventManager.RegisterRoutedEvent("RecordsInViewChanged", RoutingStrategy.Bubble, typeof(EventHandler<RecordsInViewChangedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after the set of <see cref="Record"/>s in view has changed.
		/// </summary>
		/// <seealso cref="GetRecordsInView(bool)"/>
		/// <seealso cref="BringRecordIntoView(Record)"/>
		/// <seealso cref="BringCellIntoView(Cell)"/>
		/// <seealso cref="RecordPresenter.FromRecord(Record)"/>
		/// <seealso cref="CellValuePresenter.FromRecordAndField(DataRecord,Field)"/>
		/// <seealso cref="RecordsInViewChanged"/>
		/// <seealso cref="RecordsInViewChangedEvent"/>
		/// <seealso cref="RecordsInViewChangedEventArgs"/>
		protected virtual void OnRecordsInViewChanged(RecordsInViewChangedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method and raise the direct event as well.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);

			if (this.RecordsInViewChangedDirect != null)
				this.RecordsInViewChangedDirect(this, args);
		}

        // AS 2/24/09 Optimization
        //private void ProcessPostedRecordsInViewChanged()
		private object ProcessPostedRecordsInViewChanged(object param)
		{
            // AS 2/24/09 Optimization
            // If the ScrollVersion has been bumped by something else - e.g. the 
            // ScrollChanged event handler - then we don't need to bump it so only 
            // bump if its the same as the value we had when the begininvoke was 
            // issued.
            //
            if (param is int)
            {
                int scrollVersion = (int)param;
                if (scrollVersion == this.ScrollVersion)
                    this.ScrollVersion++;
            }

			this._postRecordsInViewChangedOperation = null;
			this.RaiseRecordsInViewChanged(new RecordsInViewChangedEventArgs());

            // AS 2/24/09 Optimization
            return null;
		}

		internal void RaiseRecordsInViewChanged(RecordsInViewChangedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordsInViewChangedEvent;
			args.Source = this;
			this.OnRecordsInViewChanged(args);
		}

		/// <summary>
		/// Occurs after the set of <see cref="Record"/>s in view has changed.
		/// </summary>
		/// <seealso cref="GetRecordsInView(bool)"/>
		/// <seealso cref="BringRecordIntoView(Record)"/>
		/// <seealso cref="BringCellIntoView(Cell)"/>
		/// <seealso cref="OnRecordsInViewChanged"/>
		/// <seealso cref="RecordsInViewChangedEvent"/>
		/// <seealso cref="RecordsInViewChangedEventArgs"/>
		//[Description("Occurs after the set of records in view has changed.")]
		//[Category("Behavior")]
		public event EventHandler<RecordsInViewChangedEventArgs> RecordsInViewChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordsInViewChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordsInViewChangedEvent, value);
			}
		}

		// MD 7/16/10 - TFS26592
		/// <summary>
		/// Occurs after the set of <see cref="Record"/>s in view has changed.
		/// </summary>
		/// <seealso cref="GetRecordsInView(bool)"/>
		/// <seealso cref="BringRecordIntoView(Record)"/>
		/// <seealso cref="BringCellIntoView(Cell)"/>
		/// <seealso cref="OnRecordsInViewChanged"/>
		/// <seealso cref="RecordsInViewChangedEventArgs"/>
		public event EventHandler<RecordsInViewChangedEventArgs> RecordsInViewChangedDirect;

		#endregion //RecordsInViewChanged

		#region RecordUpdateCanceling

		/// <summary>
		/// Event ID for the <see cref="RecordUpdateCanceling"/> routed event
		/// </summary>
		/// <seealso cref="RecordUpdateCanceling"/>
		/// <seealso cref="OnRecordUpdateCanceling"/>
		/// <seealso cref="RecordUpdateCancelingEventArgs"/>
		public static readonly RoutedEvent RecordUpdateCancelingEvent =
			EventManager.RegisterRoutedEvent("RecordUpdateCanceling", RoutingStrategy.Bubble, typeof(EventHandler<RecordUpdateCancelingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when a <see cref="DataRecord"/>'s changes are about to be canceled.
		/// </summary>
		/// <remarks>
		/// <para class="body">The update can be canceled by calling the <see cref="DataRecord"/>'s <see cref="DataRecord.CancelUpdate"/> method or by calling <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands.DiscardChangesToActiveRecord"/> or <see cref="DataPresenterCommands.DiscardChangesToAllRecords"/> command.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="RecordUpdateCanceling"/>
		/// <seealso cref="RecordUpdateCancelingEvent"/>
		/// <seealso cref="RecordUpdateCancelingEventArgs"/>
		protected virtual void OnRecordUpdateCanceling(RecordUpdateCancelingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordUpdateCanceling(RecordUpdateCancelingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordUpdateCancelingEvent;
			args.Source = this;
			this.OnRecordUpdateCanceling(args);
		}

		/// <summary>
		/// Occurs when a <see cref="DataRecord"/>'s changes are about to be canceled.
		/// </summary>
		/// <remarks>
		/// <para class="body">The update can be canceled by calling the <see cref="DataRecord"/>'s <see cref="DataRecord.CancelUpdate"/> method or by calling <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands.DiscardChangesToActiveRecord"/> or <see cref="DataPresenterCommands.DiscardChangesToAllRecords"/> command.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnRecordUpdateCanceling"/>
		/// <seealso cref="RecordUpdateCanceled"/>
		/// <seealso cref="RecordUpdateCancelingEvent"/>
		/// <seealso cref="RecordUpdateCancelingEventArgs"/>
		//[Description("Occurs when a record's update is about to be canceled.")]
		//[Category("Data")]
		public event EventHandler<RecordUpdateCancelingEventArgs> RecordUpdateCanceling
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordUpdateCancelingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordUpdateCancelingEvent, value);
			}
		}

		#endregion //RecordUpdateCanceling

		#region RecordUpdateCanceled

		/// <summary>
		/// Event ID for the <see cref="RecordUpdateCanceled"/> routed event
		/// </summary>
		/// <seealso cref="RecordUpdateCanceled"/>
		/// <seealso cref="OnRecordUpdateCanceled"/>
		/// <seealso cref="RecordUpdateCanceledEventArgs"/>
		public static readonly RoutedEvent RecordUpdateCanceledEvent =
			EventManager.RegisterRoutedEvent("RecordUpdateCanceled", RoutingStrategy.Bubble, typeof(EventHandler<RecordUpdateCanceledEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="DataRecord"/>'s changes have been canceled.
		/// </summary>
		/// <remarks>
		/// <para class="body">The update can be canceled by calling the <see cref="DataRecord"/>'s <see cref="DataRecord.CancelUpdate"/> method or by calling <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands.DiscardChangesToActiveRecord"/> or <see cref="DataPresenterCommands.DiscardChangesToAllRecords"/> command.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="RecordUpdateCanceled"/>
		/// <seealso cref="RecordUpdateCanceledEvent"/>
		/// <seealso cref="RecordUpdateCanceledEventArgs"/>
		protected virtual void OnRecordUpdateCanceled(RecordUpdateCanceledEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordUpdateCanceled(RecordUpdateCanceledEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordUpdateCanceledEvent;
			args.Source = this;
			this.OnRecordUpdateCanceled(args);
		}

		/// <summary>
		/// Occurs after a <see cref="DataRecord"/>'s changes have been canceled.
		/// </summary>
		/// <remarks>
		/// <para class="body">The update can be canceled by calling the <see cref="DataRecord"/>'s <see cref="DataRecord.CancelUpdate"/> method or by calling <see cref="ExecuteCommand(RoutedCommand)"/> with either the <see cref="DataPresenterCommands.DiscardChangesToActiveRecord"/> or <see cref="DataPresenterCommands.DiscardChangesToAllRecords"/> command.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnRecordUpdateCanceled"/>
		/// <seealso cref="RecordUpdateCanceling"/>
		/// <seealso cref="RecordUpdateCanceledEvent"/>
		/// <seealso cref="RecordUpdateCanceledEventArgs"/>
		//[Description("Occurs after a record's update has been canceled.")]
		//[Category("Data")]
		public event EventHandler<RecordUpdateCanceledEventArgs> RecordUpdateCanceled
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordUpdateCanceledEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordUpdateCanceledEvent, value);
			}
		}

		#endregion //RecordUpdateCanceled

		#region RecordUpdating

		/// <summary>
		/// Event ID for the <see cref="RecordUpdating"/> routed event
		/// </summary>
		/// <seealso cref="RecordUpdating"/>
		/// <seealso cref="OnRecordUpdating"/>
		/// <seealso cref="RecordUpdatingEventArgs"/>
		public static readonly RoutedEvent RecordUpdatingEvent =
			EventManager.RegisterRoutedEvent("RecordUpdating", RoutingStrategy.Bubble, typeof(EventHandler<RecordUpdatingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when a <see cref="DataRecord"/> is about to be updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">After editing <see cref="Cell"/> values in a <see cref="DataRecord"/> the changes are commited to the <see cref="DataSource"/> based on the <see cref="UpdateMode"/> property setting.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="RecordUpdating"/>
		/// <seealso cref="RecordUpdatingEvent"/>
		/// <seealso cref="RecordUpdatingEventArgs"/>
		protected virtual void OnRecordUpdating(RecordUpdatingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordUpdating(RecordUpdatingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordUpdatingEvent;
			args.Source = this;
			this.OnRecordUpdating(args);
		}

		/// <summary>
		/// Occurs when a <see cref="DataRecord"/> is about to be updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">After editing <see cref="Cell"/> values in a <see cref="DataRecord"/> the changes are commited to the <see cref="DataSource"/> based on the <see cref="UpdateMode"/> property setting.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnRecordUpdating"/>
		/// <seealso cref="RecordUpdated"/>
		/// <seealso cref="RecordUpdatingEvent"/>
		/// <seealso cref="RecordUpdatingEventArgs"/>
		//[Description("Occurs when a record is about to be updated.")]
		//[Category("Data")]
		public event EventHandler<RecordUpdatingEventArgs> RecordUpdating
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordUpdatingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordUpdatingEvent, value);
			}
		}

		#endregion //RecordUpdating

		#region RecordUpdated

		/// <summary>
		/// Event ID for the <see cref="RecordUpdated"/> routed event
		/// </summary>
		/// <seealso cref="RecordUpdated"/>
		/// <seealso cref="OnRecordUpdated"/>
		/// <seealso cref="RecordUpdatedEventArgs"/>
		public static readonly RoutedEvent RecordUpdatedEvent =
			EventManager.RegisterRoutedEvent("RecordUpdated", RoutingStrategy.Bubble, typeof(EventHandler<RecordUpdatedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after a <see cref="DataRecord"/> has been updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">After editing <see cref="Cell"/> values in a <see cref="DataRecord"/> the changes are commited to the <see cref="DataSource"/> based on the <see cref="UpdateMode"/> property setting.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="RecordUpdated"/>
		/// <seealso cref="RecordUpdatedEvent"/>
		/// <seealso cref="RecordUpdatedEventArgs"/>
		protected virtual void OnRecordUpdated(RecordUpdatedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseRecordUpdated(RecordUpdatedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.RecordUpdatedEvent;
			args.Source = this;
			this.OnRecordUpdated(args);
		}

		/// <summary>
		/// Occurs after a <see cref="DataRecord"/> has been updated.
		/// </summary>
		/// <remarks>
		/// <para class="body">After editing <see cref="Cell"/> values in a <see cref="DataRecord"/> the changes are commited to the <see cref="DataSource"/> based on the <see cref="UpdateMode"/> property setting.</para>
		/// </remarks>
		/// <seealso cref="DataPresenterBase.UpdateMode"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="OnRecordUpdated"/>
		/// <seealso cref="RecordUpdating"/>
		/// <seealso cref="RecordUpdatedEvent"/>
		/// <seealso cref="RecordUpdatedEventArgs"/>
		//[Description("Occurs after a record has been updated.")]
		//[Category("Data")]
		public event EventHandler<RecordUpdatedEventArgs> RecordUpdated
		{
			add
			{
				base.AddHandler(DataPresenterBase.RecordUpdatedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.RecordUpdatedEvent, value);
			}
		}

		#endregion //RecordUpdated

		#region SelectedItemsChanged

		/// <summary>
		/// Event ID for the <see cref="SelectedItemsChanged"/> routed event
		/// </summary>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="OnSelectedItemsChanged"/>
		/// <seealso cref="SelectedItemsChangedEventArgs"/>
		public static readonly RoutedEvent SelectedItemsChangedEvent =
			EventManager.RegisterRoutedEvent("SelectedItemsChanged", RoutingStrategy.Bubble, typeof(EventHandler<SelectedItemsChangedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs after the <see cref="SelectedItems"/> have changed.
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. However, the <b>SelectedItemsChanged</b> event will be raised. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="SelectedItems"/>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="SelectedItemHolder"/>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="SelectedItemsChangedEvent"/>
		/// <seealso cref="SelectedItemsChangedEventArgs"/>
		protected virtual void OnSelectedItemsChanged(SelectedItemsChangedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		// JJD 11/22/11 - TFS79023 - added
		private Type _selectedItemsChangePending;

		// JJD 11/22/11 - TFS79023 - added
		internal void RaiseSelectedItemsChangedAsync(Type type)
		{
			// if a begin invoke is already pending then bail
			if (_selectedItemsChangePending != null)
				return;

			_selectedItemsChangePending = type;

			this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new GridUtilities.MethodDelegate(this.ProcessSelectedItemsChanged));
		}

		// JJD 11/22/11 - TFS79023 - added
		internal void ProcessSelectedItemsChanged()
		{
			// if the pending flag was already cleared then bail
			if (_selectedItemsChangePending == null)
				return;

			this.RaiseSelectedItemsChanged(new SelectedItemsChangedEventArgs(_selectedItemsChangePending));
		}

		internal void RaiseSelectedItemsChanged(SelectedItemsChangedEventArgs args)
		{
			// JJD 11/22/11 - TFS79023
			// Clear the _selectedItemsChangePending member
			_selectedItemsChangePending = null;

			args.RoutedEvent = DataPresenterBase.SelectedItemsChangedEvent;
			args.Source = this;
			this.OnSelectedItemsChanged(args);

			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;
			if (panelNavigator != null)
				panelNavigator.OnSelectedItemsChanged();
		}

		/// <summary>
		/// Occurs after the <see cref="SelectedItems"/> have changed.
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. However, the <b>SelectedItemsChanged</b> event will be raised. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="SelectedItems"/>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="SelectedItemHolder"/>
		/// <seealso cref="OnSelectedItemsChanged"/>
		/// <seealso cref="SelectedItemsChangedEvent"/>
		/// <seealso cref="SelectedItemsChangedEventArgs"/>
		//[Description("Occurs when the SelectedItems have changed")]
		//[Category("Behavior")]
		public event EventHandler<SelectedItemsChangedEventArgs> SelectedItemsChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.SelectedItemsChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.SelectedItemsChangedEvent, value);
			}
		}

		#endregion //SelectedItemsChanged

		#region SelectedItemsChanging

		/// <summary>
		/// Event ID for the <see cref="SelectedItemsChanging"/> routed event
		/// </summary>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="OnSelectedItemsChanging"/>
		/// <seealso cref="SelectedItemsChangingEventArgs"/>
		public static readonly RoutedEvent SelectedItemsChangingEvent =
			EventManager.RegisterRoutedEvent("SelectedItemsChanging", RoutingStrategy.Bubble, typeof(EventHandler<SelectedItemsChangingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the <see cref="SelectedItems"/> are about to change
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="SelectedItems"/>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="SelectedItemHolder"/>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="SelectedItemsChangingEvent"/>
		/// <seealso cref="SelectedItemsChangingEventArgs"/>
		protected virtual void OnSelectedItemsChanging(SelectedItemsChangingEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSelectedItemsChanging(SelectedItemsChangingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.SelectedItemsChangingEvent;
			args.Source = this;
			this.OnSelectedItemsChanging(args);
		}

		/// <summary>
		/// Occurs when the <see cref="SelectedItems"/> are about to change
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. However, the <b>SelectedItemsChanged</b> event will be raised. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="SelectedItems"/>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="SelectedItemHolder"/>
		/// <seealso cref="OnSelectedItemsChanging"/>
		/// <seealso cref="SelectedItemsChangingEvent"/>
		/// <seealso cref="SelectedItemsChangingEventArgs"/>
		//[Description("Occurs when the SelectedItems are about to change")]
		//[Category("Behavior")]
		public event EventHandler<SelectedItemsChangingEventArgs> SelectedItemsChanging
		{
			add
			{
				base.AddHandler(DataPresenterBase.SelectedItemsChangingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.SelectedItemsChangingEvent, value);
			}
		}

		#endregion //SelectedItemsChanging

		#region Sorting

		/// <summary>
		/// Event ID for the <see cref="Sorting"/> routed event
		/// </summary>
		/// <seealso cref="Sorting"/>
		/// <seealso cref="OnSorting"/>
		/// <seealso cref="SortingEventArgs"/>
		public static readonly RoutedEvent SortingEvent =
			EventManager.RegisterRoutedEvent("Sorting", RoutingStrategy.Bubble, typeof(EventHandler<SortingEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the sort order of records is about to change as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <para class="body">When records are grouped this event will not be raised even though the sort order may change as a result of the grouping.</para>
		/// </remarks>
		/// <seealso cref="Sorting"/>
		/// <seealso cref="SortingEvent"/>
		/// <seealso cref="SortingEventArgs"/>
		protected virtual void OnSorting(SortingEventArgs args)
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSorting(SortingEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.SortingEvent;
			args.Source = this;
			this.OnSorting(args);
		}

		/// <summary>
		/// Occurs when the sort order of records is about to change as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <para class="body">When records are grouped this event will not be raised even though the sort order may change as a result of the grouping.</para>
        /// <para class="note"><b>Note:</b> the <see cref="SortingEventArgs"/>.<see cref="SortingEventArgs.SortDescription"/> property can return null if the <see cref="Field"/> is being unsorted, i.e. if the <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> property is set to 'SortByOneFieldOnlyTriState' or 'SortByMultipleFieldsTriState'.
        /// </para>
        /// </remarks>
        /// <seealso cref="OnSorting"/>
		/// <seealso cref="Sorted"/>
		/// <seealso cref="Grouping"/>
		/// <seealso cref="Grouped"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="SortingEvent"/>
		/// <seealso cref="SortingEventArgs"/>
		//[Description("Occurs when the sort order of records is about to change as the result of a user action.")]
		//[Category("Behavior")]
		public event EventHandler<SortingEventArgs> Sorting
		{
			add
			{
				base.AddHandler(DataPresenterBase.SortingEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.SortingEvent, value);
			}
		}

		#endregion //Sorting

		#region Sorted

		/// <summary>
		/// Event ID for the <see cref="Sorted"/> routed event
		/// </summary>
		/// <seealso cref="Sorted"/>
		/// <seealso cref="OnSorted"/>
		/// <seealso cref="SortedEventArgs"/>
		public static readonly RoutedEvent SortedEvent =
			EventManager.RegisterRoutedEvent("Sorted", RoutingStrategy.Bubble, typeof(EventHandler<SortedEventArgs>), typeof(DataPresenterBase));

		/// <summary>
		/// Occurs when the sort order of records has changed as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <para class="body">When records are grouped this event will not be raised even though the sort order may change as a result of the grouping.</para>
		/// </remarks>
		/// <seealso cref="Sorted"/>
		/// <seealso cref="SortedEvent"/>
		/// <seealso cref="SortedEventArgs"/>
		protected virtual void OnSorted(SortedEventArgs args)
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSorted(SortedEventArgs args)
		{
			args.RoutedEvent = DataPresenterBase.SortedEvent;
			args.Source = this;
			this.OnSorted(args);
		}

		/// <summary>
		/// Occurs when the sort order of records has changed as the result of a user action.
		/// </summary>
		/// <remarks>
		/// <para class="body">When records are grouped this event will not be raised even though the sort order may change as a result of the grouping.</para>
        /// <para class="note"><b>Note:</b> the <see cref="SortedEventArgs"/>.<see cref="SortedEventArgs.SortDescription"/> property can return null if the <see cref="Field"/> is being unsorted, i.e. if the <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> property is set to 'SortByOneFieldOnlyTriState' or 'SortByMultipleFieldsTriState'.
        /// </para>
        /// </remarks>
		/// <seealso cref="OnSorted"/>
		/// <seealso cref="Sorting"/>
		/// <seealso cref="Grouping"/>
		/// <seealso cref="Grouped"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="FieldSortDescription"/>
		/// <seealso cref="SortedEvent"/>
		/// <seealso cref="SortedEventArgs"/>
		//[Description("Occurs when the sort order of records has changed as the result of a user action.")]
		//[Category("Behavior")]
		public event EventHandler<SortedEventArgs> Sorted
		{
			add
			{
				base.AddHandler(DataPresenterBase.SortedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.SortedEvent, value);
			}
		}

		#endregion //Sorted

		#region SummaryResultChanged

		/// <summary>
		/// Event ID for the <see cref="SummaryResultChanged"/> routed event
		/// </summary>
		/// <seealso cref="SummaryResultChanged"/>
		/// <seealso cref="OnSummaryResultChanged"/>
		/// <seealso cref="SummaryResultChangedEventArgs"/>
		public static readonly RoutedEvent SummaryResultChangedEvent =
			EventManager.RegisterRoutedEvent( "SummaryResultChanged", RoutingStrategy.Bubble, typeof( EventHandler<SummaryResultChangedEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised when a summary result is calculated or recalculated.
		/// </summary>
		/// <seealso cref="SummaryResultChanged"/>
		protected virtual void OnSummaryResultChanged( SummaryResultChangedEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSummaryResultChanged( SummaryResultChangedEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.SummaryResultChangedEvent;
			args.Source = this;
			this.OnSummaryResultChanged( args );
		}

		/// <summary>
		/// Occurs when a summary result is calculated or recalculated.
		/// </summary>
		/// <remarks>
		/// <b>SummaryResultChanged</b> is raised when the a summary result is calculated or recalculated.
		/// </remarks>
		/// <seealso cref="OnSummaryResultChanged"/>
		/// <seealso cref="DataPresenterBase.SummarySelectionControlClosed"/>
		//[Description( "Occurs when a summary result is calculated or recalculated." )]
		//[Category("Behavior")]
		public event EventHandler<SummaryResultChangedEventArgs> SummaryResultChanged
		{
			add
			{
				base.AddHandler( DataPresenterBase.SummaryResultChangedEvent, value );
			}
			remove
			{
				base.RemoveHandler( DataPresenterBase.SummaryResultChangedEvent, value );
			}
		}

		#endregion //SummaryResultChanged

		#region SummarySelectionControlClosed

		/// <summary>
		/// Event ID for the <see cref="SummarySelectionControlClosed"/> routed event
		/// </summary>
		/// <seealso cref="SummarySelectionControlClosed"/>
		/// <seealso cref="SummarySelectionControlOpening"/>
		public static readonly RoutedEvent SummarySelectionControlClosedEvent =
			EventManager.RegisterRoutedEvent( "SummarySelectionControlClosed", RoutingStrategy.Bubble,
				typeof( EventHandler<SummarySelectionControlClosedEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised after the UI for selecting summaries for a field is closed.
		/// </summary>
		/// <seealso cref="SummarySelectionControlClosed"/>
		protected virtual void OnSummarySelectionControlClosed( SummarySelectionControlClosedEventArgs args )
		{
			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSummarySelectionControlClosed( SummarySelectionControlClosedEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.SummarySelectionControlClosedEvent;
			args.Source = this;
			this.OnSummarySelectionControlClosed( args );
		}

		/// <summary>
		/// Raised before the UI for selecting summaries for a field is displayed. You can cancel this event and display your own UI.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>SummarySelectionControlClosed</b> is raised after the user interface for selecting summaries for a field
		/// is closed. This event is raised even when the user doesn't select any summaries or modify existing summaries.
		/// Whether summaries are actually modified is indicated by the <see cref="SummarySelectionControlClosedEventArgs.SummariesChanged"/>
		/// property.
		/// </para>
		/// </remarks>
		/// <seealso cref="SummarySelectionControlClosed"/>
		/// <seealso cref="SummarySelectionControlOpening"/>
		/// <seealso cref="SummarySelectionControlClosedEventArgs"/>
		/// <seealso cref="FieldLayout.SummaryDefinitions"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryUIType"/>
		/// <seealso cref="DataPresenterBase.SummaryResultChanged"/>
		//[Description( "Occurs after the summary selection UI is closed" )]
		//[Category( "Behavior" )]
		public event EventHandler<SummarySelectionControlClosedEventArgs> SummarySelectionControlClosed
		{
			add
			{
				base.AddHandler( SummarySelectionControlClosedEvent, value );
			}
			remove
			{
				base.RemoveHandler( SummarySelectionControlClosedEvent, value );
			}
		}

		#endregion // SummarySelectionControlClosed

		#region SummarySelectionControlOpening

		/// <summary>
		/// Event ID for the <see cref="SummarySelectionControlOpening"/> routed event
		/// </summary>
		/// <seealso cref="SummarySelectionControlOpening"/>
		/// <seealso cref="SummarySelectionControlClosed"/>
		public static readonly RoutedEvent SummarySelectionControlOpeningEvent =
			EventManager.RegisterRoutedEvent( "SummarySelectionControlOpening", RoutingStrategy.Bubble,
				typeof( EventHandler<SummarySelectionControlOpeningEventArgs> ), typeof( DataPresenterBase ) );

		/// <summary>
		/// Raised before the UI for selecting summaries for a field is displayed. You can cancel this event and display your own UI.
		/// </summary>
		/// <seealso cref="SummarySelectionControlOpening"/>
		protected virtual void OnSummarySelectionControlOpening( SummarySelectionControlOpeningEventArgs args )
		{
			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(args))
				return;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//this.RaiseEvent(args);
			this.RaiseEventHelper(args);
		}

		internal void RaiseSummarySelectionControlOpening( SummarySelectionControlOpeningEventArgs args )
		{
			args.RoutedEvent = DataPresenterBase.SummarySelectionControlOpeningEvent;
			args.Source = this;
			this.OnSummarySelectionControlOpening( args );
		}

		/// <summary>
		/// Raised before the UI for selecting summaries for a field is displayed. You can cancel this event and display your own UI.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>SummarySelectionControlOpening</b> is raised before the user interface for selecting summaries for a field
		/// is displayed. This happens when the summary button icon on a field label is clicked. To enable the UI, set the
		/// <see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/> property.
		/// </para>
		/// <para class="body">
		/// Note that you can cancel this event in which case the UI will not be displayed. This lets you display
		/// your own summary selection UI.
		/// </para>
		/// </remarks>
		/// <seealso cref="SummarySelectionControlOpening"/>
		/// <seealso cref="SummarySelectionControlClosed"/>
		/// <seealso cref="SummarySelectionControlOpeningEventArgs"/>
		/// <seealso cref="FieldLayout.SummaryDefinitions"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowSummaries"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.SummaryUIType"/>
		/// <seealso cref="DataPresenterBase.SummaryResultChanged"/>
		//[Description( "Occurs before the summary selection UI is displayed" )]
		//[Category( "Behavior" )]
		public event EventHandler<SummarySelectionControlOpeningEventArgs> SummarySelectionControlOpening
		{
			add
			{
				base.AddHandler( SummarySelectionControlOpeningEvent, value );
			}
			remove
			{
				base.RemoveHandler( SummarySelectionControlOpeningEvent, value );
			}
		}

		#endregion // SummarySelectionControlOpening

		#endregion //Events

		#region Properties

		#region Public Properties

        // JJD 10/15/09 - TFS23531 - added ActiveDataItem
        #region ActiveDataItem

        /// <summary>
        /// Identifies the <see cref="ActiveDataItem"/> dependency property
        /// </summary>
        /// <seealso cref="ActiveDataItem"/>
        public static readonly DependencyProperty ActiveDataItemProperty = DependencyProperty.Register("ActiveDataItem",
            typeof(object), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, new PropertyChangedCallback(OnActiveDataItemChanged), new CoerceValueCallback(CoerceActiveDataItem)));

        private static object CoerceActiveDataItem(DependencyObject target, object value)
        {
            DataPresenterBase dp = target as DataPresenterBase;

            return dp.SynchDataItemValue(value);

        }

        private static void OnActiveDataItemChanged(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = (DataPresenterBase)dependencyObject;

            dp.SynchDataItemValue(e.NewValue);
        }

        private object SynchDataItemValue(object value)
        {
            DataRecord dr = this.ActiveRecord as DataRecord;

            // try to synch up the ActiveRecord based on its DataItem
            // Note: setting the ActiveRecord can be cancelled so we
            // can't assume that the setting will take hold
            if (value == null)
            {
                // try to clear the active record
                if (dr != null && dr.DataItem != null)
                    this.ActiveRecord = null;
                else // JJD 2/09/10 - TFS26821 = we can just return here since both are null
                    return value;
            }
            else
            {
                // JJD 2/09/10 - TFS26821
                // If the ActiveRecor's DataItem matches we can just return
                if (dr != null && dr.DataItemForComparison != null &&
                    dr.DataItemForComparison == DataBindingUtilities.GetObjectForComparison(value))
                    return value;

                // attempt to get the DataRecord that is associated with this
                // data item
                dr = this.GetRecordFromDataItem(value, true);

                // synch up the ActiveRecord
                if (dr != null &&
                    dr != this.ActiveRecord)
                    this.ActiveRecord = dr;
            }

            // re-get the active datarecord in case the setting above was cancelled
            dr = this.ActiveRecord as DataRecord;

            return dr == null ? null : dr.DataItem;
        }

        /// <summary>
        /// Gets/sets the active item in the <see cref="DataSource"/> and synchronizes itself with the <see cref="ActiveRecord"/> property./>
        /// </summary>
        /// <remarks>
        /// <para class="note"><b>Note:</b> If the <see cref="ActiveRecord"/> is set to a record that is not a <see cref="DataRecord"/> then this property will be set to null.</para>
        /// </remarks>
        /// <seealso cref="ActiveDataItemProperty"/>
        /// <seealso cref="ActiveRecord"/>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Browsable(false)]
        public object ActiveDataItem
        {
            get
            {
                return (object)this.GetValue(DataPresenterBase.ActiveDataItemProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.ActiveDataItemProperty, value);
            }
        }

        #endregion //ActiveDataItem

		#region ActiveCell

		/// <summary>
		/// Identifies the <see cref="ActiveCell"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ActiveCellProperty = DependencyProperty.Register("ActiveCell",
				typeof(Cell), typeof(DataPresenterBase), 
				new FrameworkPropertyMetadata(null,
					
					
					
					
					
					new PropertyChangedCallback( OnActiveCellChangedCallback ), 

					new CoerceValueCallback(OnCoerceActiveCell)
				)
			);

		
		
		
		
		
		private static void OnActiveCellChangedCallback( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = (DataPresenterBase)dependencyObject;
			Cell newVal = (Cell)e.NewValue;

			// JJD 5/25/07 
			// If the value is being cleared instead of setting the cached value explicitly
			// call the coerce method to trigger the proper event
			if (newVal == null &&
				dp.ReadLocalValue(ActiveCellProperty) == DependencyProperty.UnsetValue)
			{
				OnCoerceActiveCell(dp, null);

				// JJD 5/25/07
				// If the clearing of the property was cancelled then call its set
				// to re-sync the dp property value with our cached value
				if (dp._activeCell != null)
					dp.ActiveCell = dp._activeCell;
			}
		}

		private Cell _cachedLastActiveCell;

		private static object OnCoerceActiveCell(DependencyObject target, object value)
		{
			DataPresenterBase control = target as DataPresenterBase;

			if (control != null)
			{
				// If the active cell is being set to null and the _clearingActiveCell
				// flag is true then return null to prevent recursion
				if (value == null &&
					control._clearingActiveCell == true)
				{
					// JJD 02/26/07 - BR18219
					// Return null and clear out the cached value since we are being cleared out 
					//return control._cachedLastActiveCell;
					control._activeCell = null;
					return null;
				}

				control._cachedLastActiveCell = control._activeCell;
				control.SetActiveCell(value as Cell);
				control._cachedLastActiveCell = null;
				return control._activeCell;
			}

			return null;
		}

		/// <summary>
		/// Gets/sets the active <see cref="Cell"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Making a <see cref="Cell"/> the <see cref="ActiveCell"/> will automatically make its corresponding <see cref="DataRecord"/> the <see cref="ActiveRecord"/>.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> Once the <see cref="Cell"/> is activated you can cause it to enter edit mode by calling <see cref="ExecuteCommand(RoutedCommand)"/> with the <see cref="DataPresenterCommands"/>' <see cref="DataPresenterCommands.StartEditMode"/> command. The cell will only enter edit mode if its corresponding <see cref="Field"/>'s <see cref="Field.AllowEditResolved"/> returns true.</para>
		/// </remarks>
		/// <seealso cref="Cell.IsActive"/>
		/// <seealso cref="Cell.IsInEditMode"/>
		/// <seealso cref="ActiveCellProperty"/>
		/// <seealso cref="ActiveRecord"/>
		/// <seealso cref="ActiveRecordProperty"/>
		/// <seealso cref="Cell"/>
		/// <seealso cref="CellActivating"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="RecordActivating"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		//[Description("Gets/sets the current active cell")]
		//[Category("Behavior")]
		public Cell ActiveCell
		{
			get
			{
				// JJD 2/21/07 make sure the active record is not deleted
				this.VerifyActiveRecordNotDeleted();

				return this._activeCell;
			}
			set
			{
				this.SetValue(DataPresenterBase.ActiveCellProperty, value);
			}
		}

		#endregion //ActiveCell

		#region ActiveRecord

		/// <summary>
		/// Identifies the <see cref="ActiveRecord"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ActiveRecordProperty = DependencyProperty.Register("ActiveRecord",
				typeof(Record), typeof(DataPresenterBase), 
				new FrameworkPropertyMetadata(null,
					
					
					
					
					
					
					new PropertyChangedCallback( OnActiveRecordChangedCallback ), 
					
					new CoerceValueCallback(OnCoerceActiveRecord)
				)
			);

		
		
		
		
		
		private static void OnActiveRecordChangedCallback( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = (DataPresenterBase)dependencyObject;
			Record newVal = (Record)e.NewValue;

			// JJD 5/25/07 
			// If the value is being cleared instead of setting the cached value explicitly
			// call the coerce method to trigger the proper event
			if (newVal == null &&
				dp.ReadLocalValue(ActiveRecordProperty) == DependencyProperty.UnsetValue)
			{
				OnCoerceActiveRecord(dp, null);

				// JJD 5/25/07
				// If the clearing of the property was cancelled then call its set
				// to re-sync the dp property value with our cached value
				if (dp._activeRecord != null)
					dp.ActiveRecord = dp._activeRecord;
			}

            // JJD 10/15/09 - TFS23531 - added ActiveDataItem
            // Synchronize the ActiveDataItem
            DataRecord dr = dp.ActiveRecord as DataRecord;

            dp.ActiveDataItem = dr == null ? null : dr.DataItem;

            // JJD 11/11/09 - TFS24665
            // Clear any pending cached record presenter
            dp.ClearPendingActiveRecordPresenter();
		}

		private static object OnCoerceActiveRecord(DependencyObject target, object value)
		{
			DataPresenterBase control = target as DataPresenterBase;

			if (control != null)
			{
				control.SetActiveRecord(value as Record, true);
				return control._activeRecord;
			}

			return null;
		}

		/// <summary>
		/// Gets/sets the active <see cref="Record"/>
		/// </summary>
		/// <remarks>
		/// <para class="body">Changing the <see cref="ActiveRecord"/> will automatically clear the <see cref="ActiveCell"/>. Also, if this property is set to a <see cref="DataRecord"/> then the <see cref="ActiveDataItem"/> property will be synchronized to the record's <see cref="DataRecord.DataItem"/> value.</para>
		/// <para></para>
		/// <para class="body">If the <see cref="ActiveCell"/> is in edit mode changing the <see cref="ActiveRecord"/> will cause the cell to end edit mode.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>Since <see cref="Record"/> is an abstract base class for <see cref="DataRecord"/>, <see cref="GroupByRecord"/> and <see cref="ExpandableFieldRecord"/> you may have to cast this property to the appropiate derived class to access specific properties, e.g. the <see cref="DataRecord"/>'s <see cref="DataRecord.Cells"/> collection.</para>
		/// </remarks>
		/// <seealso cref="Record.IsActive"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="RecordActivating"/>
		/// <seealso cref="RecordActivated"/>
		/// <seealso cref="RecordDeactivating"/>
		/// <seealso cref="CellDeactivating"/>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="ActiveCellProperty"/>
		/// <seealso cref="ActiveDataItem"/>
		/// <seealso cref="ActiveDataItemProperty"/>
		/// <seealso cref="ActiveRecordProperty"/>
		/// <seealso cref="CellActivating"/>
		/// <seealso cref="CellActivated"/>
		/// <seealso cref="CellDeactivating"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		//[Description("Gets/sets the current active record")]
		//[Category("Behavior")]
		public Record ActiveRecord
		{
			get
			{
				// JJD 9/19/06 
				// return the cached value instead of calling GetValue.
				// This is so the correct value is returned while inside
				// the OnCoerceActiveRecord method
				//return (Record)this.GetValue(DataPresenterBase.ActiveRecordProperty);

				// JJD 2/21/07 make sure the active record is not deleted
				this.VerifyActiveRecordNotDeleted();

				return this._activeRecord;
			}
			set
			{
				this.SetValue(DataPresenterBase.ActiveRecordProperty, value);
			}
		}

		// SSP 12/17/08 - NAS9.1 Record Filtering
		// 
		/// <summary>
		/// Returns the value of _activeRecord member variable.
		/// </summary>
		internal Record ActiveRecordInternal
		{
			get
			{
				return _activeRecord;
			}
		}

		#endregion //ActiveRecord

		#region AutoFit

		/// <summary>
		/// Identifies the 'AutoFit' dependency property
		/// </summary>
		public static readonly DependencyProperty AutoFitProperty = DependencyProperty.Register("AutoFit",
				// AS 3/22/07 AutoFit
				//typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnAutoFitChanged)));
				typeof(bool?), typeof(DataPresenterBase), 
				new FrameworkPropertyMetadata(null, 
					new PropertyChangedCallback(OnAutoFitChanged)
					
					
					
					
					
					
					
					
				)
			);

		
#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)


		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)











#endregion // Infragistics Source Cleanup (Region)


		private static void OnAutoFitChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase control = target as DataPresenterBase;

			if (control != null)
			{
				
				
				
				
				
				bool? newVal = (bool?)e.NewValue;
				control._cachedAutoFit = newVal;

				// JJD 3/26/07
				// Update the horz and vert scrollbar visibility properties
				control.UpdateScrollBarVisibility();

                // JJD 7/21/08 - BR34098 - Optimization
                // Invalidate the generated styles asynchronously so that if alot of
                // changes are made in a tight loop that only one invalidation will take place
                //control.InvalidateGeneratedStyles(true, false);
                control.InvalidateGeneratedStylesAsync();
				// AS 3/22/07 AutoFit
				//control.OnAutoFitChanged((bool)e.OldValue, (bool)e.NewValue);
			}
		}

		// JJD 4/26/07
		// Optimization - cache the property locally
		private bool? _cachedAutoFit;

		/// <summary>
		/// Gets/sets whether the cells and labels will be sized to exactly without the need to scroll.
		/// </summary>
		/// <remarks>
		/// <p class="body">When <see cref="AutoFit"/> is set to a boolean value then the <see cref="AutoFitResolved"/> property returns that value. Otherwise 
		/// when AutoFit is left to its default value - null (Nothing in VB) - the current <see cref="XamDataPresenter.View"/>'s <see cref="ViewBase.DefaultAutoFit"/> 
		/// value is returned by AutoFitResolved.</p>
		/// <para></para>
		/// <p class="body">When AutoFitResolved returns true, then for <see cref="XamDataPresenter.View"/>s where the item size dictates the size available to the <see cref="RecordPresenter"/> the cells are sized to 
		/// fit within the record in one or both dimensions based on the View's <see cref="ViewBase.IsAutoFitHeightSupported"/> and <see cref="ViewBase.IsAutoFitWidthSupported"/> properties.</p>
		/// <para></para>
		/// <p class="body">For <see cref="XamDataPresenter.View"/>s such as <see cref="GridView"/> all the records are constrained 
		/// in one dimension based on its <see cref="XamDataGrid.ViewSettings"/>' <see cref="GridViewSettings.Orientation"/>. For example, when the Orientation is Vertical all
		/// <see cref="RecordPresenter"/>s' widths are set to exactly fit within the control so there will never be a horizontal scrollbar. 
		/// Likewise, if the Orientation is Horizontal the heights are set to exactly fit within the control so there will never be a vertical scrollbar.
		/// </p>
		/// </remarks>
		/// <seealso cref="AutoFitResolved"/>
		/// <seealso cref="ViewBase"/>
		/// <seealso cref="ViewBase.AutoFitToRecord"/>
		/// <seealso cref="ViewBase.DefaultAutoFit"/>
		/// <seealso cref="ViewBase.IsAutoFitHeightSupported"/>
		/// <seealso cref="ViewBase.IsAutoFitWidthSupported"/>
		//[Description("Gets/sets whether the grid generated to display the cells and labels will be sized to exactly fit within the DataPresenterBase")]
		//[Category("Behavior")]
		[Bindable(true)]
		// AS 3/22/07 AutoFit
		//public bool AutoFit
		[TypeConverter(typeof(Infragistics.Windows.Helpers.NullableConverter<bool>))] // AS 5/15/08 BR32816
		public bool? AutoFit
		{
			get
			{
				// AS 3/22/07 AutoFit
				//return this._cachedAutoFit;
				//return (bool?)this.GetValue(AutoFitProperty);
				// JJD 4/26/07
				// Optimization - return the locally cached property
				return this._cachedAutoFit;
			}
			set
			{
				this.SetValue(DataPresenterBase.AutoFitProperty, value);
			}
		}

		// AS 3/22/07 AutoFit
		/// <summary>
		/// Returns the resolved value for the <see cref="AutoFit"/> property.
		/// </summary>
		/// <remarks>
		/// <p class="body">When <see cref="AutoFit"/> is set to a boolean value, that value is returned. Otherwise 
		/// when AutoFit is left to its default value - null (Nothing in VB) - the current <see cref="XamDataPresenter.View"/>'s <see cref="ViewBase.DefaultAutoFit"/> 
		/// value is returned.</p>
		/// <para></para>
		/// <p class="body">For <see cref="XamDataPresenter.View"/>s where the item size dictates the size available to the <see cref="RecordPresenter"/> the cells are sized to 
		/// fit within the record in one or both dimensions based on the View's <see cref="ViewBase.IsAutoFitHeightSupported"/> and <see cref="ViewBase.IsAutoFitWidthSupported"/> properties.</p>
		/// <para></para>
		/// <p class="body">For <see cref="XamDataPresenter.View"/>s such as <see cref="GridView"/> all the records are constrained 
		/// in one dimension based on its <see cref="XamDataGrid.ViewSettings"/>' <see cref="GridViewSettings.Orientation"/>. For example, when the Orientation is Vertical all
		/// <see cref="RecordPresenter"/>s' widths are set to exactly fit within the control so there will never be a horizontal scrollbar. 
		/// Likewise, if the Orientation is Horizontal the heights are set to exactly fit within the control so there will never be a vertical scrollbar.
		/// </p>
		/// </remarks>
		/// <seealso cref="AutoFit"/>
		/// <seealso cref="ViewBase"/>
		/// <seealso cref="ViewBase.AutoFitToRecord"/>
		/// <seealso cref="ViewBase.DefaultAutoFit"/>
		/// <seealso cref="ViewBase.IsAutoFitHeightSupported"/>
		/// <seealso cref="ViewBase.IsAutoFitWidthSupported"/>
		public bool AutoFitResolved
		{
			get
			{
				//bool? autoFit = this.AutoFit;

				//if (autoFit == null)
				//    autoFit = this.CurrentViewInternal.DefaultAutoFit;

				//return autoFit.Value;
				
				// JJD 4/26/07
				// Optimization - use the locally cached property
				if (this._cachedAutoFit == null)
					return this.CurrentViewInternal.DefaultAutoFit;

				return this._cachedAutoFit.Value;
			}
		}

		
#region Infragistics Source Cleanup (Region)








#endregion // Infragistics Source Cleanup (Region)


		#endregion //AutoFit

		#region BindToSampleData

		/// <summary>
		/// Identifies the <see cref="BindToSampleData"/> dependency property
		/// </summary>
		public static readonly DependencyProperty BindToSampleDataProperty = DependencyProperty.Register("BindToSampleData",
			typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnBindToSampleDataChanged)));

		private static void OnBindToSampleDataChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase dp = target as DataPresenterBase;

			if (dp != null)
			{
				if ((bool)e.NewValue == true)
					dp.DataSource = DataBindingUtilities.GetSampleData();
				else
				{
					if (dp.DataSource == DataBindingUtilities.GetSampleData())
						dp.DataSource = null;
				}
			}
		}
		/// <summary>
		/// Sets the DataSource property to some sample data when set to true.
		/// </summary>
		/// <remarks>
		/// <para class="body">This feature is useful to see how the control looks with data at design time or if the ultimate <see cref="DataSource"/> is not available.</para>
		/// </remarks>
		/// <seealso cref="BindToSampleDataProperty"/>
		//[Description("Sets the DataSource property to some sample data")]
		//[Category("Data")]
		[DefaultValue(false)]
		public bool BindToSampleData
		{
			get
			{
				return (bool)this.GetValue(DataPresenterBase.BindToSampleDataProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.BindToSampleDataProperty, value);
			}
		}

		#endregion //BindToSampleData

		#region CalculationAdapter


		/// <summary>
		/// Identifies the <see cref="CalculationAdapter"/> dependency property
		/// </summary>
		[InfragisticsFeature(FeatureName = "XamCalculationManager", Version = "11.2")]
		public static readonly DependencyProperty CalculationAdapterProperty = DependencyProperty.Register("CalculationAdapter",
			typeof(IDataPresenterCalculationAdapter), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnCalculationAdapterChanged)));

		internal IDataPresenterCalculationAdapterInternal _calculationAdapter;

		private static void OnCalculationAdapterChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase dp = target as DataPresenterBase;

			IDataPresenterCalculationAdapterInternal oldAdapter = e.OldValue as IDataPresenterCalculationAdapterInternal;

			if (oldAdapter != null)
			{
				dp.InternalRemoveLogicalChild(oldAdapter);
				
				if (oldAdapter.DataPresenter == dp)
					oldAdapter.DataPresenter = null;
			}

			IDataPresenterCalculationAdapterInternal newAdapter = e.NewValue as IDataPresenterCalculationAdapterInternal;
			dp._calculationAdapter = newAdapter;

			if (newAdapter != null)
			{
				if (newAdapter.DataPresenter != null && newAdapter.DataPresenter != dp)
					throw new NotSupportedException(DataPresenterBase.GetString("CalculationAdapter_NotMultiUse"));

				newAdapter.DataPresenter = dp;

				dp.InternalAddLogicalChild(newAdapter);
			}
			else
			{
				if (e.NewValue != null)
					throw new NotSupportedException(DataPresenterBase.GetString("CalculationAdapter_InvalidValue"));
			}

		}

		/// <summary>
		/// Gets/sets the adapter object that allows <see cref="Field"/>s and <b>Summaries</b> to participate in a XamCalculationManager's network. 
		/// </summary>
		/// <remarks>
		/// <para class="note"><b>Note: </b> if this property is not set then all <see cref="Field"/> <see cref="Field.CalculationSettings"/>, <see cref="SummaryDefinition"/> <see cref="SummaryDefinition.CalculationSettings"/> and <see cref="FieldLayout"/> <see cref="FieldLayout.CalculationReferenceId"/> properties will be ignored.</para>
		/// </remarks>
		/// <seealso cref="CalculationAdapterProperty"/>
		/// <seealso cref="FieldLayout.CalculationReferenceId"/>
		/// <seealso cref="Field.CalculationSettings"/>
		/// <seealso cref="SummaryDefinition.CalculationSettings"/>
		[InfragisticsFeature(FeatureName = "XamCalculationManager", Version = "11.2")]
		public IDataPresenterCalculationAdapter CalculationAdapter
		{
			get
			{
				return (IDataPresenterCalculationAdapter)this.GetValue(DataPresenterBase.CalculationAdapterProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.CalculationAdapterProperty, value);
			}
		}


		#endregion //CalculationAdapter
		
		#region CellContainerGenerationMode

		/// <summary>
		/// Identifies the <see cref="CellContainerGenerationMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty CellContainerGenerationModeProperty = DependencyProperty.Register("CellContainerGenerationMode",
			typeof(CellContainerGenerationMode), typeof(DataPresenterBase), 
				new FrameworkPropertyMetadata(CellContainerGenerationMode.Recycle,
				
				
				
				
				
				
				
				//null, new CoerceValueCallback(CoerceCellContainerGenerationMode)
				new PropertyChangedCallback( OnCellContainerGenerationModeChanged )
				)
			);

		private CellContainerGenerationMode _cachedCellContainerGenerationMode;

		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)







#endregion // Infragistics Source Cleanup (Region)


		
		
		
		
		
		private static void OnCellContainerGenerationModeChanged( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = (DataPresenterBase)dependencyObject;
			CellContainerGenerationMode newVal = (CellContainerGenerationMode)e.NewValue;

			dp._cachedCellContainerGenerationMode = newVal;

			// AS 5/24/07 Recycle elements
			// We need to regenerate the styles when the cell generation
			// changes since we could go from using the grid panel within 
			// the record to not.
			//
			dp.InvalidateGeneratedStyles(true, false);
		}

		/// <summary>
		/// Gets/sets how Cell containers are generated and cached.
		/// </summary>
		/// <seealso cref="CellContainerGenerationModeProperty"/>
		/// <seealso cref="CellContainerGenerationModeProperty"/>
		//[Description("Gets/sets how Cell containers are generated and cached.")]
		//[Category("Behavior")]
		public CellContainerGenerationMode CellContainerGenerationMode
		{
			get
			{
				return (CellContainerGenerationMode)this.GetValue(DataPresenterBase.CellContainerGenerationModeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.CellContainerGenerationModeProperty, value);
			}
		}

		#endregion //CellContainerGenerationMode

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region ClipboardCellDelimiter

        /// <summary>
        /// Identifies the <see cref="ClipboardCellDelimiter"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty ClipboardCellDelimiterProperty = DependencyProperty.Register("ClipboardCellDelimiter",
            typeof(string), typeof(DataPresenterBase), new FrameworkPropertyMetadata(string.Empty));

        /// <summary>
        /// Returns or sets the string used to wrap a cell/label value when copied to the clipboard.
        /// </summary>
        /// <seealso cref="ClipboardCellDelimiterProperty"/>
        /// <seealso cref="ClipboardCellSeparator"/>
        /// <seealso cref="ClipboardRecordSeparator"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
		//[Description("Returns or sets the string used to wrap a cell/label value when copied to the clipboard.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public string ClipboardCellDelimiter
        {
            get 
            {
                return (string)this.GetValue(DataPresenterBase.ClipboardCellDelimiterProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.ClipboardCellDelimiterProperty, value);
            }
        }

        #endregion //ClipboardCellDelimiter

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region ClipboardCellSeparator

        /// <summary>
        /// Identifies the <see cref="ClipboardCellSeparator"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty ClipboardCellSeparatorProperty = DependencyProperty.Register("ClipboardCellSeparator",
            typeof(string), typeof(DataPresenterBase), new FrameworkPropertyMetadata("\t"));

        /// <summary>
        /// The string used to separate the values of cells/labels when copying to the clipboard.
        /// </summary>
        /// <seealso cref="ClipboardCellSeparatorProperty"/>
        /// <seealso cref="ClipboardCellDelimiter"/>
        /// <seealso cref="ClipboardRecordSeparator"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
		//[Description("The string used to separate the values of cells/labels when copying to the clipboard.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public string ClipboardCellSeparator
        {
            get
            {
                return (string)this.GetValue(DataPresenterBase.ClipboardCellSeparatorProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.ClipboardCellSeparatorProperty, value);
            }
        }

        #endregion //ClipboardCellSeparator

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region ClipboardRecordSeparator

        /// <summary>
        /// Identifies the <see cref="ClipboardRecordSeparator"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty ClipboardRecordSeparatorProperty = DependencyProperty.Register("ClipboardRecordSeparator",
            typeof(string), typeof(DataPresenterBase), new FrameworkPropertyMetadata(Environment.NewLine));

        /// <summary>
        /// Returns or sets the strings used to separate the values of cells from different records when copied to the clipboard.
        /// </summary>
        /// <seealso cref="ClipboardRecordSeparatorProperty"/>
        /// <seealso cref="ClipboardCellSeparator"/>
        /// <seealso cref="ClipboardCellDelimiter"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowClipboardOperations"/>
		//[Description("Returns or sets the strings used to separate the values of cells from different records when copied to the clipboard.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public string ClipboardRecordSeparator
        {
            get
            {
                return (string)this.GetValue(DataPresenterBase.ClipboardRecordSeparatorProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.ClipboardRecordSeparatorProperty, value);
            }
        }

        #endregion //ClipboardRecordSeparator

		#region CurrentView

		/// <summary>
		/// Identifies the CurrentView attached dependency property
		/// </summary>
		/// <remarks>
		/// <para class="body">This property is set on Custom View Panels (i.e. panels that implement the <see cref="IViewPanel"/> interface.</para>
		/// <para>
		/// </para>
		/// <para class="note"><b>Note: </b>Unless you are implementing a custom view you should ignore this property.</para>
		/// </remarks>
		public static readonly DependencyProperty CurrentViewProperty = DependencyProperty.RegisterAttached("CurrentView",
			typeof(ViewBase), typeof(DataPresenterBase), new FrameworkPropertyMetadata((ViewBase)null));

		/// <summary>
		/// For internal use only.
		/// </summary>
		[EditorBrowsable( EditorBrowsableState.Never )]
		public static ViewBase GetCurrentView(DependencyObject d)
		{
			return (ViewBase)d.GetValue(DataPresenterBase.CurrentViewProperty);
		}

		/// <summary>
		/// For internal use only.
		/// </summary>
		[EditorBrowsable( EditorBrowsableState.Never )]
		public static void SetCurrentView(DependencyObject d, ViewBase value)
		{
			d.SetValue(DataPresenterBase.CurrentViewProperty, value);
		}

		#endregion //CurrentView

		#region DataErrorContentTemplateKey

		// SSP 4/21/09 NAS9.2 IDataErrorInfo Support
		// 
		/// <summary>
		/// The key that identifies a resource to be used as the content template (DataTemplate) 
		/// of the ContentPresenter in CellValuePresenter for displaying data error icons.
		/// </summary>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SupportDataErrorInfo"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_IDataErrorInfo, Version = FeatureInfo.Version_9_2 )]
		public static readonly ResourceKey DataErrorContentTemplateKey = new StaticPropertyResourceKey( typeof( DataPresenterBase ), "DataErrorContentTemplateKey" );

		#endregion DataErrorContentTemplateKey

		#region DataErrorIconStyleKey

		// SSP 4/21/09 NAS9.2 IDataErrorInfo Support
		// 
		/// <summary>
		/// The key that identifies a resource to be used as the style for the control
		/// that displays error icon in the record selector as well as the cell.
		/// </summary>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SupportDataErrorInfo"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_IDataErrorInfo, Version = FeatureInfo.Version_9_2 )]
		public static readonly ResourceKey DataErrorIconStyleKey = new StaticPropertyResourceKey( typeof( DataPresenterBase ), "DataErrorIconStyleKey" );

		#endregion DataErrorIconStyleKey

		#region DataItems

		/// <summary>
		/// Returns a collection used to add items directly into the control.
		/// </summary>
		/// <remarks>
		/// <para class="body">This property is specified as the control's 'Content' property which means that in xaml you can add items to this collection without having to explicitly create enclosing tags identifying this property. Any objects specified within the control's tags will automatically get added to this collection.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>This property is mutually exclusive with the <see cref="DataSource"/> property, trying to set the <see cref="DataSource"/> property and add items directly to this collection will cause an InvalidOperationException to be thrown.</para>
		/// </remarks>
		/// <seealso cref="ViewableRecords"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Records"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.DataItem"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Current"/>
		/// <seealso cref="DataSource"/>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public DataItemsCollection DataItems
		{
			get
			{
				if (this._dataItems == null)
					this._dataItems = new DataItemsCollection(this);

				return this._dataItems;
			}
		}

		#endregion //DataItems

 		#region DataSource

		/// <summary>
		/// Identifies the <see cref="DataSource"/> dependency property
		/// </summary>
		public static readonly DependencyProperty DataSourceProperty = DependencyProperty.Register("DataSource",
			typeof(IEnumerable), typeof(DataPresenterBase), new FrameworkPropertyMetadata());

        /// <summary>
		/// Gets/sets the source of the data to any object that implements the <see cref="System.Collections.IEnumerable"/>interface.
		/// </summary>
		/// <remarks>
        /// <para class="body">Any object that implements the <see cref="System.Collections.IEnumerable"/> interface (other than a string) can be 
		/// set as the DataSource. The architecture can support both hierarchical and heterogenous data (multiple data types within a single list) as well as more free-form structures like trees (e.g. XML data sources). There are 
		/// currently some limitations, e.g. the <see cref="GroupByArea"/> only displays the <see cref="FieldLayout.Fields"/> from the <see cref="DefaultFieldLayout"/> 
		/// so users can't groupby <see cref="Field"/>s from multiple types as would be the case with heterogeneous data or data from child records.</para>
		/// <para></para>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily to represent each item in the DataSource. The <see cref="DataRecord"/> exposes a read-only <see cref="DataRecord.DataItem"/> property that returns the associated item from the data source as well as a corresponding <see cref="DataRecord.DataItemIndex"/> property.
		/// These <see cref="DataRecord"/>s are managed by the <see cref="RecordManager"/> and exposed via its <see cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/>, <see cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/> and <see cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/> collection properties.</para>  
		/// <para></para>
		/// <para class="body">When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised. 
		/// If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>This property is mutually exclusive with the <see cref="DataItems"/> property, trying to set this property and add items directly to the <see cref="DataItems"/> collection will cause an InvalidOperationException to be thrown.</para>
		/// </remarks>
		/// <exception cref="InvalidOperationException">Attempting to set this property after items have been added directly to the <see cref="DataItems"/> collection property.</exception>
        /// /// <exception cref="InvalidOperationException">Attempting to set this property when the <see cref="IsExporting"/> property is true.</exception>
		/// <seealso cref="ViewableRecords"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Records"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.DataItem"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Current"/>
		/// <seealso cref="DataItems"/>
		/// <seealso cref="DataSourceProperty"/>
		//[Description("Gets/sets the source for the data")]
		//[Category("Content")]
		[Bindable(true)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public IEnumerable DataSource
		{
			get
			{
				return (IEnumerable) this.GetValue(DataPresenterBase.DataSourceProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.DataSourceProperty, value);
			}
		}

		#endregion //DataSource

		#region DataSourceResetBehavior

		// SSP 2/11/10 - TFS26273 - Added DataSourceResetBehavior property
		// 

		/// <summary>
		/// Identifies the <see cref="DataSourceResetBehavior"/> dependency property.
		/// </summary>
		public static readonly DependencyProperty DataSourceResetBehaviorProperty = DependencyProperty.Register(
			"DataSourceResetBehavior",
			typeof( DataSourceResetBehavior ),
			typeof( DataPresenterBase ),
			new FrameworkPropertyMetadata( DataSourceResetBehavior.ReuseRecordsViaEnumerator, FrameworkPropertyMetadataOptions.None )
		);

		/// <summary>
		/// Specifies what action to take when <i>Reset</i> notification is recieved from the data source.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// By default the data presenter will keep existing data records whose underlying data items are still
		/// in the data list when the data list sends a <i>Reset</i> notification. It does so by looping through 
		/// the data list and for each underlying data item finding corresponding data record. It keeps all
		/// such data records for which corresponding data items are still in the underlying list so it doesn't 
		/// have to re-create them.
		/// </para>
		/// <para class="body">
		/// Above process may be undesirable if your underlying data list is virtualized - that is it is delaying
		/// loading its data as the data items are accessed. In which case you can set the <b>DataSourceResetBehavior</b>
		/// property to either <i>DiscardExistingRecords</i> or <i>ReuseRecordsViaIndexOf</i> which will prevent
		/// the data presenter from looping through the data list and thus accessing all the data items. 
		/// See <see cref="Infragistics.Windows.DataPresenter.DataSourceResetBehavior"/> for more formation regarding
		/// what each of these options do. <b>Note</b> however that the in above process the data items are accessed from
		/// the list however properties off the data items are not accessed.
		/// </para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.DataSourceResetBehavior"/>
		/// <seealso cref="RecordLoadMode"/>
		//[Description( "Specifies what action to take when Reset notification is recieved from data source." )]
		//[Category( "Data" )]
		[Bindable( true )]
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]
		public DataSourceResetBehavior DataSourceResetBehavior
		{
			get
			{
				return (DataSourceResetBehavior)this.GetValue( DataSourceResetBehaviorProperty );
			}
			set
			{
				this.SetValue( DataSourceResetBehaviorProperty, value );
			}
		}

		#endregion // DataSourceResetBehavior

		#region DefaultFieldLayout

		/// <summary>
		/// Gets/sets the default <see cref="FieldLayout"/>
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created the <see cref="FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="FieldLayoutInitializing"/> and <see cref="FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <b>FieldLayoutInitializing</b> and <b>FieldLayoutInitialized</b> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="InitializeRecord"/> event is raised.</para>
		/// <para></para>
		/// <para class="body">Among other things the DefaultFieldLayout determines which <see cref="Field"/>s show up in the <see cref="GroupByArea"/>. It can be set thru this property or via the <see cref="FieldLayout"/>'s <see cref="FieldLayout.IsDefault"/> property. If not set explicitly this property will return the first one in the <see cref="FieldLayouts"/> colelction that has at least one <see cref="DataRecord"/> assigned.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="FieldLayout.IsDefault"/>
		/// <seealso cref="FieldLayouts"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="AssigningFieldLayoutToItem"/>
		/// <seealso cref="FieldLayoutInitializing"/>
		/// <seealso cref="FieldLayoutInitialized"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		public FieldLayout DefaultFieldLayout
		{
			get
			{
				// JJD 08/17/12 - TFS119037
				// Verify that the cached _defaultLayout was not removed from the collection
				if (this._defaultLayout != null && _defaultLayout.WasRemovedFromCollection)
					_defaultLayout = null;

				if (this._defaultLayout == null &&
					 this._fieldLayouts != null &&
					this._fieldLayouts.Count > 0)
				{
					// JM 04-30-09 TFS 16615 - If the developer has pre-defined a FieldLayout in the FieldLayouts collection for a 
					// child band but NOT for the root band, then calling this._fieldLayouts.GetDefaultFieldLayout() will actually 
					// return the child band because it would be the first FieldLayout encountered in the FieldLayouts collection 
					// with at least 1 record loaded.  A more reliable way to do this is to return our RecordManager's FieldLayout
					// property if we have one.
					if (this.RecordManager != null && this.RecordManager.FieldLayout != null)
						return this.RecordManager.FieldLayout;

					return this._fieldLayouts.GetDefaultFieldLayout();
				}

				return this._defaultLayout;
			}
			set
			{
				if (value != null &&
					!this.FieldLayouts.Contains(value))
					throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_3"));

				this._defaultLayout = value;
			}
		}

		#endregion //DefaultFieldLayout

		// AS 3/3/11 NA 2011.1 - Async Exporting
		#region ExportStatus

		private RecordExportStatus _cachedExportStatus;

		private static readonly DependencyPropertyKey ExportStatusPropertyKey =
			DependencyProperty.RegisterReadOnly("ExportStatus",
			typeof(RecordExportStatus), typeof(DataPresenterBase), new FrameworkPropertyMetadata(RecordExportStatus.NotExporting, new PropertyChangedCallback(OnExportStatusChanged)));

		private static void OnExportStatusChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase dp = d as DataPresenterBase;

			RecordExportStatus status = (RecordExportStatus)dp.GetValue(ExportStatusProperty);
			dp._cachedExportStatus = status;
			dp.IsExporting = status != RecordExportStatus.NotExporting;
		}

		/// <summary>
		/// Identifies the <see cref="ExportStatus"/> dependency property
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public static readonly DependencyProperty ExportStatusProperty =
			ExportStatusPropertyKey.DependencyProperty;

		/// <summary>
		/// Returns a value indicating the status of the current export operation of this DataPresenter.
		/// </summary>
		/// <seealso cref="ExportStatusProperty"/>
		[Bindable(true)]
		[ReadOnly(true)]
		[Browsable(false)]
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public RecordExportStatus ExportStatus
		{
			get
			{
				return _cachedExportStatus;
			}
			internal set
			{
				this.SetValue(ExportStatusPropertyKey, value);
			}
		}

		#endregion //ExportStatus

		#region FieldChooserButtonStyleKey

		
		

		/// <summary>
		/// The key that identifies a resource to be used as the style for the field chooser button within a 
		/// <see cref="HeaderPrefixArea"/>. See <see cref="DataPresenterBrushKeys" /> for an explanation of 
		/// how these keys are used. 
		/// </summary>
		public static readonly ResourceKey FieldChooserButtonStyleKey = new StaticPropertyResourceKey( typeof( DataPresenterBase ), "FieldChooserButtonStyleKey" );

		#endregion FieldChooserButtonStyleKey

		#region FieldLayouts

		/// <summary>
		/// Returns the collection of <see cref="FieldLayout"/> objects (read-only)
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created lazily as each item in the <see cref="DataPresenterBase.DataSource"/> is requested. 
		/// When a <see cref="DataRecord"/> is created <see cref="DataPresenterBase"/>'s <see cref="DataPresenterBase.FieldLayouts"/> collection is searched for an existing <see cref="FieldLayout"/> 
		/// whose <see cref="FieldLayout.Fields"/> match the <see cref="DataRecord.DataItem"/>'s properties. If one is not found then
		/// a new <see cref="FieldLayout"/> is created, in which case the <see cref="DataPresenterBase.FieldLayoutInitializing"/> and <see cref="DataPresenterBase.FieldLayoutInitialized"/> events will be raised.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>If the new <see cref="FieldLayout"/>'s <see cref="FieldLayout.AutoGenerateFieldsResolved"/> property returns true then the <see cref="FieldLayout.Fields"/> collection is automatically populated with a <see cref="Field"/> for every public property on the data item. This is done between the <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayoutInitializing"/> and <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase.FieldLayoutInitialized"/> events.</para>
		/// <para></para>
		/// <para class="body">In any case the <see cref="DataPresenterBase.AssigningFieldLayoutToItem"/> event is raised to allow a different <see cref="FieldLayout"/> to be assigned to the <see cref="DataRecord"/>. Finally the <see cref="DataPresenterBase.InitializeRecord"/> event is raised.</para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Layout.html">Field Layout</a> topic in the Developer's Guide for an explanation of the FieldLayout object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how everything works together.</p>
		/// </remarks>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="FieldLayoutCollection"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public FieldLayoutCollection FieldLayouts
		{
			get
			{
				if (this._fieldLayouts == null)
					this._fieldLayouts = new FieldLayoutCollection(this);

				return this._fieldLayouts;
			}
		}

		
		
		/// <summary>
		/// Returns the value of the _fieldLayouts member variable.
		/// </summary>
		internal FieldLayoutCollection FieldLayoutsIfAllocated
		{
			get
			{
				return _fieldLayouts;
			}
		}

		/// <summary>
		/// Determines if the <see cref="FieldLayouts"/> collection has any items.
		/// </summary>
		/// <returns>True if the collection should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeFieldLayouts()
		{
			return this._fieldLayouts != null && this._fieldLayouts.ShouldSerialize();
		}

		/// <summary>
		/// Clears the <see cref="FieldLayouts"/> collection
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetFieldLayouts()
		{
			if (this.ShouldSerializeFieldLayouts())
				this._fieldLayouts.Clear();
		}

		#endregion //FieldLayouts

		#region FieldLayoutSettings

		/// <summary>
		/// Identifies the 'FieldLayoutSettings' dependency property
		/// </summary>
		public static readonly DependencyProperty FieldLayoutSettingsProperty = DependencyProperty.Register("FieldLayoutSettings",
				typeof(FieldLayoutSettings), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new CoerceValueCallback(CoerceFieldLayoutSettings)));

        // JJD 01/05/10 - TFS25423 
        // added coerce
        private static object CoerceFieldLayoutSettings(DependencyObject target, object value )
        {
            DataPresenterBase dp = target as DataPresenterBase;

            // JJD 01/05/10 - TFS25423 
            // If we aren't in design mode and the value is null return the FieldLayoutSettings
            // property which willl never return null. THis is instead on setting the porperty in
            // OnInitialized which prevents style setting from being applied
            if (value == null &&
                 !DesignerProperties.GetIsInDesignMode(dp))
            {
                return dp.FieldLayoutSettings;
            }

            return value;
        }

		private void OnFieldLayoutSettingsPropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			// SSP 4/23/08 - Summaries Functionality
			// Added infrastructure so field, field layout and the data presenter can each process
			// change in field settings of any of these objects.
			// When the DataPresenter's FieldLayoutSettings' property changes, datapresenter as well
			// as all the field layouts may need to take their own specific actions.
			// Added new ProcessFieldLayoutSettingsPropertyChanged method on both the FieldLayout
			// and DataPresenterBase. Previous code to invalidate the generated styles was moved
			// into DataPresenterBase.ProcessFieldLayoutSettingsPropertyChanged method.
			// 
			// --------------------------------------------------------------------------------------
			if ( null != _fieldLayouts )
			{
				foreach ( FieldLayout fl in _fieldLayouts )
					FieldLayout.ProcessFieldLayoutSettingsPropertyChanged( e, _x_FieldLayoutSettings, this, false, fl, this );
			}

			FieldLayout.ProcessFieldLayoutSettingsPropertyChanged( e, _x_FieldLayoutSettings, this, true, null, this );
			
#region Infragistics Source Cleanup (Region)









#endregion // Infragistics Source Cleanup (Region)

			// --------------------------------------------------------------------------------------
		}

		private FieldLayoutSettings _x_FieldLayoutSettings = null;

		/// <summary>
		/// Holds the default settings for all <see cref="FieldLayout"/>s in this control.
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="FieldLayoutSettings"/> objects are exposed via the following 2 properties:
		/// <ul>
		/// <li><see cref="DataPresenterBase"/>'s <see cref="DataPresenterBase.FieldLayoutSettings"/> - settings specified here become the default for all <see cref="FieldLayout"/>s in the <see cref="DataPresenterBase.FieldLayouts"/> collection.</li>
		/// <li><see cref="FieldLayout"/>'s <see cref="FieldLayout.Settings"/> - settings specified here apply to only this one specific <see cref="FieldLayout"/>.</li>
		/// </ul>
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldLayouts"/>
		/// <seealso cref="DefaultFieldLayout"/>
		/// <seealso cref="FieldLayout"/>
		/// <seealso cref="FieldLayout.Settings"/>
		/// <seealso cref="FieldSettings"/>
		//[Description("Holds the default settings for fields")]
		//[Category("Behavior")]
		public FieldLayoutSettings FieldLayoutSettings
		{
			get
			{
				if (this._x_FieldLayoutSettings == null)
				{
                    // JJD 12/21/07
                    // Don't lazy create this object at design time.
                    // This will allow the VS2008 designer to work properly 
                    if (!DesignerProperties.GetIsInDesignMode(this))
                    {
                        this._x_FieldLayoutSettings = new FieldLayoutSettings();
						// JJD 8/18/20 - TFS36399 
						// Use PropertyChangedEventManager.AddListener instead so
						// we don't risk rooting the DP.
						//this._x_FieldLayoutSettings.PropertyChanged += new PropertyChangedEventHandler(this.OnFieldLayoutSettingsPropertyChanged);
                        PropertyChangedEventManager.AddListener( this._x_FieldLayoutSettings, this, string.Empty );
                    }
				}

				return this._x_FieldLayoutSettings;
			}
			set
			{
				this.SetValue(DataPresenterBase.FieldLayoutSettingsProperty, value);
			}
		}

		// SSP 2/21/08 - Optimizations
		// 
		internal FieldLayoutSettings FieldLayoutSettingsIfAllocated
		{
			get
			{
				return _x_FieldLayoutSettings;
			}
		}

		/// <summary>
		/// Determines if the <see cref="FieldLayoutSettings"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeFieldLayoutSettings()
		{
			return this._x_FieldLayoutSettings != null && this._x_FieldLayoutSettings.ShouldSerialize();
		}

		/// <summary>
		/// Resets the <see cref="FieldLayoutSettings"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetFieldLayoutSettings()
		{
            if (this.ShouldSerializeFieldLayoutSettings())
            {
                // JJD 12/21/07
                // At design time clear the value instead on re-initializing it to a new instance.
                // This will allow the VS2008 designer to work properly 
                if (DesignerProperties.GetIsInDesignMode(this))
                    this.ClearValue(FieldLayoutSettingsProperty);
                else
                    this.FieldLayoutSettings = new FieldLayoutSettings();
            }
		}

		#endregion //FieldLayoutSettings

		#region FieldSettings

		/// <summary>
		/// Identifies the 'FieldSettings' dependency property
		/// </summary>
		public static readonly DependencyProperty FieldSettingsProperty = DependencyProperty.Register("FieldSettings",
				typeof(FieldSettings), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new CoerceValueCallback(CoerceFieldSettings)));

        // JJD 01/05/10 - TFS25423 
        // added coerce
        private static object CoerceFieldSettings(DependencyObject target, object value )
        {
            DataPresenterBase dp = target as DataPresenterBase;

            // JJD 01/05/10 - TFS25423 
            // If we aren't in design mode and the value is null return the FieldLayoutSettings
            // property which willl never return null. THis is instead on setting the porperty in
            // OnInitialized which prevents style setting from being applied
            if (value == null &&
                 !DesignerProperties.GetIsInDesignMode(dp))
            {
                return dp.FieldSettings;
            }

            return value;
        }

		private void OnFieldSettingsPropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			// SSP 4/23/08 - Summaries Functionality
			// Added infrastructure so field, field layout and the data presenter can each process
			// change in field settings of any of these objects. Previous code was moved into the
			// ProcessFieldSettingsPropertyChanged new method.
			// ------------------------------------------------------------------------------------
			if ( null != _fieldLayouts )
			{
				// First process it on each field.
				foreach ( FieldLayout fieldLayout in _fieldLayouts )
				{
					FieldCollection fields = fieldLayout.FieldsIfAllocated;
					if ( null != fields )
					{
						foreach ( Field field in fields )
							Field.ProcessFieldSettingsPropertyChanged( e, _x_FieldSettings, this, 
								false, false, field, fieldLayout, this );
					}

					Field.ProcessFieldSettingsPropertyChanged( e, _x_FieldSettings, this, false, true, null, fieldLayout, this );
				}
			}

			Field.ProcessFieldSettingsPropertyChanged( e, _x_FieldSettings, this, true, false, null, null, this );

			
#region Infragistics Source Cleanup (Region)













#endregion // Infragistics Source Cleanup (Region)

		}

		private FieldSettings _x_FieldSettings = null;

		/// <summary>
		/// Holds the default settings for all fields in this control.
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="FieldSettings"/> are exposed via the following 3 properties:
		/// <ul>
		/// <li><see cref="DataPresenterBase"/>'s <see cref="DataPresenterBase.FieldSettings"/> - settings specified here become the default for all <see cref="Field"/>s in every <see cref="FieldLayout"/>.</li>
		/// <li><see cref="FieldLayout"/>'s <see cref="FieldLayout.FieldSettings"/> - settings specified here become the default for all <see cref="Field"/>s in this <see cref="FieldLayout"/>'s <see cref="FieldLayout.Fields"/> collection.</li>
		/// <li><see cref="Field"/>'s <see cref="Field.Settings"/> - settings specified here apply to only this one specific <see cref="Field"/>.</li>
		/// </ul>
		/// </para>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields.html">Fields</a> topic in the Developer's Guide for an explanation of fields.</p>
		/// <p class="body">Refer to the <a href="xamData_Terms_Fields_Field_Settings.html">Field Settings</a> topic in the Developer's Guide for an explanation of the FieldSettings object.</p>
		/// <p class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an explanation of how this object is used.</p>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="FieldLayout.FieldSettings"/>
		/// <seealso cref="Field.Settings"/>
		//[Description("Holds the default settings for fields")]
		//[Category("Behavior")]
		public FieldSettings FieldSettings
		{
			get
			{
				if (this._x_FieldSettings == null)
				{
                    // JJD 12/21/07
                    // Don't lazy create this object at design time.
                    // This will allow the VS2008 designer to work properly 
                    if (!DesignerProperties.GetIsInDesignMode(this))
                    {
                        this._x_FieldSettings = new FieldSettings();

						// JJD 8/18/20 - TFS36399 
						// Use PropertyChangedEventManager.AddListener instead so
						// we don't risk rooting the DP.
						//this._x_FieldSettings.PropertyChanged += new PropertyChangedEventHandler(this.OnFieldSettingsPropertyChanged);
						PropertyChangedEventManager.AddListener(this._x_FieldSettings, this, string.Empty);
                    }
				}

				return this._x_FieldSettings;
			}
			set
			{
				this.SetValue(DataPresenterBase.FieldSettingsProperty, value);
			}
		}

		// SSP 2/21/08 - Optimizations
		// 
		internal FieldSettings FieldSettingsIfAllocated
		{
			get
			{
				return _x_FieldSettings;
			}
		}

		/// <summary>
		/// Determines if the <see cref="FieldSettings"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeFieldSettings()
		{
			return this._x_FieldSettings != null && this._x_FieldSettings.ShouldSerialize();
		}

		/// <summary>
		/// Resets the <see cref="FieldSettings"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetFieldSettings()
		{
            if (this.ShouldSerializeFieldSettings())
            {
                // JJD 12/21/07
                // At design time clear the value instead on re-initializing it to a new instance.
                // This will allow the VS2008 designer to work properly 
                if (DesignerProperties.GetIsInDesignMode(this))
                    this.ClearValue(FieldSettingsProperty);
                else
                    this.FieldSettings = new FieldSettings();
            }
		}

		#endregion //FieldSettings

        // JJD 12/30/08 NA 2009 Vol 1 - Record filtering
        #region FilterCellClearButtonStyleKey

        /// <summary>
        /// The key that identifies a resource to be used as the style for the clear button within a <see cref="FilterCellValuePresenter"/>.  Look here <see cref="DataPresenterBrushKeys" /> for 
        /// an explanation of how these keys are used. 
        /// </summary>
        public static readonly ResourceKey FilterCellClearButtonStyleKey = new StaticPropertyResourceKey(typeof(DataPresenterBase), "FilterCellClearButtonStyleKey");

        #endregion FilterCellClearButtonStyleKey

		// JJD 07/06/10 - TFS32174 - added
		#region FilterDropDownLoadingTemplateKey

        /// <summary>
        /// The key that identifies a resource to be used as the DataTemplate for the loading indicator in the filter drop down.  Look here <see cref="DataPresenterBrushKeys" /> for 
        /// an explanation of how these keys are used. 
        /// </summary>
		public static readonly ResourceKey FilterDropDownLoadingTemplateKey = new StaticPropertyResourceKey(typeof(DataPresenterBase), "FilterDropDownLoadingTemplateKey");

		#endregion FilterDropDownLoadingTemplateKey

		// JJD 12/30/08 NA 2009 Vol 1 - Record filtering
        #region FilterRecordClearButtonStyleKey

        /// <summary>
        /// The key that identifies a resource to be used as the style for the clear button within the <see cref="RecordSelector"/> in a <see cref="DataRecordPresenter"/> for a <see cref="FilterRecord"/>.  Look here <see cref="DataPresenterBrushKeys" /> for 
        /// an explanation of how these keys are used. 
        /// </summary>
        public static readonly ResourceKey FilterRecordClearButtonStyleKey = new StaticPropertyResourceKey(typeof(DataPresenterBase), "FilterRecordClearButtonStyleKey");

        #endregion FilterRecordClearButtonStyleKey

        #region GroupByArea

        #region Old code

        
#region Infragistics Source Cleanup (Region)

















































#endregion // Infragistics Source Cleanup (Region)


        #endregion //Old code	
    
        /// <summary>
        /// Identifies the <see cref="GroupByArea"/> dependency property
        /// </summary>
        public static readonly DependencyProperty GroupByAreaProperty = DependencyProperty.Register("GroupByArea",
            typeof(GroupByArea), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnGroupByAreaChanged)));

        private static void OnGroupByAreaChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = target as DataPresenterBase;

            if (dp != null)
            {
                GroupByArea oldGBA = e.OldValue as GroupByArea;

                if (oldGBA != null)
                {
                    oldGBA.InitializeDataPresenter(null);

                    // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                    // If the old groupbyarea is a logical child of us 
                    // remove it 
                    if (oldGBA.Parent == dp)
                        dp.InternalRemoveLogicalChild(oldGBA);
                }

                dp._groupByArea = e.NewValue as GroupByArea;

                if (dp._groupByArea != null)
                {
                    dp._groupByArea.InitializeDataPresenter(dp);

                    // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                    // If the groupbyarea doesn't have a logical parent
                    // then add it as a logical child of the dp
                    if (dp.IsInitialized && dp._groupByArea.Parent == null)
                        dp.InternalAddLogicalChild(dp._groupByArea);
                }

                dp.SetGroupByAreaStyle();
                dp.VerifyGroupByAreaLocation();
            }
        }

		private void SetGroupByAreaStyle()
		{
			if (this._groupByArea == null)
				return;

			Style style = this.GroupByAreaStyle;

            // JJD 10/29/08 - TFS6369 - BR35008
            // Don't touch the style property unless it is different than the GroupByAreaStyle
            // property
            if (style != null && style != this._groupByArea.Style)
                this._groupByArea.Style = style;
 
		}

        /// <summary>
        /// Returns the <see cref="Infragistics.Windows.DataPresenter.GroupByArea"/> 
        /// </summary>
        /// <remarks>
        /// <p class="body">The GroupByArea provides a UI for grouping data records based on <see cref="Field"/>s defined in the <see cref="DataPresenterBase.DefaultFieldLayout"/>.  Since there is only one 
        /// <see cref="DataPresenterBase.DefaultFieldLayout"/>, the GroupByArea can only provide a grouping UI for that <see cref="FieldLayout"/>.  By default, the <see cref="DataPresenterBase.DefaultFieldLayout"/>
        /// is set to the FieldLayout associated with the first DataRecord encountered.  When bound to flat homogeneous data this is not an issue since there is only one FieldLayout.  Keep in mind that if
        /// the control is bound to non-homogeneous data or hierarchical data the grouping UI will only show the <see cref="Field"/>s from the <see cref="DataPresenterBase.DefaultFieldLayout"/>.</p>
        /// <p class="note"><b>Note: </b>To support grouping of heterogenous data or hierarchical data use the <see cref="GroupByAreaMulti"/> property and set the <see cref="GroupByAreaMode"/> property 
        /// to <b>MultipleFieldLayoutsFull</b> or <b>MultipleFieldLayoutsCompact</b>.</p>
        /// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
        /// </remarks>
        /// <seealso cref="GroupByAreaLocation"/>
        /// <seealso cref="GroupByAreaMode"/>
        /// <seealso cref="GroupByAreaMulti"/>
        /// <seealso cref="GroupByRecord"/>
        /// <seealso cref="RecordManager"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowGroupBy"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByComparer"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByEvaluator"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByMode"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByRecordPresenterStyle"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByRecordPresenterStyleSelector"/>
        /// <seealso cref="FieldLayout.SortedFields"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription.IsGroupBy"/>
        //[Description("Returns/sets the GroupByArea that is used for Outlook style grouping.")]
        //[Category("Behavior")]
        [Bindable(true)]
        public GroupByArea GroupByArea
        {
            get
            {
                return this._groupByArea;
            }
            set
            {
                this.SetValue(DataPresenterBase.GroupByAreaProperty, value);
            }
        }

        #endregion //GroupByArea

		#region GroupByAreaFieldLabelStyle

		/// <summary>
		/// Identifies the <see cref="GroupByAreaFieldLabelStyle"/> dependency property
		/// </summary>
		public static readonly DependencyProperty GroupByAreaFieldLabelStyleProperty = DependencyProperty.Register("GroupByAreaFieldLabelStyle",
			typeof(Style), typeof(DataPresenterBase), new FrameworkPropertyMetadata((object)null));

		/// <summary>
		/// Gets/sets the style to be used for <see cref="GroupByAreaFieldLabel"/>s.  By default, this property returns null which indicates that an internally generated default style should be used.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
        /// <p class="body">Refer to the <a href="WPF_Working_with_xamDataGrid_xamDataCarousel_and_xamDataPresenter_Styling_Points.html">Working with xamDataGrid, xamDataCarousel and xamDataPresenter Styling Points</a> topic in the Developer's Guide for an explanation of how to style the control.</p>
		/// </remarks>
		/// <seealso cref="GroupByArea"/>
		/// <seealso cref="GroupByAreaLocation"/>
		/// <seealso cref="GroupByAreaFieldLabel"/>
		/// <seealso cref="GroupByAreaFieldLabelStyleSelector"/>
		/// <seealso cref="GroupByAreaFieldLabelCollection"/>
		/// <seealso cref="GroupByAreaLocation"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowGroupBy"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByComparer"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByEvaluator"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByMode"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription.IsGroupBy"/>
		//[Description("Gets/sets the style to be used for the GroupByAreaFieldLabels.  By default, this property returns null which indicates that an internally generated default style should be used.")]
		//[Category("Appearance")]
		[Bindable(true)]
		[DefaultValue(null)]
		public Style GroupByAreaFieldLabelStyle
		{
			get
			{
				return (Style)this.GetValue(DataPresenterBase.GroupByAreaFieldLabelStyleProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.GroupByAreaFieldLabelStyleProperty, value);
			}
		}

		#endregion //GroupByAreaFieldLabelStyle

		#region GroupByAreaFieldLabelStyleSelector

		/// <summary>
		/// Identifies the 'GroupByAreaFieldLabelStyleSelector' dependency property
		/// </summary>
		public static readonly DependencyProperty GroupByAreaFieldLabelStyleSelectorProperty = DependencyProperty.Register("GroupByAreaFieldLabelStyleSelector",
			typeof(StyleSelector), typeof(DataPresenterBase), new FrameworkPropertyMetadata((object)null));

		/// <summary>
		/// Gets/sets the style selector to be used for the <see cref="GroupByAreaFieldLabel"/>s.  By default, this property returns null which indicates that an internally generated default style should be used.
		/// </summary>
		/// <seealso cref="GroupByArea"/>
		/// <seealso cref="GroupByAreaLocation"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.GroupByAreaLocation"/>
		/// <seealso cref="GroupByAreaFieldLabel"/>
		/// <seealso cref="GroupByAreaFieldLabelStyle"/>
		/// <seealso cref="GroupByAreaFieldLabelCollection"/>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Browsable(false)]
		//[Description("Gets/sets the style to be used for the GroupByAreaFieldLabels.  By default, this property returns null which indicates that an internally generated default style should be used.")]
		//[Category("Appearance")]
		public StyleSelector GroupByAreaFieldLabelStyleSelector
		{
			get
			{
				return (StyleSelector)this.GetValue(DataPresenterBase.GroupByAreaFieldLabelStyleSelectorProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.GroupByAreaFieldLabelStyleSelectorProperty, value);
			}
		}

		#endregion //GroupByAreaFieldLabelStyleSelector

		#region GroupByAreaLocation

		/// <summary>
		/// Identifies the <see cref="GroupByAreaLocation"/> dependency property
		/// </summary>
		public static readonly DependencyProperty GroupByAreaLocationProperty = DependencyProperty.Register("GroupByAreaLocation",
			typeof(GroupByAreaLocation), typeof(DataPresenterBase), new FrameworkPropertyMetadata(GroupByAreaLocation.AboveDataArea));

		/// <summary>
		/// Determines where the <see cref="GroupByArea"/> is displayed.  If set to None, the GroupByArea is not displayed.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
		/// </remarks>
		/// <seealso cref="GroupByArea"/>
		/// <seealso cref="GroupByAreaLocationProperty"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.GroupByAreaLocation"/>
		/// <seealso cref="GroupByAreaFieldLabel"/>
		/// <seealso cref="GroupByAreaFieldLabelStyle"/>
		/// <seealso cref="GroupByAreaFieldLabelCollection"/>
		/// <seealso cref="GroupByAreaLocation"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowGroupBy"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByComparer"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByEvaluator"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.GroupByMode"/>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSortDescription.IsGroupBy"/>
		//[Description("Determines where the GroupByArea is displayed.  If set to None, the GroupByArea is not displayed.")]
		//[Category("Appearance")]
		[Bindable(true)]
		[DefaultValue(GroupByAreaLocation.AboveDataArea)]
		public GroupByAreaLocation GroupByAreaLocation
		{
			get
			{
				return (GroupByAreaLocation)this.GetValue(DataPresenterBase.GroupByAreaLocationProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.GroupByAreaLocationProperty, value);
			}
		}

		#endregion //GroupByAreaLocation

        // JJD 4/07/09 - NA 2009 vol 2 
        #region GroupByAreaMode

        /// <summary>
        /// Identifies the <see cref="GroupByAreaMode"/> dependency property
        /// </summary>
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_CrossBandGrouping, Version = FeatureInfo.Version_9_2)]
        public static readonly DependencyProperty GroupByAreaModeProperty = DependencyProperty.Register("GroupByAreaMode",
            typeof(GroupByAreaMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(GroupByAreaMode.MultipleFieldLayoutsFull, new PropertyChangedCallback(OnGroupByAreaModeChanged)));

        private static void OnGroupByAreaModeChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = target as DataPresenterBase;

            if (dp != null)
            {
                dp.VerifyGroupByAreaLocation();

                if (dp.IsInitialized && dp.DataSource != null)
                    dp.BumpGroupByAreaStyleVersion();
            }
        }

        /// <summary>
        /// Gets/sets how fields are grouped by the end-user.
        /// </summary>
        /// <seealso cref="GroupByAreaModeProperty"/>
        /// <seealso cref="Infragistics.Windows.DataPresenter.GroupByAreaMode"/>
        //[Description("Gets/sets how fields are grouped by the end-user.")]
        //[Category("Behavior")]
        [InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_CrossBandGrouping, Version = FeatureInfo.Version_9_2)]
        public GroupByAreaMode GroupByAreaMode
        {
            get
            {
                return (GroupByAreaMode)this.GetValue(DataPresenterBase.GroupByAreaModeProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.GroupByAreaModeProperty, value);
            }
        }

        #endregion //GroupByAreaMode

		// JM 04-08-09 - NA 2009 Vol 2 - Cross-band Grouping
		#region GroupByAreaMulti

		/// <summary>
		/// Identifies the <see cref="GroupByAreaMulti"/> dependency property
		/// </summary>
		[InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_CrossBandGrouping, Version = FeatureInfo.Version_9_2)]
		public static readonly DependencyProperty GroupByAreaMultiProperty = DependencyProperty.Register("GroupByAreaMulti",
			typeof(GroupByAreaMulti), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnGroupByAreaMultiChanged)) );

        private static void OnGroupByAreaMultiChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = target as DataPresenterBase;

            if (dp != null)
            {
                GroupByAreaMulti oldGBA = e.OldValue as GroupByAreaMulti;

                if (oldGBA != null)
                {
                    oldGBA.InitializeDataPresenter(null);

                    // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                    // If the old groupbyarea is a logical child of us 
                    // remove it 
                    if (oldGBA.Parent == dp)
                        dp.InternalRemoveLogicalChild(oldGBA);
                }

                dp._groupByAreaMulti = e.NewValue as GroupByAreaMulti;

                if (dp._groupByAreaMulti != null)
                {
                    dp._groupByAreaMulti.InitializeDataPresenter(dp);

                    // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                    // If the groupyarea doesn't have a logical parent
                    // then add it as a logical child of the dp
                    if (dp._groupByAreaMulti.Parent == null)
                        dp.InternalAddLogicalChild(dp._groupByAreaMulti);
                }

                dp.VerifyGroupByAreaLocation();
            }
        }

		/// <summary>
		/// Returns/sets the GroupByAreaMulti control that is used for Outlook style grouping across multiple <see cref="FieldLayout"/>s.
		/// </summary>
		/// <remarks>
		/// <p class="body">The <see cref="GroupByAreaMode"/> property determines whether the XamDataPresenter uses the original <see cref="GroupByArea"/> control as the UI for Outlook style grouping of the
		/// <see cref="DefaultFieldLayout"/> only or whether it uses the <see cref="GroupByAreaMulti"/> control for Outlook style grouping across multiple <see cref="FieldLayout"/>s.</p>
		/// </remarks>
		/// <seealso cref="GroupByAreaMultiProperty"/>
		/// <seealso cref="GroupByArea"/>
		/// <seealso cref="GroupByAreaMode"/>
		/// <seealso cref="FieldLayout"/>
		//[Description("Returns/sets the GroupByArea that is used for Outlook style grouping across multiple FieldLayouts.")]
		//[Category("Behavior")]
		[Bindable(true)]
		[InfragisticsFeature(FeatureName = FeatureInfo.FeatureName_CrossBandGrouping, Version = FeatureInfo.Version_9_2)]
		public GroupByAreaMulti GroupByAreaMulti
		{
			get
			{
				return this._groupByAreaMulti;
			}
			set
			{
				this.SetValue(DataPresenterBase.GroupByAreaMultiProperty, value);
			}
		}

		#endregion //GroupByAreaMulti

		#region GroupByAreaStyle

		/// <summary>
		/// Identifies the <see cref="GroupByAreaStyle"/> dependency property
		/// </summary>
        
        
        [EditorBrowsable(EditorBrowsableState.Never)]
		public static readonly DependencyProperty GroupByAreaStyleProperty = DependencyProperty.Register("GroupByAreaStyle",
			typeof(Style), typeof(DataPresenterBase), new FrameworkPropertyMetadata((object)null));

		/// <summary>
		/// Gets/sets the style to be used for the <see cref="GroupByArea"/>.  By default, this property returns null which indicates that the default style should be used.
		/// </summary>
		/// <remarks>
		/// <p class="body">Refer to the <a href="xamDataPresenter_About_Grouping.html">About Grouping</a> topic in the Developer's Guide for an explanation of how this property is used.</p>
        /// <p class="body">Refer to the <a href="WPF_Working_with_xamDataGrid_xamDataCarousel_and_xamDataPresenter_Styling_Points.html">Working with xamDataGrid, xamDataCarousel and xamDataPresenter Styling Points</a> topic in the Developer's Guide for an explanation of how to style the control.</p>
        /// <para class="note"><b>Note:</b> this property is no longer necessary since the <see cref="GroupByArea"/> property has been made writable its Style property can be set directly. For backwards
        ///  compatibility this property is still supported be has been flagged so that it won't show in the property browser or in intellisense.</para>
		/// </remarks>
		/// <seealso cref="GroupByArea"/>
		/// <seealso cref="GroupByAreaLocation"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.GroupByAreaLocation"/>
		/// <seealso cref="GroupByAreaFieldLabel"/>
		/// <seealso cref="GroupByAreaFieldLabelStyle"/>
		/// <seealso cref="GroupByAreaFieldLabelCollection"/>
		/// <seealso cref="GroupByAreaStyleProperty"/>
		//[Description("Gets/sets the style to be used for the GroupByArea.  By default, this property returns null which indicates that an internally generated default style should be used.")]
		//[Category("Appearance")]
		[Bindable(true)]
		[DefaultValue(null)]
        
        
        [Browsable(false)]
        [EditorBrowsable( EditorBrowsableState.Never )]
		public Style GroupByAreaStyle
		{
			get
			{
				return (Style)this.GetValue(DataPresenterBase.GroupByAreaStyleProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.GroupByAreaStyleProperty, value);
			}
		}

		#endregion //GroupByAreaStyle

        // MBS 7/20/09 - NA9.2 Excel Exporting
        #region IsExporting

		// AS 3/3/11 NA 2011.1 - Async Exporting
		// Changed to a DP and set it on the source control as well.
		//
		private static readonly DependencyPropertyKey IsExportingPropertyKey =
			DependencyProperty.RegisterReadOnly("IsExporting",
			typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnIsExportingChanged)));

		private static void OnIsExportingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase grid = d as DataPresenterBase;
			grid._isExporting = (bool)e.NewValue;
			CommandManager.InvalidateRequerySuggested();
		}

		/// <summary>
		/// Identifies the <see cref="IsExporting"/> read-only dependency property
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public static readonly DependencyProperty IsExportingProperty =
			IsExportingPropertyKey.DependencyProperty;

        /// <summary>
        /// Returns whether the control is in the process of an export operation.
        /// </summary>
        /// <seealso cref="DataSource"/>
        /// <seealso cref="IDataPresenterExporter"/>
		[Browsable(false)]
		public bool IsExporting
        {
			// AS 3/3/11 NA 2011.1 - Async Exporting
			//get { return this._isExporting; }
			//internal set 
			//{
			//    Debug.Assert(this is DataPresenterExportControlBase, "Unexpected use of the IsExporting property");
			//    this._isExporting = value; 
			//}
            get { return this._isExporting; }
            internal set { this.SetValue(IsExportingPropertyKey, KnownBoxes.FromValue(value)); }
        }
        #endregion //IsExporting

        #region IsGroupByAreaExpanded

        /// <summary>
		/// Identifies the <see cref="IsGroupByAreaExpanded"/> dependency property
		/// </summary>
		public static readonly DependencyProperty IsGroupByAreaExpandedProperty = DependencyProperty.Register("IsGroupByAreaExpanded",
			typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		/// <summary>
		/// Determines if the <see cref="GroupByArea"/> is expanded or collapsed
		/// </summary>
		/// <see cref="GroupByArea"/>
		/// <see cref="GroupByAreaLocation"/>
		/// <seealso cref="IsGroupByAreaExpandedProperty"/>
		//[Description("Determines if the GroupByArea is expanded or collapsed")]
		//[Category("Behavior")]
		[Bindable(true)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool IsGroupByAreaExpanded
		{
			get
			{
				return (bool)this.GetValue(DataPresenterBase.IsGroupByAreaExpandedProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.IsGroupByAreaExpandedProperty, value);
			}
		}

		#endregion //IsGroupByAreaExpanded

		#region IsNestedDataDisplayEnabled

		/// <summary>
		/// Identifies the <see cref="IsNestedDataDisplayEnabled"/> dependency property
		/// </summary>
		public static readonly DependencyProperty IsNestedDataDisplayEnabledProperty = DependencyProperty.Register("IsNestedDataDisplayEnabled",
			typeof(bool), typeof(DataPresenterBase), 
				new FrameworkPropertyMetadata(KnownBoxes.TrueBox, 
					new PropertyChangedCallback(OnIsNestedDataDisplayEnabledChanged)
					
					
					
					
					
					
					
					//, new CoerceValueCallback(CoerceIsNestedDataDisplayEnabled)
				)
			);

		// JJD 5/16/07 
		// Since derived classes could override default values of any dependency property we
		// have to initialize the property cache variables to metadata default values in the ctor.
		//private bool _cachedIsNestedDataDisplayEnabled = true;
		private bool _cachedIsNestedDataDisplayEnabled;

		
		
		
		
		
		
		
		
#region Infragistics Source Cleanup (Region)











#endregion // Infragistics Source Cleanup (Region)


		private static void OnIsNestedDataDisplayEnabledChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase dp = target as DataPresenterBase;

			
			
			
			
			
			bool newVal = (bool)e.NewValue;
			dp._cachedIsNestedDataDisplayEnabled = newVal;

			if (dp != null && dp._recordManager != null)
				dp._recordManager.OnIsNestedDataDisplayEnabledChanged();
		}

		/// <summary>
		/// Gets/sets whether nested/hierarchical data can be displayed.
		/// </summary>
		/// <remarks>
		/// <para class="body">If set to false will cause all expandable <see cref="Field"/>s (i.e. those that return true from their <see cref="Field.IsExpandableResolved"/> property) to be hidden. 
		/// This has the effect of only showing root level <see cref="DataRecord"/>s.</para>
		/// </remarks>
		/// <seealso cref="IsNestedDataDisplayEnabledProperty"/>
		//[Description("Gets/sets whether nested/hierarchical data can be displayed")]
		//[Category("Behavior")]
		[Bindable(true)]
		[DefaultValue(true)]
		public bool IsNestedDataDisplayEnabled
		{
			get
			{
				// JJD 4/26/07
				// Optimization - cache the property locally
				//return (bool)this.GetValue(DataPresenterBase.IsNestedDataDisplayEnabledProperty);
				return this._cachedIsNestedDataDisplayEnabled;
			}
			set
			{
				this.SetValue(DataPresenterBase.IsNestedDataDisplayEnabledProperty, value);
			}
		}

		#endregion //IsNestedDataDisplayEnabled

        // JJD 12/08/08 - Added 
        #region IsSynchronizedWithCurrentItem

        /// <summary>
        /// Identifies the <see cref="IsSynchronizedWithCurrentItem"/> dependency property
        /// </summary>
        public static readonly DependencyProperty IsSynchronizedWithCurrentItemProperty = DependencyProperty.Register("IsSynchronizedWithCurrentItem",
            typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnIsSynchronizedWithCurrentItemChanged)));

        private static void OnIsSynchronizedWithCurrentItemChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = target as DataPresenterBase;

            if (dp != null &&
                (bool)e.NewValue == true)
                dp.RecordManager.SetActiveRecordFromCurrentItem();
        }

        /// <summary>
        /// Gets/sets a value that indicates whether the ActiveRecord is synchronized with the current item of a DataSource that implements the ICollectionView interface.
        /// </summary>
        /// <remarks>
        /// <para class="note"><b>Note:</b> if the <see cref="DataSource"/> does not implement the <see cref="System.ComponentModel.ICollectionView"/> interface then this setting is ignored.</para>
        /// </remarks>
        /// <seealso cref="ActiveRecord"/>
        /// <seealso cref="RecordActivating"/>
        /// <seealso cref="RecordDeactivating"/>
        /// <seealso cref="RecordActivated"/>
        /// <seealso cref="IsSynchronizedWithCurrentItemProperty"/>
        //[Description("Gets/sets a value that indicates whether the ActiveRecord is synchronized with the CurrentItem of a DataSource that implements the ICollectionView interface.")]
        //[Category("Behavior")]
        public bool IsSynchronizedWithCurrentItem
        {
            get
            {
                return (bool)this.GetValue(DataPresenterBase.IsSynchronizedWithCurrentItemProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.IsSynchronizedWithCurrentItemProperty, value);
            }
        }

        #endregion //IsSynchronizedWithCurrentItem

		// JJD 03/14/12 - TFS100150 - Added touch support
		#region IsTouchSupportEnabled


		/// <summary>
		/// Identifies the <see cref="IsTouchSupportEnabled"/> dependency property
		/// </summary>
		public static readonly DependencyProperty IsTouchSupportEnabledProperty = DependencyPropertyUtilities.Register("IsTouchSupportEnabled",
			typeof(bool), typeof(DataPresenterBase),
			DependencyPropertyUtilities.CreateMetadata(KnownBoxes.TrueBox, new PropertyChangedCallback(OnIsTouchSupportEnabledChanged))
			);

		private static void OnIsTouchSupportEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase instance = (DataPresenterBase)d;

			instance._scrollHelper.IsEnabled = (bool)e.NewValue;

			instance.SetCurrentValue(FrameworkElement.IsManipulationEnabledProperty, KnownBoxes.FromValue((bool)e.NewValue));
		}

		/// <summary>
		/// Returns or sets whether touch support is enabled for this control
		/// </summary>
		/// <seealso cref="IsTouchSupportEnabledProperty"/>
		public bool IsTouchSupportEnabled
		{
			get
			{
				return (bool)this.GetValue(DataPresenterBase.IsTouchSupportEnabledProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.IsTouchSupportEnabledProperty, value);
			}
		}


		#endregion //IsTouchSupportEnabled

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region IsUndoEnabled

        /// <summary>
        /// Identifies the <see cref="IsUndoEnabled"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty IsUndoEnabledProperty = DependencyProperty.Register("IsUndoEnabled",
            typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnIsUndoEnabledChanged)));

        private static void OnIsUndoEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = (DataPresenterBase)d;

			dp._cachedIsUndoEnabled = (bool)e.NewValue; // AS 1/12/11 TFS59619

            if (false.Equals(e.NewValue) && null != dp._history)
            {
                dp._history.Clear();
            }
        }

        /// <summary>
        /// Returns or sets a value when undo/redo functionality is enabled within the control.
        /// </summary>
        /// <seealso cref="IsUndoEnabledProperty"/>
        /// <seealso cref="UndoLimit"/>
        /// <seealso cref="DataPresenterCommands.Undo"/>
		/// <seealso cref="DataPresenterCommands.Redo"/>
		//[Description("Returns or sets a value when undo/redo functionality is enabled within the control.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public bool IsUndoEnabled
        {
            get
            {
				// AS 1/12/11 TFS59619
				//return (bool)this.GetValue(DataPresenterBase.IsUndoEnabledProperty);
				return _cachedIsUndoEnabled;
            }
            set
            {
                this.SetValue(DataPresenterBase.IsUndoEnabledProperty, value);
            }
        }

        #endregion //IsUndoEnabled

		// JJD 10/21/11 - TFS86028 - added
		#region ProcessCellInvalidationsSynchronously

		/// <summary>
		/// Used to bypass logic that was added to optimize performance by deferring
		/// record and cell invalidations so they could be processed together in a single pass.
		/// This static property was added to allow applications to opt out of the
		/// optimization in case their logic was relying on synchronous invalidations.
		/// </summary>
		/// <value>True to process cell invalidations synchronously, otherwise false. The default is false.</value>
		public static bool ProcessCellInvalidationsSynchronously { get; set; }

		#endregion //ProcessCellInvalidationsSynchronously	
    
		#region RecordContainerGenerationMode

		/// <summary>
		/// Identifies the <see cref="RecordContainerGenerationMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty RecordContainerGenerationModeProperty = DependencyProperty.Register("RecordContainerGenerationMode",
			typeof(ItemContainerGenerationMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(ItemContainerGenerationMode.Recycle));

		/// <summary>
		/// Gets/sets how Record containers are generated and cached.
		/// </summary>
		/// <seealso cref="RecordContainerGenerationModeProperty"/>
		/// <seealso cref="CellContainerGenerationModeProperty"/>
		//[Description("Gets/sets how Record containers are generated and cached.")]
		//[Category("Behavior")]
		public ItemContainerGenerationMode RecordContainerGenerationMode
		{
			get
			{
				return (ItemContainerGenerationMode)this.GetValue(DataPresenterBase.RecordContainerGenerationModeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordContainerGenerationModeProperty, value);
			}
		}

		#endregion //RecordContainerGenerationMode
	
		#region RecordLoadMode

		/// <summary>
		/// Identifies the 'RecordLoadMode' dependency property
		/// </summary>
		public static readonly DependencyProperty RecordLoadModeProperty = DependencyProperty.Register("RecordLoadMode",
			typeof(RecordLoadMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(RecordLoadMode.LoadOnDemand));

		/// <summary>
		/// Gets/sets how <see cref="DataRecord"/>s are loaded
		/// </summary>
		/// <remarks>
		/// <para class="body">The default value of <b>LoadOnDemand</b> will delay the creation of <see cref="DataRecord"/>s until they are requested.</para>
		/// <para></para>
		/// <para class="note">Some operations, like sorting or grouping records, will cause the all <see cref="DataRecord"/>s to be loaded regardless 
		/// of this setting because they require access to all records. </para>
		/// </remarks>
		/// <seealso cref="FieldLayout.SortedFields"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowGroupBy"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		//[Description("Gets/sets how records are loaded")]
		//[Category("Behavior")]
		[DefaultValue(RecordLoadMode.LoadOnDemand)]
		public RecordLoadMode RecordLoadMode
		{
			get
			{
				return (RecordLoadMode)this.GetValue(DataPresenterBase.RecordLoadModeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordLoadModeProperty, value);
			}
		}

		#endregion //RecordLoadMode

		#region RecordManager

		/// <summary>
		/// Returns a <see cref="Infragistics.Windows.DataPresenter.RecordManager"/> that manages the collections of root <see cref="DataRecord"/>s (read-only).
		/// </summary>
		/// <remarks>
		/// <para class="body"><see cref="DataRecord"/>s are created to represent each item in the <see cref="DataPresenterBase.DataSource"/>. The <see cref="DataRecord"/> exposes a read-only <see cref="DataRecord.DataItem"/> property that returns the associated item from the data source as well as a corresponding <see cref="DataRecord.DataItemIndex"/> property.
		/// These <see cref="DataRecord"/>s are managed by the <see cref="RecordManager"/> and exposed via its <see cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/>, <see cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/> and <see cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/> collection properties.</para>  
		/// <para></para>
		/// <para class="body">The RecordManager is responsible for listening to events raised by the <see cref="DataPresenterBase.DataSource"/> thru either the <see cref="System.Collections.Specialized.INotifyCollectionChanged"/> or the <see cref="System.ComponentModel.IBindingList"/> interfaces. 
		/// Based on these notifcations it keeps its <see cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/> and <see cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/> collections of <see cref="DataRecord"/>s in sync and raises corresponding events on each thru their <see cref="System.Collections.Specialized.INotifyCollectionChanged"/> interface implemenations.</para>
		/// <para class="body">Refer to the <a href="xamData_Terms_Record_Manager.html">Record Manager</a> topic in the Developer's Guide.</para>
		/// <para class="body">Refer to the <a href="xamData_Terms_Records.html">Records</a> topic in the Developer's Guide for a explanation of the various record types.</para>
		/// <para class="body">Refer to the <a href="xamData_TheoryOfOperation.html">Theory of Operation</a> topic in the Developer's Guide for an overall explanation of how everything works together.</para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Unsorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Sorted"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Groups"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.RecordManager.Current"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="ExpandableFieldRecord.ChildRecordManager"/>
		/// <seealso cref="ActiveRecord"/>
		//[Description("The record collection manager (read-only)")]
		//[Category("Data")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public RecordManager RecordManager
		{
			get
			{
				if (this._recordManager == null)
				{
					this._recordManager = new RecordManager(this, null, null);

					this._recordManager.PropertyChanged += new PropertyChangedEventHandler(OnRecordManagerPropertyChanged);
					this.SetValue(RecordsPropertyKey, this._recordManager.Current);
				}

				return this._recordManager;
			}
		}

		
		
		internal RecordManager RecordManagerIfAllocated
		{
			get
			{
				return _recordManager;
			}
		}

		void OnRecordManagerPropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			switch (e.PropertyName)
			{
				case "Current":
					this.SetValue(RecordsPropertyKey, this._recordManager.Current);
					this.SetValue(ViewableRecordsPropertyKey, this._recordManager.ViewableRecords);
					break;
			}
		}

		#endregion //RecordManager

		#region Records

		private static readonly DependencyPropertyKey RecordsPropertyKey =
			DependencyProperty.RegisterReadOnly("Records",
			typeof(RecordCollectionBase), typeof(DataPresenterBase), new FrameworkPropertyMetadata());

		/// <summary>
		/// Identifies the 'Records' dependency property
		/// </summary>
		public static readonly DependencyProperty RecordsProperty =
			RecordsPropertyKey.DependencyProperty;

		/// <summary>
		/// Returns a <see cref="RecordCollectionBase"/> object that contains the current root collection of <see cref="Record"/>s.
		/// </summary>
		/// <remarks>
		/// <para class="body">This is exposed as a convenience property and returns the root <see cref="RecordManager"/>'s <see cref="Infragistics.Windows.DataPresenter.RecordManager.Current"/> collection of records. 
		/// This will either contain the top level <see cref="DataRecord"/>s or the top level <see cref="GroupByRecord"/>s if records are grouped.</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b>This collection will not include add record templates. Those special <see cref="DataRecord"/>s are only included in the <see cref="ViewableRecords"/> collection.</para>
		/// </remarks>
		/// <seealso cref="Record"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="ViewableRecords"/>
		//[Description("The current root collection of records")]
		//[Category("Data")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public RecordCollectionBase Records
		{
			get
			{
                // JJD 1/10/08 - BR29572
                // Make sure that RecordManager's DataSource is initialized
                if (!this._isRecordManagerDataSourceInitialized)
                    this.VerifyRecordManagerDataSource();

                return (RecordCollectionBase)this.GetValue(DataPresenterBase.RecordsProperty);
			}
		}

		#endregion //Records

		// JJD 3/23/12 - Metro theme support
		// Added properties to supply default RecordSelectorExtents from within a theme's style
		#region RecordSelectorExtent

		/// <summary>
		/// Identifies the <see cref="RecordSelectorExtent"/> dependency property
		/// </summary>
		public static readonly DependencyProperty RecordSelectorExtentProperty = DependencyProperty.Register("RecordSelectorExtent",
			typeof(double), typeof(DataPresenterBase), new FrameworkPropertyMetadata(double.NaN, OnRecordSelectorExtentChanged), ValidateRecordSelectorExtent);

		private static bool ValidateRecordSelectorExtent(object value)
		{
			double dbl = (double)value;

			if (double.IsNaN(dbl))
				return true;

			if (dbl < 0 || double.IsInfinity(dbl))
				return false;

			return true;
			
		}

		private static void OnRecordSelectorExtentChanged(DependencyObject target, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = target as DataPresenterBase;

			dp._cachedRecordSelectorExtent = (double)e.NewValue;

			dp.InvalidateGeneratedStylesAsync();
		}

		/// <summary>
		/// Gets/sets the default extent for RecordSelectors
		/// </summary>
		/// <value>The default extent for a record selector or NaN.</value>
		/// <remarks>
		/// <para class="note"><b>Note:</b> this value is used in the calculation of the <see cref="FieldLayout"/>.<see cref="FieldLayout.RecordSelectorExtentResolved"/> property.</para>
		/// </remarks>
		/// <seealso cref="RecordSelectorExtentProperty"/>
		public double RecordSelectorExtent
		{
			get
			{
				return _cachedRecordSelectorExtent;
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordSelectorExtentProperty, value);
			}
		}

		#endregion //RecordSelectorExtent

		// JJD 3/23/12 - Metro theme support
		// Added properties to supply default RecordSelectorExtents from within a theme's style
		#region RecordSelectorErrorIconExtent

		/// <summary>
		/// Identifies the <see cref="RecordSelectorErrorIconExtent"/> dependency property
		/// </summary>
		public static readonly DependencyProperty RecordSelectorErrorIconExtentProperty = DependencyProperty.Register("RecordSelectorErrorIconExtent",
			typeof(double), typeof(DataPresenterBase), new FrameworkPropertyMetadata(double.NaN, OnRecordSelectorErrorIconExtentChanged), ValidateRecordSelectorExtent);

		private static void OnRecordSelectorErrorIconExtentChanged(DependencyObject target, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = target as DataPresenterBase;

			dp._cachedRecordSelectorErrorIconExtent = (double)e.NewValue;
			dp.InvalidateGeneratedStylesAsync();
		}

		/// <summary>
		/// Gets/sets the default extent for error icons inside RecordSelectors
		/// </summary>
		/// <value>The default extent for a error icon inside a record selector or NaN.</value>
		/// <remarks>
		/// <para class="note"><b>Note:</b> this value is used in the calculation of the <see cref="FieldLayout"/>.<see cref="FieldLayout.RecordSelectorExtentResolved"/> property.</para>
		/// </remarks>
		/// <seealso cref="RecordSelectorErrorIconExtentProperty"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SupportDataErrorInfo"/>
		public double RecordSelectorErrorIconExtent
		{
			get
			{
				return _cachedRecordSelectorErrorIconExtent;
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordSelectorErrorIconExtentProperty, value);
			}
		}

		#endregion //RecordSelectorErrorIconExtent

		// JJD 3/23/12 - Metro theme support
		// Added properties to supply default RecordSelectorExtents from within a theme's style
		#region RecordSelectorFixButtonExtent

		/// <summary>
		/// Identifies the <see cref="RecordSelectorFixButtonExtent"/> dependency property
		/// </summary>
		public static readonly DependencyProperty RecordSelectorFixButtonExtentProperty = DependencyProperty.Register("RecordSelectorFixButtonExtent",
			typeof(double), typeof(DataPresenterBase), new FrameworkPropertyMetadata(double.NaN, OnRecordSelectorFixButtonExtentChanged), ValidateRecordSelectorExtent);

		private static void OnRecordSelectorFixButtonExtentChanged(DependencyObject target, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = target as DataPresenterBase;

			dp._cachedRecordSelectorFixButtonExtent = (double)e.NewValue;
			dp.InvalidateGeneratedStylesAsync();
		}

		/// <summary>
		/// Gets/sets the default extent for the fix buttons inside RecordSelectors
		/// </summary>
		/// <value>The default extent for the fix button inside a record selector or NaN.</value>
		/// <remarks>
		/// <para class="note"><b>Note:</b> this value is used in the calculation of the <see cref="FieldLayout"/>.<see cref="FieldLayout.RecordSelectorExtentResolved"/> property.</para>
		/// </remarks>
		/// <seealso cref="RecordSelectorFixButtonExtentProperty"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowRecordFixing"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FixedRecordUIType"/>
		public double RecordSelectorFixButtonExtent
		{
			get
			{
				return _cachedRecordSelectorFixButtonExtent;
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordSelectorFixButtonExtentProperty, value);
			}
		}

		#endregion //RecordSelectorFixButtonExtent
		
		#region ReportView

		/// <summary>
		/// Identifies the <see cref="ReportView"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ReportViewProperty = DependencyProperty.Register("ReportView",
			typeof(ReportViewBase), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null));

		/// <summary>
		/// Returns/sets the view to be used when printing/exporting the DataPresenter's contents.
		/// </summary>
		/// <seealso cref="ReportViewProperty"/>
		/// <seealso cref="ReportViewBase"/>
		/// <seealso cref="TabularReportView"/>
		//[Description("Returns/sets the view to be used when printing/exporting the DataPresenter's contents.")]
		//[Category("Layout")]
		//[Bindable(true)]
		public ReportViewBase ReportView
		{
			get
			{
				return (ReportViewBase)this.GetValue(DataPresenterBase.ReportViewProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.ReportViewProperty, value);
			}
		}

        #endregion //ReportView

		// JJD 4/09/12 - TFS108549 - added
		#region RecordContainerRetentionMode

		/// <summary>
		/// Identifies the <see cref="RecordContainerRetentionMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty RecordContainerRetentionModeProperty = DependencyProperty.Register("RecordContainerRetentionMode",
			typeof(RecordContainerRetentionMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(RecordContainerRetentionMode.RetainDeactivatedContainersUntilResize));

		/// <summary>
		/// Gets or sets whether de-activated (i.e. unused) record containers will be retained in the visual tree for possible future use.
		/// </summary>
		/// <value>'RetainDeactivatedContainers' to retain unused record containers always, 'RetainDeactivatedContainersUntilResize' to retain them until the control is resized smaller, otherwise 'DiscardDeactivatedContainers'. The default is 'RetainDeactivatedContainersUntilResize'.</value>
		/// <remarks>
		/// <para class="note"><b>Note:</b> if this property is set 'RetainDeactivatedContainers' or 'RetainDeactivatedContainersUntilResize' then any record containers that have already been hydrated but are not used 
		/// in the current display will be retained in the visual tree (collapsed) so that they can be recycled in the future. Depending on the scenario, e.g. if the mix of DataRecords, GroupByRecords and SummaryRecords in the display changes, this
		/// can improve scrolling performance. This property is ignored if <see cref="RecordContainerGenerationMode"/> is set to any value other than 'Recycle'.</para>
		/// </remarks>
		/// <seealso cref="RecordContainerGenerationMode"/>
		/// <seealso cref="RecordContainerRetentionModeProperty"/>
		//[Description("Gets or sets whether de-activated (i.e. unused) record containers will be retained in the visual tree for possible future use.")]
		//[Category("Behavior")]
		public RecordContainerRetentionMode RecordContainerRetentionMode
		{
			get
			{
				return (RecordContainerRetentionMode)this.GetValue(DataPresenterBase.RecordContainerRetentionModeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.RecordContainerRetentionModeProperty, value);
			}
		}

		#endregion //RecordContainerRetentionMode

		// JJD 11/30/10 - TFS31984 - added
		#region ScrollBehaviorOnListChange

		/// <summary>
		/// Identifies the <see cref="ScrollBehaviorOnListChange"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ScrollBehaviorOnListChangeProperty = DependencyProperty.Register("ScrollBehaviorOnListChange",
			typeof(ScrollBehaviorOnListChange), typeof(DataPresenterBase), new FrameworkPropertyMetadata(ScrollBehaviorOnListChange.Default));

		/// <summary>
		/// Determines the scroll position behavior when records are added or removed before the current records in view.
		/// </summary>
		/// <seealso cref="ScrollBehaviorOnListChangeProperty"/>
		[Description("Determines the scroll position behavior when records are added or removed before the current records in view.")]
		[Category("Behavior")]
		public ScrollBehaviorOnListChange ScrollBehaviorOnListChange
		{
			get
			{
				return (ScrollBehaviorOnListChange)this.GetValue(DataPresenterBase.ScrollBehaviorOnListChangeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.ScrollBehaviorOnListChangeProperty, value);
			}
		}

		#endregion //ScrollBehaviorOnListChange

        #region ScrollInfo

        /// <summary>
		/// Returns a reference to an IScrollInfo interface that can be used to scroll the list and query scrolling information.
		/// </summary>
		[EditorBrowsable( EditorBrowsableState.Advanced )]
		[Browsable(false)]
		[DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden)]
		public IScrollInfo ScrollInfo
		{
			get
			{
				if (this._rootRecordListControl != null)
					return this._rootRecordListControl.ScrollInfo;

				return null;
			}
		}

		#endregion //ScrollInfo

		#region ScrollingMode

		/// <summary>
		/// Identifies the <see cref="ScrollingMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ScrollingModeProperty = DependencyProperty.Register("ScrollingMode",
			typeof(ScrollingMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(ScrollingMode.DeferredWithScrollTips), new ValidateValueCallback(OnValidateScrollingMode));

		private static bool OnValidateScrollingMode(object value)
		{
			if (!Enum.IsDefined(typeof(ScrollingMode), value))
				throw new ArgumentException();

			return true;
		}

		/// <summary>
		/// Determines whether the records being displayed are updated while the scroll thumb is being dragged.
		/// </summary>
		/// <remarks>
		/// <p class="body">This property affects the scroll thumb of the vertical scrollbar when the <see cref="GridViewSettings.Orientation"/> is 
		/// set to <b>Vertical</b> and the scroll thumb of the horizontal scrollbar when the Orientation is set to <b>Horizontal</b>. 
		/// When set to <b>DeferredWithScrollTips</b>, which is the default value, or <b>Deferred</b>, the records displayed in 
		/// the grid will not be updated until the mouse is released. When set to <b>Immediate</b>, no scroll tip will be displayed and the records displayed will be updated while the 
		/// scroll thumb is being dragged.</p>
		/// <p class="body">For <b>DeferredWithScrollTips</b>, a tooltip adjacent to the original position of the scroll thumb will be displayed that contains 
		/// information about the <see cref="Record"/> that will become the new top record when the mouse is released. 
		/// The scrolltip contains information about the new <b>TopRecord</b> and its ancestors. The information displayed by 
		/// default is based on the type of record. For <see cref="DataRecord"/>, the information is that of the <see cref="FieldLayout.ScrollTipField"/> of 
		/// the <see cref="Record.FieldLayout"/>. For <see cref="GroupByRecord"/> and <see cref="ExpandableFieldRecord"/>, it 
		/// will be the <see cref="GroupByRecord.Description"/>. The scrolltip contents can be controlled by creating a new 
		/// <see cref="System.Windows.HierarchicalDataTemplate"/> for the <see cref="RecordScrollTipInfo"/> class. The scroll tip can be styled 
		/// by restyling the <see cref="RecordScrollTip"/> class.</p>
		/// <p class="note"><b>Note:</b> When set to <b>DeferredWithScrollTips</b> or <b>Deferred</b>, scrolling of records will not take place until the mouse has been released.
		/// </p>
		/// </remarks>
		//[Description("Determines whether the records being displayed are updated while the scroll thumb is being dragged.")]
		//[Category("Behavior")]
		public ScrollingMode ScrollingMode
		{
			get { return (ScrollingMode)this.GetValue(DataPresenterBase.ScrollingModeProperty); }
			set { this.SetValue(DataPresenterBase.ScrollingModeProperty, value); }
		}

		/// <summary>
		/// Determines if the <see cref="ScrollingMode"/> property needs to be serialized.
		/// </summary>
		/// <returns>True if the property should be serialized</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool ShouldSerializeScrollingMode()
		{
			return this.ReadLocalValue(DataPresenterBase.ScrollingModeProperty) != DependencyProperty.UnsetValue;
		}

		/// <summary>
		/// Resets the <see cref="ScrollingMode"/> property to its default state
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ResetScrollingMode()
		{
			this.ClearValue(DataPresenterBase.ScrollingModeProperty);
		}

		#endregion //ScrollingMode

		#region SelectedItems

		/// <summary>
		/// Returns an object that contains collections of selected <see cref="Record"/>s, <see cref="Field"/>s and <see cref="Cell"/>s
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. However, the <b>SelectedItemsChanged</b> event will be raised. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="SelectedItems"/>
		/// <seealso cref="SelectedItemsChanged"/>
		/// <seealso cref="SelectedItemsChanging"/>
		/// <seealso cref="SelectedItemHolder"/>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public SelectedItemHolder SelectedItems
		{
			get
			{
				if (this._selectedItems == null)
				{
					this._selectedItems = new SelectedItemHolder(this);
					// JJD 4/13/07 - BR21909
					// Obsolete method
					//this._selectedItems.Initialize(this);
				}

				return this._selectedItems;
			}
		}

		#endregion //SelectedItems

		#region SelectionStrategyFilter

		/// <summary>
		/// Gets/sets a filter for supplying selection stratgies for items.
		/// </summary>
		/// <seealso cref="ISelectionStrategyFilter"/>
		/// <seealso cref="SelectionStrategyBase"/>
		[EditorBrowsable( EditorBrowsableState.Advanced )]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		internal ISelectionStrategyFilter SelectionStrategyFilter
		{
			get { return this._selectionStrategyFilter; }
			set { this._selectionStrategyFilter = value; }
		}

		#endregion //SelectionStrategyFilter

		#region SortRecordsByDataType

		/// <summary>
		/// Identifies the 'SortRecordsByDataType' dependency property
		/// </summary>
		public static readonly DependencyProperty SortRecordsByDataTypeProperty = DependencyProperty.Register("SortRecordsByDataType",
			typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		/// <summary>
		/// Gets/sets whether data sources containing non-homogenous data will force a sort of records by data type.
		/// </summary>
		//[Description("Gets/sets whether data sources containing non-homogenous data will force a sort of records by data type.")]
		//[Category("Behavior")]
		[Bindable(true)]
		[DefaultValue(false)]
		public bool SortRecordsByDataType
		{
			get
			{
				return (bool)this.GetValue(DataPresenterBase.SortRecordsByDataTypeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.SortRecordsByDataTypeProperty, value);
			}
		}

		#endregion //SortRecordsByDataType

		// MD 7/16/10 - TFS26592
		#region SuppressedEvents

		/// <summary>
		/// Returns a collection of routed events which shouldn't be fired.
		/// </summary>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
		public ObservableCollection<RoutedEventWrapper> SuppressedEvents
		{
			get
			{
				if (_suppressedEvents == null)
					// SSP 12/22/11 TFS67264 - Optimizations
					// 
					//_suppressedEvents = new SuppressedEventsCollection();
					_suppressedEvents = new SuppressedEventsCollection( this );

				return _suppressedEvents.Collection;
			}
		}

		#endregion // SuppressedEvents

		#region Theme

		#region Old Version
		
#region Infragistics Source Cleanup (Region)
































































































































#endregion // Infragistics Source Cleanup (Region)

		#endregion //Old Version
		/// <summary>
		/// Identifies the 'Theme' dependency property
		/// </summary>
		public static readonly DependencyProperty ThemeProperty = ThemeManager.ThemeProperty.AddOwner(typeof(DataPresenterBase), new FrameworkPropertyMetadata(new PropertyChangedCallback(OnThemeChanged)));

		/// <summary>
		/// Event ID for the 'ThemeChanged' routed event
		/// </summary>
		public static readonly RoutedEvent ThemeChangedEvent =ThemeManager.ThemeChangedEvent.AddOwner(typeof(DataPresenterBase));

		private static void OnThemeChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase control = target as DataPresenterBase;

			string theme = (string)e.NewValue;
			if (theme != null && theme.Length > 0)
				control._themeRegistered_DP_ResourceSet = ThemeManager.GetResourceSet(theme, DataPresenterGeneric.Location.Grouping);
			else
				control._themeRegistered_DP_ResourceSet = null;

            // JJD 11/11/09 - TFS24665
            // Clear any pending cached record presenter
            control.ClearPendingActiveRecordPresenter();

			// JJD 7/7/06 
			// We no longer need to invalidate everything since we changed
			// from the look approach to the theme approach
			//control.InvalidateGeneratedStyles(true, true);
			control.ClearStyleCache();

			// JJD 2/26/07
			// we need to call UodateLayout after we change the merged dictionaries.
			// Otherwise, the styles from the new merged dictionary are not picked
			// up right away. It seems the framework must be caching some information
			// that doesn't get refreshed until the next layout update
			// JM BR28475 12-05-07 - Do the InvalidateMeasure and UpdateLayout AFTER we bump the layout versions.
			//control.InvalidateMeasure();
			//control.UpdateLayout();
			control.FieldLayouts.BumpLayoutVersions();
			control.InvalidateMeasure();

			// AS 9/4/09 TFS21087
			// Do not call UpdateLayout while the control is being initialized.
			//
			if (control.IsInitialized)
	    		control.UpdateLayout();

			// JJD 3/13/07
			// Invalidate the measure of the main panel
			// JJD 3/14/07
			// Check to make sure currentpanel is not null
			if (control.CurrentPanel != null)
				control.CurrentPanel.InvalidateMeasure();

			control.OnThemeChanged((string)(e.OldValue), (string)(e.NewValue));
		}

		private ResourceDictionary _themeRegistered_DP_ResourceSet;

		/// <summary>
		/// Gets/sets the default look for the control.
		/// </summary>
		/// <remarks>
		/// <para class="body">If left set to null then the default 'Generic' theme will be used. 
		/// This property can be set to the name of any registered theme (see <see cref="Infragistics.Windows.Themes.ThemeManager.Register(string, string, ResourceDictionary)"/> and <see cref="Infragistics.Windows.Themes.ThemeManager.GetThemes()"/> methods).</para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> The following themes are pre-registered by this assembly but additional themes can be registered as well.
		/// <ul>
		/// <li>"Aero" - a theme that is compatible with Vista's 'Aero' theme.</li>
		/// <li>"Generic" - the default theme.</li>
		/// <li>"LunaNormal" - a theme that is compatible with XP's 'blue' theme.</li>
		/// <li>"LunaOlive" - a theme that is compatible with XP's 'olive' theme.</li>
		/// <li>"LunaSilver" - a theme that is compatible with XP's 'silver' theme.</li>
		/// <li>"Office2k7Black" - a theme that is compatible with MS Office 2007's 'Black' theme.</li>
		/// <li>"Office2k7Blue" - a theme that is compatible with MS Office 2007's 'Blue' theme.</li>
		/// <li>"Office2k7Silver" - a theme that is compatible with MS Office 2007's 'Silver' theme.</li>
		/// <li>"Onyx" - a theme that features black and orange highlights.</li>
		/// <li>"Royale" - a theme that features subtle blue highlights.</li>
		/// <li>"RoyaleStrong" - a theme that features strong blue highlights.</li>
		/// </ul>
		/// </para>
		/// </remarks>
		/// <seealso cref="Infragistics.Windows.Themes.ThemeManager"/>
		/// <seealso cref="ThemeProperty"/>
		//[Description("Gets/sets the general look of the FieldLayout")]
		//[Category("Appearance")]
		[Bindable(true)]
		[DefaultValue((string)null)]
		[TypeConverter(typeof(Infragistics.Windows.Themes.Internal.DataPresenterThemeTypeConverter))]
		public string Theme
		{
			get
			{
				return (string)this.GetValue(DataPresenterBase.ThemeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.ThemeProperty, value);
			}
		}

		/// <summary>
		/// Called when property 'Theme' changes
		/// </summary>
		protected virtual void OnThemeChanged(string previousValue, string currentValue)
		{
			RoutedPropertyChangedEventArgs<string> newEvent = new RoutedPropertyChangedEventArgs<string>(previousValue, currentValue);
			newEvent.RoutedEvent = DataPresenterBase.ThemeChangedEvent;
			newEvent.Source = this;

			// MD 7/16/10 - TFS26592
			// Raise the event through the helper method.
			//RaiseEvent(newEvent);
			this.RaiseEventHelper(newEvent);
		}

		/// <summary>
		/// Occurs when the 'Theme' property changes
		/// </summary>
		//[Description("Occurs when the 'Theme' property changes")]
		//[Category("Behavior")]
		public event RoutedPropertyChangedEventHandler<string> ThemeChanged
		{
			add
			{
				base.AddHandler(DataPresenterBase.ThemeChangedEvent, value);
			}
			remove
			{
				base.RemoveHandler(DataPresenterBase.ThemeChangedEvent, value);
			}
		}

		#endregion //Theme

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region UndoLimit

        /// <summary>
        /// Identifies the <see cref="UndoLimit"/> dependency property
        /// </summary>
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly DependencyProperty UndoLimitProperty = DependencyProperty.Register("UndoLimit",
            typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata(0, new PropertyChangedCallback(OnUndoLimitChanged)), new ValidateValueCallback(GridUtilities.ValidateNonNegativeInt));

        private static void OnUndoLimitChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataPresenterBase dp = (DataPresenterBase)d;

            if (null != dp._history)
                dp._history.UndoLimit = (int)e.NewValue;
        }

        /// <summary>
        /// Returns/sets the maximum number of operations that can be stored in the undo and redo history.
        /// </summary>
        /// <seealso cref="UndoLimitProperty"/>
        /// <seealso cref="IsUndoEnabled"/>
		/// <seealso cref="DataPresenterCommands.Undo"/>
		/// <seealso cref="DataPresenterCommands.Redo"/>
		//[Description("Returns/sets the maximum number of operations that can be stored in the undo and redo history.")]
        //[Category("Behavior")]
        [Bindable(true)]
        [InfragisticsFeature(Version=FeatureInfo.Version_9_2, FeatureName=FeatureInfo.FeatureName_ClipboardSupport)]
        public int UndoLimit
        {
            get
            {
                return (int)this.GetValue(DataPresenterBase.UndoLimitProperty);
            }
            set
            {
                this.SetValue(DataPresenterBase.UndoLimitProperty, value);
            }
        }

        #endregion //UndoLimit

		#region UpdateMode

		/// <summary>
		/// Identifies the <see cref="UpdateMode"/> dependency property
		/// </summary>
		public static readonly DependencyProperty UpdateModeProperty = DependencyProperty.Register("UpdateMode",
			typeof(UpdateMode), typeof(DataPresenterBase), new FrameworkPropertyMetadata(UpdateMode.OnRecordChangeOrLostFocus));

		/// <summary>
		/// Determines how updates are committed to the <see cref="DataSource"/>
		/// </summary>
		/// <seealso cref="UpdateModeProperty"/>
		/// <seealso cref="DataPresenterBase.RecordUpdating"/>
		/// <seealso cref="DataPresenterBase.RecordUpdated"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceling"/>
		/// <seealso cref="DataPresenterBase.RecordUpdateCanceled"/>
		/// <seealso cref="DataRecord.IsDataChanged"/>
		/// <seealso cref="DataRecord.Update()"/>
		/// <seealso cref="DataRecord.CancelUpdate"/>
		/// <seealso cref="DataPresenterCommands"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.CommitChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToAllRecords"/>
		/// <seealso cref="DataPresenterCommands.DiscardChangesToActiveRecord"/>
		/// <seealso cref="DataPresenterBase.ExecuteCommand(RoutedCommand)"/>
		//[Description("Determines how updates are committed to the DataSource")]
		//[Category("Behavior")]
		[Bindable(true)]
		[DefaultValue(UpdateMode.OnRecordChangeOrLostFocus)]
		public UpdateMode UpdateMode
		{
			get
			{
				return (UpdateMode)this.GetValue(DataPresenterBase.UpdateModeProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.UpdateModeProperty, value);
			}
		}

		#endregion //UpdateMode

		#region ViewableRecords

		private static readonly DependencyPropertyKey ViewableRecordsPropertyKey =
			DependencyProperty.RegisterReadOnly("ViewableRecords",
			typeof(ViewableRecordCollection), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnViewableRecordsChanged)));

		private static void OnViewableRecordsChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			DataPresenterBase dp = target as DataPresenterBase;

			if (dp != null)
			{
				ViewableRecordCollection oldCollection = e.OldValue as ViewableRecordCollection;
				if (oldCollection != null)
					oldCollection.PropertyChanged -= dp.OnViewableRecordsPropertyChanged;

				ViewableRecordCollection newCollection = e.NewValue as ViewableRecordCollection;

				if (newCollection != null)
				{
					newCollection.PropertyChanged += dp.OnViewableRecordsPropertyChanged;
					// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
					// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
					// calculating scroll count.
					// 
					//dp._overallScrollCount = newCollection.ScrollCount;
					dp._cachedOverallScrollCountDirty = true;
				}
				else
				{
					// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
					// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
					// calculating scroll count.
					// 
					//dp._overallScrollCount = 0;
					dp._cachedOverallScrollCountDirty = true;

					dp._overallScrollPosition = 0;
				}

			}
		}

		private void OnViewableRecordsPropertyChanged(object sender, PropertyChangedEventArgs e)
		{
			// JM 09-26-07 BR26775
			//if (e.PropertyName == "ScrollCount")
			//    this._overallScrollCount = this.ViewableRecords.ScrollCount;
			if (e.PropertyName == "ScrollCount")
			{
				// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
				// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
				// calculating scroll count.
				// 
				//this._overallScrollCount = this.ViewableRecords.ScrollCount;
				_cachedOverallScrollCountDirty = true;

                // JJD 3/29/08 - added support for printing.
                // We can't do asynchronous operations during a print
                //
                // MBS 7/29/09 - NA9.2 Excel Exporting
                //if (this.IsReportControl)
				if (this.IsSynchronousControl)
					this.BumpScrollableRecordCountVersion();
				else
				{
					// JJD 10/18/10 - TFS30715
					// Only call BeginInvoke if one isn't already pending
					if (this._bumpScrollCountOperation == null)
						this._bumpScrollCountOperation = this.Dispatcher.BeginInvoke(DispatcherPriority.Input, new GridUtilities.MethodDelegate(this.BumpScrollableRecordCountVersion));
				}
			}
		}

        // AS 1/27/09
        // Optimization - only have 1 parameterless void delegate class defined.
        //
		//delegate void MyDelegate();


		/// <summary>
		/// Identifies the <see cref="ViewableRecords"/> dependency property
		/// </summary>
		public static readonly DependencyProperty ViewableRecordsProperty =
			ViewableRecordsPropertyKey.DependencyProperty;

		/// <summary>
		/// Returns a read only collection of root level records whose visibility is not set to 'Collapsed'. 
		/// </summary>
		/// <value>A <see cref="ViewableRecordCollection"/> containing all records at the root level whose <see cref="Record.Visibility"/> property is not set to 'Collapsed'.</value>
		/// <remarks>
		/// <para class="body">This collection also includes any special records (e.g. add records).</para>
		/// <para></para>
		/// <p class="note"><b>Note:</b>The records are ordered exactly as they are presented in the UI.</p>
		/// </remarks>
		/// <seealso cref="ViewableRecordsProperty"/>
		/// <seealso cref="Record.ViewableChildRecords"/>
		/// <seealso cref="Records"/>
		//[Description("A read-only collection that contains all the records that can be viewed at this level.")]
		//[Category("Data")]
		[Bindable(true)]
		[ReadOnly(true)]
		[Browsable(false)]
		public ViewableRecordCollection ViewableRecords
		{
			get
			{
				ViewableRecordCollection vrc = (ViewableRecordCollection)this.GetValue(DataPresenterBase.ViewableRecordsProperty);

				if (vrc == null)
				{
					vrc = this.RecordManager.ViewableRecords;
					this.SetValue(ViewableRecordsPropertyKey, vrc);
				}

                // JJD 1/10/08 - BR29572
                // Make sure that RecordManager's DataSource is initialized
                if (!this._isRecordManagerDataSourceInitialized)
                    this.VerifyRecordManagerDataSource();

				return vrc;
			}
		}

		#endregion //ViewableRecords

		#endregion //Public Properties

        #region Internal Properties

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region AllRecordsAutoSizeMaxDepth
		internal int AllRecordsAutoSizeMaxDepth
		{
			get
			{
				if (_allRecordsAutoSizeMaxDepth < -1)
				{
					_allRecordsAutoSizeMaxDepth = -1;

					foreach (FieldLayout fl in _fieldLayouts)
					{
						if (fl.AutoSizeInfo.HasAllRecordFields)
							_allRecordsAutoSizeMaxDepth = Math.Max(_allRecordsAutoSizeMaxDepth, fl.MaxRecordManagerDepth);
					}
				}

				return _allRecordsAutoSizeMaxDepth;
			}
		}
		#endregion //AllRecordsAutoSizeMaxDepth

		// AS 4/8/09 NA 2009.2 ClipboardSupport
        #region ClipboardOperationInfo
        internal ClipboardOperationInfo ClipboardOperationInfo
        {
            get
            {
                if (null == _clipboardOperationInfo)
                    _clipboardOperationInfo = new ClipboardOperationInfo(this);

                return _clipboardOperationInfo;
            }
        } 
        #endregion //ClipboardOperationInfo

        #region CommandsInternal

        internal CommandsBase CommandsInternal
		{
			get
			{
				return this.Commands;
			}
		}

		#endregion // CommandsInternal

		#region CurrentRecordListControl

		internal RecordListControl CurrentRecordListControl
		{
			get
			{
				if (this._currentRecordListControl == null)
					this.InitializeRecordManagerDataSource();
				else
				{
					Grid grid = this._currentRecordListControl.Parent as Grid;
					if (grid != null && grid != this._dataAreaGrid)
						grid.Children.Remove(this._currentRecordListControl);
				}

				return this._currentRecordListControl;
			}
		}

		#endregion //ItemsFormatter

		#region CurrentPanel

		internal Panel CurrentPanel
		{
			get
			{
				//ListBoxPanelSettings ps = null;

				if (this._currentRecordListControl != null)
				{
                    // JJD 2/22/08 - BR30660 
                    // Changed VerifyCurrentPanel so that it returns the panel.
                    // We always need to call this is case things have changed 
                    //ps = DataPresenterBase.GetPanelSettings(this._currentRecordListControl);

                    //if (ps != null)
                    //    return ps.Panel;

					return this.VerifyCurrentPanel();
				}

				return null;
			}
		}

		#endregion //CurrentPanel

		#region CurrentViewInternal

		internal ViewBase CurrentViewInternal
		{
			get { return this._currentViewInternal; }
			set
			{

				if (value != this._currentViewInternal)
				{
					bool oldViewExisted = this._currentViewInternal != null;


					// Detach the current view.
					if (this._currentViewInternal != null)
						this._currentViewInternal.ViewStateChanged -= new EventHandler<ViewStateChangedEventArgs>(this.OnCurrentViewStateChanged);


					// Set the view to the new value.
					this._currentViewInternal = value;


					// Attach the new view if not null.
					if (value != null)
						this._currentViewInternal.ViewStateChanged += new EventHandler<ViewStateChangedEventArgs>(this.OnCurrentViewStateChanged);


					if (oldViewExisted)
					{
						// AS 7/27/09 NA 2009.2 Field Sizing
						//if (this._cellValuePresenterInEditMode != null)
						//	this._cellValuePresenterInEditMode.Cell.EndEditMode(false, true);
						this.EditHelper.EndEditMode(false, true);

						this._itemsPanel = null;

						// JJD 3/26/07
						// Update the horz and vert scrollbar visibility properties
						this.UpdateScrollBarVisibility();

						this.ClearItemsHost();
						// AS 2/25/08 BR30387
						// The StyleGenerator of the FieldLayouts was still initialized with that
						// of the previous view so we need to reinitialize those as well. Also since
						// InvalidateFormatSettings is calling ResetGroupBySettings, we don't need
						// to call that explicitly any more.
						//
						//this.ResetGroupBySettings();
						this.InvalidateFormatSettings();

						this.ResetItemsPanel();
						this.InitializeItemsPanel();


                        // AS 12/2/08 TFS11099
                        if (null != this.DefaultFieldLayout)
                        {
                            // JM 10-16-08 [TFS9104]
							// SSP 6/26/09 - NAS9.2 Field Chooser
							// Use the new GetFieldLayoutInfo and SetFieldLayoutInfo methods instead of
							// directly accessing the member var.
							// 
                            //this.DefaultFieldLayout._dragFieldLayoutInfo = null;
							this.DefaultFieldLayout.SetFieldLayoutInfo( null, false, false );
                        }

					}

                    // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                    // Some resolved properties, etc. are based on the current view information
                    // so proactively let the fieldlayouts know when the view has changed.
                    //
                    FieldLayoutCollection layouts = this.FieldLayoutsIfAllocated;

                    if (null != layouts)
                    {
                        foreach (FieldLayout fl in layouts)
                        {
							// AS 10/13/09 NA 2010.1 - CardView
							// Added format settings changed parameter.
							//
							fl.OnCurrentViewChanged(false);
                        }
                    }

					this.VerifyGroupByAreaLocation();

					// JJD 4/28/11 - TFS73523 - added 
					this.InitializeSpacingOnResizeController();
				}
			}
		}

		#endregion //CurrentViewInternal

		// JM 08-04-08 Load/Save Customizations
		#region CustomizationsManager

		internal CustomizationsManager CustomizationsManager
		{
			get
			{
				if (this._customizationsManager == null)
					this._customizationsManager = new CustomizationsManager(this);

				return this._customizationsManager;
			}
		}

		#endregion //CustomizationsManager

		#region DataPresenterBase

		/// <summary>
		/// Identifies the <see cref="DataPresenter"/> attached dependency property
		/// </summary>
		/// <remarks>
		/// This attached property is set on the panel that is implementing the layout for the current view.
		/// It provides the contained panel with a reference to the DataPresenterBase it is contained within.
		/// </remarks>
		public static readonly DependencyProperty DataPresenterProperty = DependencyProperty.RegisterAttached("DataPresenterBase",
			typeof(DataPresenterBase), typeof(DataPresenterBase), new FrameworkPropertyMetadata(new PropertyChangedCallback(OnDataPresenterChanged)));

		private static void OnDataPresenterChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
		{
			//Panel panel = target as Panel;

			//Debug.Assert(panel != null);

			//DataPresenterBase dp = e.NewValue as DataPresenterBase;

			//if (panel != null && dp != null)
			//    dp.InitializePanelWithSettings(panel);
		}

		internal static DataPresenterBase GetDataPresenter(DependencyObject d)
		{
			return (DataPresenterBase)d.GetValue(DataPresenterBase.DataPresenterProperty);
		}

		internal static void SetDataPresenter(DependencyObject d, DataPresenterBase value)
		{
			d.SetValue(DataPresenterBase.DataPresenterProperty, value);
		}

		#endregion //DataPresenterBase

        // JJD 12/14/07 - changed from IEnumerable to object to support IListSource (e.e. DataTable and DataSet)
        #region DataSourceInternal

		private static readonly DependencyPropertyKey DataSourceInternalPropertyKey =
			DependencyProperty.RegisterReadOnly("DataSourceInternal",
			typeof(object), typeof(DataPresenterBase), new FrameworkPropertyMetadata(null, new CoerceValueCallback(CoerceDataSourceInternal)));

		private static object CoerceDataSourceInternal(DependencyObject target, object value)
		{
			DataPresenterBase dp = target as DataPresenterBase;

			Debug.Assert(dp != null);

			if (dp == null)
				return value;

            // JJD 12/17/07
            // Replaced logic
            #region Old code

            //if (value == null)
            //{
            //    // JJD 12/12/07 - BR28988
            //    // Removed ItemsControl wrapper since installing 3.5 version of the framework introduced
            //    // an error in the CollectionView implementation that brought down the app with
            //    // a FataExecutionEngineError that was untrappable. This happened when calling
            //    // EndEdit on a DataView data source after calling AddNew.
            //    //if (dp._dataSourceWrapper != null)
            //    //    dp._dataSourceWrapper.ItemsSource = null;

            //    // JJD 12/14/07
            //    // Unwire the event listeners for the last root list
            //    dp.UnwireDataSourceRootList();

            //    return null;
            //}

            //// if the value is a collectionview then we don't need to
            //// wrap it
            //if (value is ICollectionView)
            //{
            //    // JJD 12/12/07 - BR28988
            //    // Removed ItemsControl wrapper since installing 3.5 version of the framework introduced
            //    // an error in the CollectionView implementation that brought down the app with
            //    // a FataExecutionEngineError that was untrappable. This happened when calling
            //    // EndEdit on a DataView data source after calling AddNew.
            //    // if the DataSource was set to something other than
            //    // our added items then clear them out.
            //    //if (dp._dataSourceWrapper != null &&
            //    //    value != dp._dataSourceWrapper.Items)
            //    //{
            //    //    dp._dataSourceWrapper.ItemsSource = null;
            //    //    dp.RemoveLogicalChild(dp._dataSourceWrapper);
            //    //    dp._dataSourceWrapper = null;
            //    //}
            //    return value;
            //}

            //object newValue = value;

            //ITypedList typedList = value as ITypedList;

            //if (typedList != null)
            //{
            //    // get the property descriptors
            //    PropertyDescriptorCollection pds = typedList.GetItemProperties(null);

            //    // if there is a single property of type IEnumerable with a single item
            //    // in the list then we want get get the IEnumerable value from the
            //    // property descriptor and use that as our source

            //    // JJD 7/17/07 - BR24396
            //    // Check to make sure the singular property type is not string before 
            //    // checking if it implements IEnumerable
            //    //if (pds != null &&
            //    //     pds.Count == 1 &&
            //    //     typeof(IEnumerable).IsAssignableFrom(pds[0].PropertyType))
            //    if (pds != null &&
            //         pds.Count == 1)
            //    {
            //        Type proptype = pds[0].PropertyType;

            //        if (proptype != typeof(string) &&
            //            typeof(IEnumerable).IsAssignableFrom(proptype))
            //        {
            //            IList list = value as IList;

            //            if (list != null && list.Count == 1)
            //            {
            //                newValue = pds[0].GetValue(list[0]) as IEnumerable;
            //            }
            //        }
            //    }
            //}

            //Debug.Assert(newValue is IEnumerable);

            //// JJD 12/12/07 - BR28988
            //// Removed ItemsControl wrapper since installing 3.5 version of the framework introduced
            //// an error in the CollectionView implementation that brought down the app with
            //// a FataExecutionEngineError that was untrappable. This happened when calling
            //// EndEdit on a DataView data source after calling AddNew.
            ////// create an ItemsControl to wrap the value
            ////if (dp._dataSourceWrapper == null)
            ////{
            ////    dp._dataSourceWrapper = new ItemsControl();
            ////    dp.AddLogicalChild(dp._dataSourceWrapper);
            ////}

            ////// set the wrapper's ItemsSource property to the value
            ////dp._dataSourceWrapper.ItemsSource = newValue as IEnumerable;

            ////// return the wrapper's Items collection
            ////return dp._dataSourceWrapper.Items;

            //return newValue as IEnumerable;

            #endregion //Old code	
    
            IListSource listSource = value as IListSource;

            // JJD 12/17/07
            // If the datasource implements IListSource then call its GetList Method
            if (listSource != null)
                value = listSource.GetList();

            IEnumerable rootEnumerable = value as IEnumerable;

            // JJD 12/17/07
            // If the datasource doesn't implement either IEnumerable or IListSource then call then
            // unwirs the last datasource and return null
            if (rootEnumerable == null)
            {
                dp.UnwireDataSourceRootList();

                // JJD 12/17/07
                // If the value is not null but we got here then they tried to set the DataSource to
                // an object that didn't implement either IEnumerable or IListSource so throw an exception
                // Note: we had to throw the exception here because the ValidatValueCallback would
                // pass us in a BindingExpression which is pretty strange and not very helpful.
                //if ( value != null )
                //    throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_37"));

				return null;
            }

            IList rootList = rootEnumerable as IList;

            // JJD 12/17/07
            // see if the root enumerable implements IList but has a single object in its list
            if (rootList != null && rootList.Count == 1)
            {
                dp.WireDataSourceRootList(rootList);

                object singleItem = rootList[0];

                if (singleItem != null)
                {
                    // JJD 12/17/07
                    // if the single item is an IEnumerable then return it as the list we will use as the root
                    if (singleItem is IEnumerable)
                    {
                        if (singleItem is string || 
                            singleItem is XmlNode)
                            return rootEnumerable;

                        return singleItem;
                    }

                    #region Process ITypedList case

                    ITypedList rootTypedList = rootList as ITypedList;

                    if (rootTypedList != null)
                    {
                        // get the property descriptors
                        // Note: a DataSet or its DefaultViewManager will return a single object
                        // whose properties represent the tables in the dataset
                        PropertyDescriptorCollection pds = rootTypedList.GetItemProperties(null);

                        if (pds != null)
                        {
                            int count = pds.Count;

                            // If the singleton object doesn't have any properties then return null
                            // but keep the change event handlers wired up to listen for changes
							if (count == 0)
							{
								// JJD 11/24/10 - TFS59031
								// Return the rootTypedList so we don't clear the RecordManagers DataSource
								//return null;
								return rootTypedList;
							}
 
                            bool allPropertiesAreEnumerable = true;

                            #region See if all properties are IEumerable

                            // JJD 12/17/07
                            // loop over all of the property descriptors to see is they all represent 
                            // IEnumerable types
                            for (int i = 0; i < count; i++)
                            {
                                Type proptype = pds[i].PropertyType;

                                if (proptype != typeof(string) &&
                                    proptype != typeof(XmlNode) &&
                                    typeof(IEnumerable).IsAssignableFrom(proptype))
                                    continue;

                                allPropertiesAreEnumerable = false;
                                break;
                            }

                            #endregion //See if all properties are IEumerable	
    
                            if (allPropertiesAreEnumerable)
                            {
                                // If there is only one property then return its value as 
                                // the list we use. 
                                if (count == 1)
                                    return pds[0].GetValue(singleItem);

                                // Since we have more than 1 property we want to wrap the 
                                // each one in an EnumerableObjectWrapper
                                #region Copy the old wrappers into a stack vaiable

                                // JJD 12/17/07
                                // Create a stack list to hold the existing EnumerableObjectWrappers we created last time
                                List<EnumerableObjectWrapper> oldWrappers = null;
                                int originalOldWrappersCount = 0;

                                if (dp._dataSourceRootChildListWrappers == null)
                                    dp._dataSourceRootChildListWrappers = new ObservableCollection<EnumerableObjectWrapper>();
                                else
                                {
                                    if (dp._dataSourceRootChildListWrappers.Count > 0)
                                    {
                                        oldWrappers = new List<EnumerableObjectWrapper>(dp._dataSourceRootChildListWrappers);
                                        originalOldWrappersCount = oldWrappers.Count;
                                    }
                                }

                                #endregion //Copy the old wrappers	
    
                                for (int i = 0; i < count; i++)
                                {
                                    PropertyDescriptor pd = pds[i];

                                    IEnumerable newItems = pd.GetValue(singleItem) as IEnumerable;

                                    // JJD 12/17/07
                                    #region See if the IEnumerable already wrapped

                                    if (oldWrappers != null &&
                                         oldWrappers.Count > 0)
                                    {
                                        bool oldWrapperFound = false;
                                        DataView newDV = newItems as DataView;

                                        for (int j = 0; j < oldWrappers.Count; j++)
                                        {
                                            IEnumerable oldItems = oldWrappers[j].Items;
                                            DataView oldDV = oldItems as DataView;

                                            // If we have a match then remove the wrapper from
                                            // the stack list we created above.
                                            if (newItems == oldItems ||
                                                (oldDV != null && oldDV.Equals(newDV)))
                                            {
                                                oldWrapperFound = true;
                                                oldWrappers.RemoveAt(j);
                                                break;
                                            }
                                        }

                                        // If we found an existing wrapper we can continue so
                                        // we don't add it again below
                                        if (oldWrapperFound)
                                            continue;
                                    }

                                    #endregion //See if the IEnumerable already wrapped	
    
                                    // JJD 12/17/07
                                    // Since this is a new list wrap it in an EnumerableObjectWrapper
                                    if (newItems != null)
                                        dp._dataSourceRootChildListWrappers.Add(new EnumerableObjectWrapper(newItems, pd.Name));
                                }

                                #region Remove any left over old wrappers

                                if (oldWrappers != null && oldWrappers.Count > 0)
                                {
                                    for (int i = 0; i < oldWrappers.Count; i++)
                                    {
                                        EnumerableObjectWrapper oldWrapper = oldWrappers[i];

                                        for (int j = 0; j < originalOldWrappersCount; j++)
                                        {
                                            if (oldWrapper == dp._dataSourceRootChildListWrappers[j])
                                            {
                                                dp._dataSourceRootChildListWrappers.RemoveAt(j);
                                                break;
                                            }
                                        }
                                    }
                                }

                                #endregion //Remove any left over old wrappers	

                                Debug.Assert(count == dp._dataSourceRootChildListWrappers.Count, "At this point we should have created a wrapper for every INumerable property");

                                #region Verify order of wrappers

                                if (count == dp._dataSourceRootChildListWrappers.Count)
                                {
                                    for (int i = 0; i < count; i++)
                                    {
                                        PropertyDescriptor pd = pds[i];

                                        IEnumerable items = pd.GetValue(singleItem) as IEnumerable;
                                        DataView itemsDV = items as DataView;

                                        IEnumerable wrappedItems = dp._dataSourceRootChildListWrappers[i].Items;
                                        DataView wrappedItemsDV = wrappedItems as DataView;

                                        if (items != wrappedItems &&
                                            (itemsDV == null || !itemsDV.Equals(wrappedItemsDV)))
                                        {
                                            bool wasWrapperMoved = false;

                                            for (int j = i + 1; j < count; j++)
                                            {
                                                EnumerableObjectWrapper wrapper = dp._dataSourceRootChildListWrappers[j];
                                                    
                                                wrappedItems = wrapper.Items;
                                                wrappedItemsDV = wrappedItems as DataView;

                                                if (items == wrappedItems ||
                                                   (itemsDV != null && itemsDV.Equals(wrappedItemsDV)))
                                                {
                                                    dp._dataSourceRootChildListWrappers.RemoveAt(j);
                                                    dp._dataSourceRootChildListWrappers.Insert(i, wrapper);
                                                    wasWrapperMoved = true;
                                                    break;
                                                }
                                            }

                                            Debug.Assert(wasWrapperMoved == true, "We should have found a wrapper for the item.");
                                        }
                                    }
                                }

                                #endregion //Verify order of wrappers	
    
                                return dp._dataSourceRootChildListWrappers;
                            }
                        }
                    }

                    #endregion //Process ITypedList case
                }
            }

            return rootEnumerable;
 		}

		internal static readonly DependencyProperty DataSourceInternalProperty =
			DataSourceInternalPropertyKey.DependencyProperty;

		internal object DataSourceInternal
		{
			get
			{
				return this.GetValue(DataPresenterBase.DataSourceInternalProperty);
			}
		}

		#endregion //DataSourceInternal
                
        // JJD 3/5/08 - added support for Converter properies on Field
        #region DefaultConverter

        internal CultureInfo DefaultConverterCulture
        {
            get
            {
                if (this._defaultConverterCulture == null)
                {
                    // JJD 4/15/08
                    // Call the new GetNonNeutralCulture method instead so we always
                    // get a culture that can be used in formatting operations
                    //XmlLanguage language = this.Language;
                    //if (language != null)
                    //     this._defaultConverter = language.GetSpecificCulture();
                    this._defaultConverterCulture = Utilities.GetNonNeutralCulture(this);
                 }

                return this._defaultConverterCulture;
            }
        }

        #endregion //DefaultConverter	

		#region CellValuePresenterInEdit

		
#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)


		#endregion //CellValuePresenterInEdit

		// AS 7/27/09 NA 2009.2 Field Sizing
		#region EditHelper
		internal EditModeHelper EditHelper
		{
			get
			{
				if (_editHelper == null)
					_editHelper = new EditModeHelper(this);

				return _editHelper;
			}
		} 
		#endregion //EditHelper

		// AS 3/3/11 NA 2011.1 - Async Exporting
		#region ExportHelper
		internal ExportHelper ExportHelper
		{
			get
			{
				if (null == _exportHelper)
					_exportHelper = new ExportHelper(this);

				return _exportHelper;
			}
		} 
		#endregion //ExportHelper

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region HasAutoSizeAllRecordFields
		internal bool HasAutoSizeAllRecordFields
		{
			get { return _fieldLayoutAutoSizeAllRecordsCount > 0; }
		} 
		#endregion //HasAutoSizeAllRecordFields

		// AS 2/26/10 TFS28159
		#region FieldLayoutAutoSizeRecordsInViewCount
		/// <summary>
		/// Returns/sets the number of field layouts that have autosized fields that act on records in view.
		/// </summary>
		internal int FieldLayoutAutoSizeRecordsInViewCount
		{
			get { return _fieldLayoutAutoSizeRecordsInViewCount; }
			set
			{
				Debug.Assert(value >= 0);
				_fieldLayoutAutoSizeRecordsInViewCount = value;
			}
		} 
		#endregion //FieldLayoutAutoSizeRecordsInViewCount

		// AS 8/5/09 NA 2009.2 Field Sizing
		#region FieldLayoutAutoSizeViewableCount
		/// <summary>
		/// Returns/sets the number of field layouts that have autosized fields that act on viewable records.
		/// </summary>
		internal int FieldLayoutAutoSizeViewableCount
		{
			get { return _fieldLayoutAutoSizeViewableCount; }
			set
			{
				Debug.Assert(value >= 0);
				_fieldLayoutAutoSizeViewableCount = value;
			}
		} 
		#endregion //FieldLayoutAutoSizeViewableCount

		#region HasFieldLayoutSettings

		internal bool HasFieldLayoutSettings
		{
			get { return this._x_FieldLayoutSettings != null; }
		}

		#endregion //HasFieldLayoutSettings

		#region HasFieldLayouts

		internal bool HasFieldLayouts
		{
			get { return this._fieldLayouts != null; }
		}

		#endregion //HasFieldLayouts

		#region HasFieldSettings

		internal bool HasFieldSettings
		{
			get { return this._x_FieldSettings != null; }
		}

		#endregion //HasFieldSettings

		// AS 11/14/11 TFS91077
		#region GridMeasureVersion

		internal static readonly DependencyProperty GridMeasureVersionProperty = DependencyProperty.Register("GridMeasureVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata(0));

		private void BumpGridMeasureVersion()
		{
			int version = (int)this.GetValue(DataPresenterBase.GridMeasureVersionProperty);
			this.SetValue(DataPresenterBase.GridMeasureVersionProperty, version + 1);
		}

		#endregion //GridMeasureVersion

        // AS 4/8/09 NA 2009.2 ClipboardSupport
        #region History
        internal DataPresenterHistory History
        {
            get
            {
                if (null == _history)
                    _history = new DataPresenterHistory(this);

                return _history;
            }
        } 
        #endregion //History

		#region InternalCellPresenterStyleSelector

		internal StyleSelector InternalCellPresenterStyleSelector
		{
			get
			{
				if (this._internalCellPresenterStyleSelector == null)
					this._internalCellPresenterStyleSelector = new DPCellPresenterStyleSelector(this);

				return this._internalCellPresenterStyleSelector;
			}
		}

		#endregion //InternalCellPresenterStyleSelector

		#region InternalCellValuePresenterStyleSelector

		internal StyleSelector InternalCellValuePresenterStyleSelector
		{
			get
			{
				if (this._internalCellValuePresenterStyleSelector == null)
					this._internalCellValuePresenterStyleSelector = new DPCellValuePresenterStyleSelector(this);

				return this._internalCellValuePresenterStyleSelector;
			}
		}

		#endregion //InternalCellValuePresenterStyleSelector

		#region InternalEditorStyleSelector

		internal StyleSelector InternalEditorStyleSelector
		{
			get
			{
				if (this._internalEditorStyleSelector == null)
					this._internalEditorStyleSelector = new DPEditorStyleSelector(this);

				return this._internalEditorStyleSelector;
			}
		}

		#endregion //InternalEditorStyleSelector

		#region InternalExpandedCellStyleSelector

		internal StyleSelector InternalExpandedCellStyleSelector
		{
			get
			{
				if (this._internalExpandedCellStyleSelector == null)
					this._internalExpandedCellStyleSelector = new DPExpandedCellStyleSelector(this);

				return this._internalExpandedCellStyleSelector;
			}
		}

		#endregion //InternalExpandedCellStyleSelector

		#region InternalHeaderPresenterStyleSelector

		internal StyleSelector InternalHeaderPresenterStyleSelector
		{
			get
			{
				if (this._internalHeaderPresenterStyleSelector == null)
					this._internalHeaderPresenterStyleSelector = new DPHeaderPresenterStyleSelector(this);

				return this._internalHeaderPresenterStyleSelector;
			}
		}

		#endregion //InternalHeaderPresenterStyleSelector

		#region InternalHeaderLabelAreaStyleSelector

		internal StyleSelector InternalHeaderLabelAreaStyleSelector
		{
			get
			{
				if (this._internalHeaderLabelAreaStyleSelector == null)
					this._internalHeaderLabelAreaStyleSelector = new DPHeaderLabelAreaStyleSelector(this);

				return this._internalHeaderLabelAreaStyleSelector;
			}
		}

		#endregion //InternalHeaderLabelAreaStyleSelector

		#region InternalHeaderPrefixAreaStyleSelector

		internal StyleSelector InternalHeaderPrefixAreaStyleSelector
		{
			get
			{
				if (this._internalHeaderPrefixAreaStyleSelector == null)
					this._internalHeaderPrefixAreaStyleSelector = new DPHeaderPrefixAreaStyleSelector(this);

				return this._internalHeaderPrefixAreaStyleSelector;
			}
		}

		#endregion //InternalHeaderPrefixAreaStyleSelector

		#region InternalLabelPresenterStyleSelector

		internal StyleSelector InternalLabelPresenterStyleSelector
		{
			get
			{
				if (this._internalLabelPresenterStyleSelector == null)
					this._internalLabelPresenterStyleSelector = new DPLabelPresenterStyleSelector(this);

				return this._internalLabelPresenterStyleSelector;
			}
		}

		#endregion //InternalLabelPresenterStyleSelector

		#region InternalRecordCellAreaStyleSelector

		internal StyleSelector InternalRecordCellAreaStyleSelector
		{
			get
			{
				if (this._internalRecordCellAreaStyleSelector == null)
					this._internalRecordCellAreaStyleSelector = new DPRecordCellAreaStyleSelector(this);

				return this._internalRecordCellAreaStyleSelector;
			}
		}

		#endregion //InternalRecordCellAreaStyleSelector

		#region InternalRecordStyleSelector

		internal StyleSelector InternalRecordStyleSelector
		{
			get
			{
				if (this._internalRecordStyleSelector == null)
					this._internalRecordStyleSelector = new DPRecordPresenterStyleSelector(this);

				return this._internalRecordStyleSelector;
			}
		}

		#endregion //InternalRecordStyleSelector

		#region InternalRecordSelectorStyleSelector

		internal StyleSelector InternalRecordSelectorStyleSelector
		{
			get
			{
				if (this._internalRecordSelectorStyleSelector == null)
					this._internalRecordSelectorStyleSelector = new DPRecordSelectorStyleSelector(this);

				return this._internalRecordSelectorStyleSelector;
			}
		}

		#endregion //InternalRecordSelectorStyleSelector

		#region InternalRecords

		private static readonly DependencyProperty InternalRecordsProperty =
			DependencyProperty.Register("InternalRecords",
			typeof(IList<Record>), typeof(DataPresenterBase), new FrameworkPropertyMetadata( ));

		internal IList<Record> InternalRecords
		{
			get
			{
				return (IList<Record>)this.GetValue(DataPresenterBase.InternalRecordsProperty);
			}
		}

		#endregion //InternalRecords

		#region IsAutoFitHeightSupported

		
#region Infragistics Source Cleanup (Region)












#endregion // Infragistics Source Cleanup (Region)

		#endregion //IsAutoFitHeightSupported

		#region IsAutoFitWidthSupported

		
#region Infragistics Source Cleanup (Region)












#endregion // Infragistics Source Cleanup (Region)


		#endregion //IsAutoFitWidthSupported

        // MBS 7/29/09 - NA9.2 Excel Exporting
        #region IsExportControl

        internal virtual bool IsExportControl
        {
            get { return false; }
        }
        #endregion //IsExportControl

		// JJD 3/29/08 - added support for printing
        #region IsReportControl
        
        internal bool IsReportControl        
        {

            get { return this is IEmbeddedVisualPaginator; } 



        }

        #endregion //IsReportControl	
    
		// JM 08-04-08 Load/Save Customizations
		#region IsApplyingCustomizations

		internal bool IsApplyingCustomizations
		{
			get { return this._isLoadingCustomizations; }
			set	{ this._isLoadingCustomizations = value; }
		}

		#endregion //IsApplyingCustomizations

		#region IsDraggingField

		// SSP 6/24/09 - NAS9.2 Field Chooser
		// Added IsDraggingField property.
		// 
		/// <summary>
		/// Indicates if a field label presenter from this data presenter is being dragged. 
		/// Note that this property will return false if the label presenter from a field chooser
		/// is being dragged.
		/// </summary>
		internal bool IsDraggingField
		{
			get
			{
				return null != _fieldDragManager;
			}
		}

		#endregion // IsDraggingField

		#region IsFlatView

		// SSP 8/4/09 - NAS9.2 Enhanced grid-view
		// 
		/// <summary>
		/// Indicates if the view is using flat panel.
		/// </summary>
		internal bool IsFlatView
		{
			get
			{
				ViewBase view = this.CurrentViewInternal;
                return null != view && view.SupportedDataDisplayMode == DataDisplayMode.FlattenedHierarchical;
			}
		}

		#endregion // IsFlatView

		// JJD 04/13/12 - TFS108986 - Optimization - added
		#region IsScrolling

		private static readonly DependencyPropertyKey IsScrollingPropertyKey =
			DependencyProperty.RegisterReadOnly("IsScrolling",
			typeof(bool), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		internal static readonly DependencyProperty IsScrollingProperty =
			IsScrollingPropertyKey.DependencyProperty;

		internal bool IsScrolling
		{
			get
			{
				return _isScrollingTimer != null && _isScrollingTimer.IsEnabled;
			}
		}

		#endregion //IsScrolling

		// MBS 7/29/09 - NA9.2 Excel Exporting
        // There is now the need for a distinction of whether a derived control
        // needs to have its operations performed synchronously where it may 
        // not return true for IsReportControl.
        #region IsSynchronousControl

        internal virtual bool IsSynchronousControl
        {
            get { return false; }
        }
        #endregion //IsSynchronousControl

        #region ItemsPanel

        private static readonly DependencyPropertyKey ItemsPanelPropertyKey =
			DependencyProperty.RegisterReadOnly("ItemsPanel",
			typeof(ItemsPanelTemplate), typeof(DataPresenterBase), new FrameworkPropertyMetadata());

		internal static readonly DependencyProperty ItemsPanelProperty =
			ItemsPanelPropertyKey.DependencyProperty;

		internal ItemsPanelTemplate ItemsPanel
		{
			get
			{
				return (ItemsPanelTemplate)this.GetValue(DataPresenterBase.ItemsPanelProperty);
			}
		}

		#endregion //ItemsPanel

		// AS 11/14/11 TFS91077
		#region LastMeasureSize
		internal Size LastMeasureSize
		{
			get { return _lastMeasureSize; }
		} 
		#endregion //LastMeasureSize

		// JJD 2/19/09 - TFS13979 - added
        #region OverallSortVersion

		// JM 04/09 CrossBandGrouping feature
		// Change to a DependencyProperty
		//// JJD 2/19/09 - TFS13979
		//// Maintain an overall sort version that gets bumped whenever
		//// a sorting change is made on any field layout
		//internal int OverallSortVersion
		//{
		//    get { return this._overallSortVersion; }
		//}

		internal static readonly DependencyProperty OverallSortVersionProperty = DependencyProperty.Register("OverallSortVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata((int)0));

		// Return/set an overall sort version that gets bumped whenever a sorting or grouping change is made on any field layout.
		internal int OverallSortVersion
		{
			get	{ return (int)this.GetValue(DataPresenterBase.OverallSortVersionProperty); }
			set { this.SetValue(DataPresenterBase.OverallSortVersionProperty, value); }
		}

        #endregion //OverallSortVersion	

		#region PanelSettings

		private static readonly DependencyProperty PanelSettingsProperty = DependencyProperty.RegisterAttached("PanelSettings",
			typeof(ListBoxPanelSettings), typeof(DataPresenterBase), new FrameworkPropertyMetadata());

		private static ListBoxPanelSettings GetPanelSettings(DependencyObject d)
		{
			return (ListBoxPanelSettings)d.GetValue(DataPresenterBase.PanelSettingsProperty);
		}

		private static void SetPanelSettings(DependencyObject d, ListBoxPanelSettings value)
		{
			d.SetValue(DataPresenterBase.PanelSettingsProperty, value);
		}

		#endregion //PanelSettings

        // JJD 11/11/09 - TFS24665 - added
        #region PendingActiveRecordPresenter

        internal RecordPresenter PendingActiveRecordPresenter
        {
            get
            {
                return this._pendingActiveRecordPresenter;
            }
            set
            {
                this._pendingActiveRecordPresenter = value;
            }
        }

        #endregion //PendingActiveRecordPresenter	
    
		#region RecordsInViewVersion

		private static readonly DependencyPropertyKey RecordsInViewVersionPropertyKey =
			DependencyProperty.RegisterReadOnly("RecordsInViewVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata((int)0));

		internal static readonly DependencyProperty RecordsInViewVersionProperty =
			RecordsInViewVersionPropertyKey.DependencyProperty;

		internal int RecordsInViewVersion
		{
			get
			{
				return (int)this.GetValue(RecordsInViewVersionProperty);
			}
		}

		#endregion //RecordsInViewVersion

		#region RenderVersion

		private static readonly DependencyPropertyKey RenderVersionPropertyKey =
			DependencyProperty.RegisterReadOnly("RenderVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata((int)0));

		internal static readonly DependencyProperty RenderVersionProperty =
			RenderVersionPropertyKey.DependencyProperty;

		internal int RenderVersion
		{
			get
			{
				return this._renderVersion;
			}
		}

		#endregion //RenderVersion

		#region RootRecordListControl
		internal RecordListControl RootRecordListControl
		{
			get { return this._rootRecordListControl; }
		}
		#endregion //RootRecordListControl

		#region ScrollableRecordCountVersion

		// JM 09-26-07 BR26775 - Change to Dependency property so it can be bound to.
		//internal int ScrollableRecordCountVersion { get { return this._scrollableRowCountVersion; } }

		internal static readonly DependencyProperty ScrollableRecordCountVersionProperty = DependencyProperty.Register("ScrollableRecordCountVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata(0));

		internal int ScrollableRecordCountVersion
		{
			get
			{
				return (int)this.GetValue(DataPresenterBase.ScrollableRecordCountVersionProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.ScrollableRecordCountVersionProperty, value);
			}
		}

		#endregion //ScrollableRecordCountVersion

		#region ScrollCountRecalcVersion

		// SSP 8/28/09 - Enhanced grid-view - TFS21591
		// Added ScrollCountRecalcVersion dependency property for the existing 
		// _scrollCountRecalcVersion member var.
		// 

		/// <summary>
		/// Identifies the <see cref="ScrollCountRecalcVersion"/> dependency property.
		/// </summary>
		internal static readonly DependencyProperty ScrollCountRecalcVersionProperty = DependencyProperty.Register(
			"ScrollCountRecalcVersion",
			typeof( int ),
			typeof( DataPresenterBase ),
			new FrameworkPropertyMetadata( 0, new PropertyChangedCallback( OnScrollCountRecalcVersionChanged ) )
		);

		/// <summary>
		/// Scroll count recalc version number which gets bumped whenever a property that affects
		/// how we calculate scroll counts is changed (for example a field's IsExpandable).
		/// </summary>
		internal int ScrollCountRecalcVersion
		{
			get
			{
				return _cachedScrollCountRecalcVersion;
			}
			set
			{
				this.SetValue( ScrollCountRecalcVersionProperty, value );
			}
		}

		internal void BumpScrollCountRecalcVersion( )
		{
			this.ScrollCountRecalcVersion++;
		}

		private static void OnScrollCountRecalcVersionChanged( DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e )
		{
			DataPresenterBase dp = (DataPresenterBase)dependencyObject;
			dp._cachedScrollCountRecalcVersion = (int)e.NewValue;
		}

		#endregion // ScrollCountRecalcVersion

		#region ScrollVersion

		internal static readonly DependencyProperty ScrollVersionProperty = DependencyProperty.Register("ScrollVersion",
			typeof(int), typeof(DataPresenterBase), new FrameworkPropertyMetadata(0));

		internal int ScrollVersion
		{
			get
			{
				return (int)this.GetValue(DataPresenterBase.ScrollVersionProperty);
			}
			set
			{
				this.SetValue(DataPresenterBase.ScrollVersionProperty, value);
			}
		}

		#endregion //ScrollVersion

		#region SelectionSnapshot







		private SelectedItemHolder SelectionSnapshot
		{
			get
			{
				if (this._selectionSnapshot == null)
					this._selectionSnapshot = new SelectedItemHolder(this);

				return this._selectionSnapshot;
			}
		}

		#endregion //SelectionSnapshot

		#region ShouldRaiseCellsInViewChanged

		// SSP 2/2/10
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 
		internal bool ShouldRaiseCellsInViewChanged
		{
			get
			{
				return null != _cellsInViewChangedEventHandler;
			}
		}

		#endregion // ShouldRaiseCellsInViewChanged

        // MBS 7/20/09 - NA9.2 Excel Exporting
        #region SuppressExportingDataSourceException

        internal bool SuppressExportingDataSourceException
        {
            get { return this._suppressExportingDataSourceException; }
            set { this._suppressExportingDataSourceException = value; }
        }
        #endregion //SuppressExportingDataSourceException

        #endregion //Internal Properties

        #region Private Properties

        #region FirstOverallDataRecord

        private DataRecord FirstOverallDataRecord
		{
			get
			{
				Record record;

				ViewableRecordCollection vrc = this.ViewableRecords;

				int scrollCount = vrc.ScrollCount;

				for (int i = 0; i < scrollCount; i++)
                {
                    record = vrc.GetRecordAtScrollPosition(i);
                    // JJD 6/14/07
                    // Use 'is' instead of IsSubclassOf since that is 10x more efficient
                    //if (record.GetType() == typeof(DataRecord) || record.GetType().IsSubclassOf(typeof(DataRecord)))

                    // JJD 1/12/09 - NA 2009 vol 1 - record filtering
                    // Use IsRecordValid method instead. 
                    //if (record is DataRecord)
                    //{
                    //    if (!((DataRecord)record).IsAddRecordTemplate)
                    //        return record as DataRecord;
                    //}
                    if (GridUtilities.IsRecordOfType(record, RecordType.DataRecord))
                        return record as DataRecord;
                }

				return null;
			}
		}

		#endregion //FirstOverallDataRecord

		// JJD 3/26/07 - added
		#region HorizontalScrollBarVisibility 

		private static readonly DependencyPropertyKey HorizontalScrollBarVisibilityPropertyKey =
			DependencyProperty.RegisterReadOnly("HorizontalScrollBarVisibility",
			typeof(ScrollBarVisibility), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FromValue(ScrollBarVisibility.Auto)));

		private static readonly DependencyProperty HorizontalScrollBarVisibilityProperty =
			HorizontalScrollBarVisibilityPropertyKey.DependencyProperty;

		private ScrollBarVisibility HorizontalScrollBarVisibility
		{
			get
			{
				return (ScrollBarVisibility)this.GetValue(DataPresenterBase.HorizontalScrollBarVisibilityProperty);
			}
		}

		#endregion //HorizontalScrollBarVisibility

		#region LastOverallDataRecord

		private DataRecord LastOverallDataRecord
		{
			get
			{
				Record record;

				ViewableRecordCollection vrc = this.ViewableRecords;

				int scrollCount = vrc.ScrollCount;

				for (int i = scrollCount - 1; i >= 0; i--)
				{
					record = vrc.GetRecordAtScrollPosition(i);

					// JJD 6/14/07
					// Use 'is' instead of IsSubclassOf since that is 10x more efficient
					//if (record.GetType() == typeof(DataRecord) || record.GetType().IsSubclassOf(typeof(DataRecord)))

                    // JJD 1/12/09 - NA 2009 vol 1 - record filtering
                    // Use IsRecordValid method instead. 
                    //if (record is DataRecord)
                    //{
                    //    if (!((DataRecord)record).IsAddRecordTemplate)
                    //        return record as DataRecord;
                    //}
                    if (GridUtilities.IsRecordOfType(record, RecordType.DataRecord))
						return record as DataRecord;
				}

				return null;
			}
		}

		#endregion //LastOverallDataRecord

		// MD 7/16/10 - TFS26592
		#region RaiseEventHelper

		private void RaiseEventHelper(RoutedEventArgs args)
		{
			if (this.IsEventSuppressed(args.RoutedEvent))
				return;

			this.RaiseEvent(args);
		} 

		#endregion // RaiseEventHelper

		// AS 4/12/11 TFS62951
		// Moved all logic that would set the various pivot fields to this helper so we can 
		// update some scrolling information when fixing fields.
		//
		#region SetPivotMember
		private void SetPivotMember<T>(ref T member, T newValue)
			where T : ISelectableItem
		{
			if (!object.Equals(member, newValue))
			{
				T oldValue = member;
				member = newValue;

				_fixedScrollHelper.OnPivotItemChanged(oldValue, newValue);
			}
		}
		#endregion //SetPivotMember

		#region StyleCache

		
#region Infragistics Source Cleanup (Region)








#endregion // Infragistics Source Cleanup (Region)

		#endregion //StyleCache

		// JJD 3/26/07 - added
		#region VerticalScrollBarVisibility

		private static readonly DependencyPropertyKey VerticalScrollBarVisibilityPropertyKey =
			DependencyProperty.RegisterReadOnly("VerticalScrollBarVisibility",
			typeof(ScrollBarVisibility), typeof(DataPresenterBase), new FrameworkPropertyMetadata(KnownBoxes.FromValue(ScrollBarVisibility.Auto)));

		private static readonly DependencyProperty VerticalScrollBarVisibilityProperty =
			VerticalScrollBarVisibilityPropertyKey.DependencyProperty;

		private ScrollBarVisibility VerticalScrollBarVisibility
		{
			get
			{
				return (ScrollBarVisibility)this.GetValue(DataPresenterBase.VerticalScrollBarVisibilityProperty);
			}
		}

		#endregion //VerticalScrollBarVisibility

		#endregion //Private Properties

		#endregion //Properties

		#region Methods

		#region Public Methods

		#region BringCellIntoView

		/// <summary>
		/// Scrolls the specified <see cref="Cell"/> into view
		/// </summary>
		/// <seealso cref="ActiveCell"/>
		/// <seealso cref="Cell"/>
		/// <seealso cref="DataRecord"/>
		/// <param name="cell">The cell to bring into view.</param>
		public void BringCellIntoView(Cell cell)
		{
			if (cell == null)
				throw new ArgumentNullException("cell");

			if (cell.Field == null ||
				 cell.Record == null ||
				 cell.Field.Owner == null)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_4"));

			if (cell.DataPresenter != this)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_5"));

			// AS 7/24/09 NA 2009.2 Field Sizing
			// I moved the original implementation into a helper method. While we are processing a request 
			// to bring the active cell into view, we want to avoid exiting edit mode on that cell.
			//
			bool isInEditMode = cell.IsInEditMode;

			try
			{
				if (isInEditMode)
					SuspendEndEditOnScroll();

				this.BringCellIntoViewImpl(cell);
			}
			finally
			{
				if (isInEditMode)
					ResumeEndEditOnScroll();
			}
		}

		private void BringCellIntoViewImpl(Cell cell)
		{
			// make sure the record is in view since we need to get the record presenter
			this.BringRecordIntoView(cell.Record);
			this.UpdateLayout();

			DataRecordPresenter rp = cell.Record.AssociatedRecordPresenter as DataRecordPresenter;

			if (null != rp && rp.ShouldDisplayRecordContent)
			{
				DataRecordCellArea cellArea = (DataRecordCellArea)Utilities.GetDescendantFromType(rp, typeof(DataRecordCellArea), true);

				VirtualizingDataRecordCellPanel virtualPanel = null != cellArea
					? cellArea.Content as VirtualizingDataRecordCellPanel
					: null;

				// make sure the cell is allocated and positioned
				if (null != virtualPanel)
					virtualPanel.EnsureCellIsCreated(cell);
			}


			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;

			if (panelNavigator != null)
				panelNavigator.EnsureCellIsVisible(cell);
		}

		#endregion //BringCellIntoView

		#region BringDataItemIntoView

		/// <summary>
		/// Scrolls the <see cref="Record"/> associated with the specified data item into view.
		/// </summary>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.DataItem"/>
		/// <seealso cref="DataSource"/>
		/// <param name="dataItem">The data item whose associated record should be scrolled into view.</param>
		/// <param name="recursive">True to recursively check all child DataRecords</param>
		/// <remarks>
		/// <para>The data item must be an object from the underlying DataSource.</para>
		/// <para></para>
		/// <para class="note"><b>Note:</b> This may be an expensive operation depending on the size and structure of the data. The logic first checks all of the DataRecords at the root level and if a match is not found then checks all of the descendant records.</para>
		/// </remarks>
		public void BringDataItemIntoView(object dataItem, bool recursive)
		{
			if (dataItem == null)
				throw new ArgumentNullException("dataItem");

			DataRecord record = this.GetRecordFromDataItem(dataItem, recursive);

			if (record == null)
				return;

			this.BringRecordIntoView(record);
		}

		#endregion //BringDataItemIntoView

		#region BringRecordIntoView

		/// <summary>
		/// Scrolls the specified <see cref="Record"/> into view
		/// </summary>
		/// <seealso cref="Records"/>
		/// <seealso cref="Record"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.DataItem"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="DataSource"/>
		/// <param name="record">The record to bring into view.</param>
		public void BringRecordIntoView(Record record)
		{
			if (record == null)
				throw new ArgumentNullException("record");

			if (record.DataPresenter != this)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_6"));

            // JJD 7/22/08 - BR34098
            // Make sure we don't have any pending invalidations
            if ( this._invalidateGeneratedStylesPending )
                this.OnInvalidateGeneratedStyles();

			// JJD 3/4/07
			// Call updatLayout  to make sure the visual tree matches the control state
			// before calling EnsureRecordIsVisible
			this.UpdateLayout();

			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;

			if (panelNavigator != null)
				panelNavigator.EnsureRecordIsVisible(record);
		}

		#endregion //BringRecordIntoView

		// AS 3/3/11 NA 2011.1 - Async Exporting
		#region CancelExport
		/// <summary>
		/// Cancels a previously started asynchronous export operation.
		/// </summary>
		/// <param name="exporter">The exporter whose asynchronous exporting is to be cancelled.</param>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public void CancelExport(IDataPresenterExporterAsync exporter)
		{
			this.ExportHelper.CancelExport(exporter);
		}
		#endregion //CancelExport

		#region ClearCustomizations

		
		
		/// <summary>
		/// Clears current user customizations based on the customizations parameter.
		/// </summary>
		/// <param name="customizations">Customizations to clear.</param>
		/// <seealso cref="CustomizationType"/>
		/// <seealso cref="SaveCustomizations()"/>
		/// <seealso cref="LoadCustomizations(string)"/>
		public void ClearCustomizations( CustomizationType customizations )
		{
			this.CustomizationsManager.ClearCustomizations( customizations );
		}

		#endregion // ClearCustomizations

        // AS 4/14/09 NA 2009.2 ClipboardSupport
        #region ClearUndoHistory
        /// <summary>
        /// Clears the undo/redo history.
        /// </summary>
        /// <seealso cref="IsUndoEnabled"/>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public void ClearUndoHistory()
        {
            if (null != _history)
                _history.Clear();
        } 
        #endregion //ClearUndoHistory

		#region CreateReportSection


		///// <summary>
        ///// Creates a <see cref="ReportSection"/> that can be used to output the contents of a DataPresenterBase derived control
        ///// to a <see cref="Infragistics.Windows.Reporting.Report"/>.
        ///// </summary>
        ///// <param name="reportSettings">The settings to use when outputting the contents of the control.</param>
        ///// <returns></returns>
        //public EmbeddedVisualReportSection CreateReportSection(DataPresenterReportSettings reportSettings)
        //{
        //    //TODO: implement CreateReportSection in DataPresenterBase
        //    throw new NotImplementedException("Feature not yet implemented.");
        //}


		#endregion //CreateReportSection	
    
		#region ExecuteCommand

		/// <summary>
		/// Executes the RoutedCommand represented by the specified CommandWrapper.
		/// </summary>
		/// <param name="commandWrapper">The CommandWrapper that contains the RoutedCommand to execute</param>
		/// <returns>True if command was executed, false if canceled.</returns>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutedCommand"/>
		/// <seealso cref="ExecuteCommand(RoutedCommand)"/>
		/// <seealso cref="DataPresenterCommands"/>
		public bool ExecuteCommand(CommandWrapper commandWrapper)
		{
			if (commandWrapper == null)
				throw new ArgumentNullException("commandWrapper");

			// AS 6/3/09 NA 2009.2 ClipboardSupport
			//return this.ExecuteCommandImpl(commandWrapper.Command, null, true);
			return this.ExecuteCommand(commandWrapper.Command, null);
		}

		/// <summary>
		/// Executes the specified RoutedCommand.
		/// </summary>
		/// <param name="command">The RoutedCommand to execute.</param>
		/// <returns>True if command was executed, false if canceled.</returns>
		/// <seealso cref="ExecutingCommand"/>
		/// <seealso cref="ExecutedCommand"/>
		/// <seealso cref="ExecuteCommand(CommandWrapper)"/>
		/// <seealso cref="DataPresenterCommands"/>
		public bool ExecuteCommand(RoutedCommand command)
		{
			return this.ExecuteCommandImpl(command, null, true);
		}

        // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
        /// <summary>
        /// Executes the specified RoutedCommand.
        /// </summary>
        /// <param name="command">The RoutedCommand to execute.</param>
        /// <param name="parameter">The parameter for the command execution</param>
        /// <returns>True if command was executed, false if canceled.</returns>
        /// <seealso cref="ExecutingCommand"/>
        /// <seealso cref="ExecutedCommand"/>
        /// <seealso cref="ExecuteCommand(CommandWrapper)"/>
        /// <seealso cref="DataPresenterCommands"/>
        public bool ExecuteCommand(RoutedCommand command, object parameter)
        {
			return this.ExecuteCommandImpl(command, parameter, true);
        }

        // JJD 2/26/09 - TFS14664
        //private bool ExecuteCommandImpl(RoutedCommand command, object commandParameter)
		private bool ExecuteCommandImpl(RoutedCommand command, object commandParameter, bool raiseEvents)
		{
			return ExecuteCommandImpl(new ExecuteCommandInfo(command, commandParameter, null), raiseEvents);
		}

		// AS 6/3/09 NA 2009.2 ClipboardSupport
		private bool ExecuteCommandImpl(ExecuteCommandInfo commandInfo, bool raiseEvents)
		{
			// AS 6/3/09 NA 2009.2 ClipboardSupport
			RoutedCommand command = commandInfo.RoutedCommand;
			object commandParameter = commandInfo.Parameter;

			// Make sure we have a command to execute.
			if (command == null)
				throw new ArgumentNullException("command");


			// Make sure the minimal control state exists to execute the command.
			if (DataPresenterCommands.IsMinimumStatePresentForCommand(this as ICommandHost, command) == false)
				return false;


            // JJD 2/26/09 - TFS14664
            // Check the raiseEvents flag
            if (raiseEvents)
            {
			    // Fire the 'before executed' cancelable event.
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                //ExecutingCommandEventArgs beforeArgs = new ExecutingCommandEventArgs(command);
			    ExecutingCommandEventArgs beforeArgs = new ExecutingCommandEventArgs(command, commandParameter);
			    bool proceed = this.RaiseExecutingCommand(beforeArgs);

                if (proceed == false)
                {
                    // JJD 06/02/10 - TFS33112
                    // Return the inverse of ContinueKeyRouting so that the developer can prevent
                    // the original key message from bubbling
                    //return false;
                    return !beforeArgs.ContinueKeyRouting;
                }
            }


			// Setup some info needed by more than 1 command.
			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;
			bool shiftKeyDown = (Keyboard.Modifiers & ModifierKeys.Shift) != 0;
			bool ctlKeyDown = (Keyboard.Modifiers & ModifierKeys.Control) != 0;
			bool tabKeyDown = Keyboard.IsKeyDown(Key.Tab);



			// =========================================================================================
			// Determine which of our supported commands should be executed and do the associated action.
			bool handled = false;

			#region ClearAllSelected

			if (command == DataPresenterCommands.ClearAllSelected)
			{
				handled = this.ClearAllSelected();

				goto PostExecute;
			}

			#endregion //ClearAllSelected

			#region DeleteSelectedDataRecords

			if (command == DataPresenterCommands.DeleteSelectedDataRecords)
			{
				handled = this.DeleteSelectedRecords(true);

				goto PostExecute;
			}

			#endregion //DeleteSelectedDataRecords

			#region ExpandRecord/CollapseRecord

			
#region Infragistics Source Cleanup (Region)

































#endregion // Infragistics Source Cleanup (Region)

			if (command == DataPresenterCommands.CollapseRecord ||
				command == DataPresenterCommands.ExpandRecord)
			{
				Record activeRecord = this.ActiveRecord;

				if (activeRecord != null)
					handled = activeRecord.ExpandCollapse(command == DataPresenterCommands.ExpandRecord, true);

				goto PostExecute;
			}

			#endregion //ExpandRecord/CollapseRecord

			#region StartEditMode

			if (command == DataPresenterCommands.StartEditMode)
			{
				Cell cell = this.ActiveCell;
				if (cell == null)
					goto PostExecute;

				CellValuePresenter cellValuePresenter = cell.AssociatedCellValuePresenter;

				if (cellValuePresenter == null)
					goto PostExecute;

				handled = cellValuePresenter.StartEditMode();

				goto PostExecute;
			}

			#endregion //StartEditMode

			#region EndEditMode

			// JJD 7/19/07 - BR22682
			// Added EndEditModeAndCommitRecord command
			if (command == DataPresenterCommands.EndEditModeAndAcceptChanges ||
				command == DataPresenterCommands.EndEditModeAndDiscardChanges ||
				command == DataPresenterCommands.EndEditModeAndCommitRecord)
			{
				Cell cell = this.ActiveCell;
				if (cell == null)
					goto PostExecute;

				// JJD 7/19/07 - BR22682
				// Added EndEditModeAndCommitRecord command
				if (command == DataPresenterCommands.EndEditModeAndAcceptChanges ||
					command == DataPresenterCommands.EndEditModeAndCommitRecord)
					cell.EndEditMode(true);
				else
					cell.EndEditMode(false);
			
				// JJD 7/19/07 - BR22682
				// Added EndEditModeAndCommitRecord command
				if (command == DataPresenterCommands.EndEditModeAndCommitRecord)
				{
					// If the exit of edit mode wasn't cancelled then commit the changes to the record
					if (!cell.IsInEditMode)
						this.CommitChangesToRecord(cell.Record);
				}

				handled = true;

				goto PostExecute;
			}

			#endregion //EndEditMode

			#region CommitChangesToActiveRecord

			if (command == DataPresenterCommands.CommitChangesToActiveRecord)
			{
				DataRecord record = this.ActiveRecord as DataRecord;
				if (record == null)
					goto PostExecute;

				// JJD 7/19/07 - BR22682
				// Moved logic to helper routine
				#region Old code

				//if (record.IsDataChanged)
				//{
				//    bool isAddReordWithDataItem = record.IsAddRecord &&
				//                                  !record.IsAddRecordTemplate;

				//    record.Update();

				//    if (isAddReordWithDataItem)
				//    {
				//        // JJD 3/4/07
				//        // Call updatLayout  to make sure the visual tree matches the control state
				//        // before calling EnsureRecordIsVisible
				//        this.UpdateLayout();

				//        IViewPanel pnlNavigator = this.CurrentPanel as IViewPanel;

				//        Debug.Assert(pnlNavigator != null);

				//        if (pnlNavigator != null)
				//            pnlNavigator.EnsureRecordIsVisible(record);
				//    }
				//}

				#endregion //Old code	
    
				this.CommitChangesToRecord(record);

                // JJD 3/2/09
                // Return true if the changes were committed
				//handled = record.IsDataChanged;
				handled = !record.IsDataChanged;

				goto PostExecute;
			}

			#endregion //CommitChangesToActiveRecord

			#region CommitChangesToAllRecords

			if (command == DataPresenterCommands.CommitChangesToAllRecords)
			{
				if (this._recordManager != null)
					this._recordManager.UpdateRecordsWithPendingChanges(false, true);

				handled = true;

				goto PostExecute;
			}

			#endregion //CommitChangesToAllRecords

			#region DiscardChangesToActiveRecord

			if (command == DataPresenterCommands.DiscardChangesToActiveRecord)
			{
				DataRecord record = this.ActiveRecord as DataRecord;
				if (record == null)
					goto PostExecute;

				this._recordWhoseChangesAreBeingDiscarded = record;	// JM 10-10-11 TFS91236

				if (record.IsDataChanged)
					record.CancelUpdate();

				this._recordWhoseChangesAreBeingDiscarded = null;	// JM 10-10-11 TFS91236

                // JJD 11/14/08 
                // If the cancelUpdate succeeded then IsDataChanged is false not true
				//handled = record.IsDataChanged;
				handled = !record.IsDataChanged;

				goto PostExecute;
			}

			#endregion //DiscardChangesToActiveRecord

			#region DiscardChangesToAllRecords

			if (command == DataPresenterCommands.DiscardChangesToAllRecords)
			{
				if (this._recordManager != null)
					this._recordManager.UpdateRecordsWithPendingChanges(true, true);

				handled = true;

				goto PostExecute;
			}

			#endregion //DiscardChangesToAllRecords

			#region Record Navigation

			if (command == DataPresenterCommands.RecordAbove ||
				command == DataPresenterCommands.RecordBelow ||
				command == DataPresenterCommands.RecordLeft ||
				command == DataPresenterCommands.RecordRight ||
				command == DataPresenterCommands.RecordNext ||
				command == DataPresenterCommands.RecordPrevious)
			{
				if (panelNavigator != null)
				{
					PanelNavigationDirection navigationDirection = (command == DataPresenterCommands.RecordAbove) ? PanelNavigationDirection.Above :
															  (command == DataPresenterCommands.RecordBelow) ? PanelNavigationDirection.Below :
															  (command == DataPresenterCommands.RecordLeft) ? PanelNavigationDirection.Left :
															  (command == DataPresenterCommands.RecordRight) ? PanelNavigationDirection.Right :
															  (command == DataPresenterCommands.RecordNext && panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewVertical) ? PanelNavigationDirection.Below :
															  (command == DataPresenterCommands.RecordNext && panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewHorizontal) ? PanelNavigationDirection.Right :
															  (command == DataPresenterCommands.RecordPrevious && panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewVertical) ? PanelNavigationDirection.Above :
															  (command == DataPresenterCommands.RecordPrevious && panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewHorizontal) ? PanelNavigationDirection.Left :
															  (command == DataPresenterCommands.RecordNext && panelNavigator.LayoutStyle == PanelLayoutStyle.Custom) ? PanelNavigationDirection.Next :
															  (command == DataPresenterCommands.RecordPrevious && panelNavigator.LayoutStyle == PanelLayoutStyle.Custom) ? PanelNavigationDirection.Previous :
															  PanelNavigationDirection.Previous;

					Record record = panelNavigator.GetNavigationTargetRecord(this.ActiveRecord,
																										navigationDirection,
																										this as ISelectionHost,
																										shiftKeyDown,
																										ctlKeyDown,
																										PanelSiblingNavigationStyle.AcrossParentsNoWrap,
																										typeof(Record));

					if (record != null)
					{
						SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(record);
						if (selectionStrategy != null)
						{
                            // JJD 10/14/09 - TFS22988
                            // Since RecordPrevious is mapped to a shift/tab key combination we should
                            // not pass the shift key down to SelectItemViaKeyboard.
                            // Otherwise, it might do a range selection.
                            if (command == DataPresenterCommands.RecordPrevious)
                                shiftKeyDown = false;

							selectionStrategy.SelectItemViaKeyboard(record, shiftKeyDown, ctlKeyDown, false);

							handled = true;
						}

						this.BringRecordIntoView(record);

						if (record != null && this.IsKeyboardFocusWithin)
							record.FocusIfActive();
					}

					// JM 09-08-08 TFS6016 - If the command was RecordAbove, RecordBelow, RecordLeft or RecordRight, force handled to be true
					// so the framework doesn't try to activate an element.
					if (command == DataPresenterCommands.RecordAbove	||
						command == DataPresenterCommands.RecordBelow	||
						command == DataPresenterCommands.RecordLeft		||
						command == DataPresenterCommands.RecordRight)
						handled = true;
				}

				goto PostExecute;
			}

			if (command == DataPresenterCommands.RecordFirstDisplayed ||
				command == DataPresenterCommands.RecordLastDisplayed ||
				command == DataPresenterCommands.RecordFirstOverall ||
				command == DataPresenterCommands.RecordLastOverall)
			{
				Record record = (command == DataPresenterCommands.RecordFirstDisplayed) ? panelNavigator.GetFirstDisplayedRecord(typeof(Record)) :
								(command == DataPresenterCommands.RecordLastDisplayed) ? panelNavigator.GetLastDisplayedRecord(typeof(Record)) :
								(command == DataPresenterCommands.RecordFirstOverall) ? panelNavigator.GetFirstOverallRecord(typeof(Record)) :
																						  panelNavigator.GetLastOverallRecord(typeof(Record));
				SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(record);
				if (selectionStrategy != null)
				{
					selectionStrategy.SelectItemViaKeyboard(record, shiftKeyDown, ctlKeyDown, false);

					if (command == DataPresenterCommands.RecordFirstOverall ||
						command == DataPresenterCommands.RecordLastOverall)
					{
                        // JJD 7/22/08 - BR34098
                        // Make sure we don't have any pending invalidations
                        if (this._invalidateGeneratedStylesPending)
                            this.OnInvalidateGeneratedStyles();
                        
                        // JJD 3/4/07
						// Call updatLayout  to make sure the visual tree matches the control state
						// before calling EnsureRecordIsVisible
						this.UpdateLayout();

                        // JJD 10/16/09 - TFS16793
                        // For fixed records, since they are already in view we should get
                        // the next sibling record tha is scrollable and scroll that into view
                        if (record.IsFixed == true)
                        {
                            ViewableRecordCollection vrc = record.ParentCollection.ViewableRecords;

                            if (vrc != null && 
                                vrc.Count > vrc.CountOfFixedRecordsOnBottom + vrc.CountOfFixedRecordsOnTop)
                            {
                                if (command == DataPresenterCommands.RecordFirstOverall)
                                    record = vrc[vrc.CountOfFixedRecordsOnTop];
                                else
                                    record = vrc[vrc.Count - (vrc.CountOfFixedRecordsOnBottom + 1)];
                            }
                        }

						
						
						
						if ( null != record )
							panelNavigator.EnsureRecordIsVisible(record);
					}


					handled = true;
				}

				if ( record != null && this.IsKeyboardFocusWithin )
					record.FocusIfActive();

				goto PostExecute;
			}

			#endregion //Record Navigation

			#region Record Page Navigation

			if (command == DataPresenterCommands.RecordPageAbove ||
				command == DataPresenterCommands.RecordPageBelow ||
				command == DataPresenterCommands.RecordPageLeft ||
				command == DataPresenterCommands.RecordPageRight)
			{
				if (panelNavigator != null)
				{
                    // JJD 2/26/09 - TFS14664
                    // If we aren't on the first or last record currently displayed then
                    // invoke the appropriate command and bail since we don't want to scroll
                    // unless we the first or last record in view is selected
					// SSP 3/18/10 TFS29783 - Optimizations
					// Changed the CurrentState property to a method that takes in the states to query.
					// 
                    //States states = (States)(((ICommandHost)this).CurrentState);
					States recordFirstLastStates = (States)( ( (ICommandHost)this ).GetCurrentState( (long)( States.RecordLastDisplayed | States.RecordFirstDisplayed ) ) );

                    if (command == DataPresenterCommands.RecordPageBelow ||
                        command == DataPresenterCommands.RecordPageRight)
                    {
						if ( ( recordFirstLastStates & States.RecordLastDisplayed ) == 0 )
                        {
                            handled = this.ExecuteCommandImpl(DataPresenterCommands.RecordLastDisplayed, null, false);
                            goto PostExecute;
                        }
                    }
                    else
                    {
                        if (command == DataPresenterCommands.RecordPageAbove ||
                            command == DataPresenterCommands.RecordPageLeft)
                        {
							if ( ( recordFirstLastStates & States.RecordFirstDisplayed ) == 0 )
                            {
                                handled = this.ExecuteCommandImpl(DataPresenterCommands.RecordFirstDisplayed, null, false);
                                goto PostExecute;
                            }
                        }
                    }

					// Do the proper scroll based on the command.
                    if (command == DataPresenterCommands.RecordPageAbove)
                        panelNavigator.Scroll(PanelNavigationScrollType.PageAbove);
                    else
                        if (command == DataPresenterCommands.RecordPageBelow)
                            panelNavigator.Scroll(PanelNavigationScrollType.PageBelow);
                        else
                            if (command == DataPresenterCommands.RecordPageLeft)
                                panelNavigator.Scroll(PanelNavigationScrollType.PageLeft);
                            else
                                panelNavigator.Scroll(PanelNavigationScrollType.PageRight);
					
					// we need to invalidate the panel's measure
					this.CurrentPanel.InvalidateMeasure();

					// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
					// If the shift and ctrl keys are not down and we are in a pageup/down key down
					// then defer the record selection until the layoutupdated event is raised by
					// using the new AsyncPageCommand class
					if (shiftKeyDown == false && ctlKeyDown == false && _isInPageUpDown)
					{
						if (_asyncCommand == null)
							_asyncCommand = new AsyncPageCommand(this);
						
						_asyncCommand.Command = command;
					}
					else
					{
						// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
						// Since we are about to execute the record selection synchronously
						// we need to detach and clear any pending AsyncPageCommand
						if ( _asyncCommand != null )
						{
							_asyncCommand.Detach();
							_asyncCommand = null;
						}

						// Force the panel to re-layout to ensure that the scroll we did above has 'taken effect'
						// when we select the first/last record below below
						this.CurrentPanel.UpdateLayout();


						// JJD 3/1/11 - TFS66934 - Optimization 
						// Re-factored coe into SelectFirstOrLastDisplayedRecord method
						// Select/Activate the appropriate record. 
						this.SelectFirstOrLastDisplayedRecord(command == DataPresenterCommands.RecordPageAbove ||
																command == DataPresenterCommands.RecordPageLeft,  shiftKeyDown, ctlKeyDown);
					}

					handled = true;
				}

				goto PostExecute;
			}

			#endregion //Record Page Navigation

			#region Cell Navigation

			if (command == DataPresenterCommands.CellAbove ||
				command == DataPresenterCommands.CellBelow ||
				command == DataPresenterCommands.CellLeft ||
				command == DataPresenterCommands.CellRight ||
				command == DataPresenterCommands.CellNext ||
				command == DataPresenterCommands.CellPrevious ||
				// SSP 7/19/07 BR21366
				// Added CellNextByTab and CellPreviousByTab commands.
				// 
				command == DataPresenterCommands.CellNextByTab ||
				command == DataPresenterCommands.CellPreviousByTab
				)
			{
				// JM 08-05-09 TFS19975 - Since we are finding the next cell by interpreting the 'direction' as a 'logical' direction
				//						  rather than a purely 'spatial' one (i.e., navigate right is being interpreted as navigating
				//						  to the next logical column not to the column on the right), the command needs to be 'flipped'
				//						  if the FlowDirection is RightToLeft and the requested navigation direction is Right or Left.
				if (this.FlowDirection == FlowDirection.RightToLeft)
				{
					if (command == DataPresenterCommands.CellRight)
						command = DataPresenterCommands.CellLeft;
					else
						if (command == DataPresenterCommands.CellLeft)
							command = DataPresenterCommands.CellRight;
				}

				if (panelNavigator != null)
				{
					Cell activeCell = this.ActiveCell;

					bool wasInEdit = activeCell != null && activeCell.IsInEditMode;

					PanelNavigationDirection navigationDirection =
							(command == DataPresenterCommands.CellAbove) ? PanelNavigationDirection.Above :
							(command == DataPresenterCommands.CellBelow) ? PanelNavigationDirection.Below :
							(command == DataPresenterCommands.CellLeft) ? PanelNavigationDirection.Left :
							(command == DataPresenterCommands.CellRight) ? PanelNavigationDirection.Right :
							// SSP 7/19/07 BR21366
							// Added CellNextByTab and CellPreviousByTab commands.
							// 
							//(command == DataPresenterCommands.CellNext) ? PanelNavigationDirection.Next :
							//( command == DataPresenterCommands.CellPrevious ) ? PanelNavigationDirection.Previous :
							( command == DataPresenterCommands.CellNext || command == DataPresenterCommands.CellNextByTab ) ? PanelNavigationDirection.Next :
							( command == DataPresenterCommands.CellPrevious || command == DataPresenterCommands.CellPreviousByTab ) ? PanelNavigationDirection.Previous :
																			  PanelNavigationDirection.Next;

                    
#region Infragistics Source Cleanup (Region)














#endregion // Infragistics Source Cleanup (Region)


					PanelSiblingNavigationStyle navigationStyle = PanelSiblingNavigationStyle.AcrossParentsNoWrap;

					// JJD 12/5/06 - BR18303
					// if we are back tabbing then clear the shift key so we don't select a range of cells
					// SSP 7/19/07 BR21366
					// Added CellNextByTab and CellPreviousByTab commands.
					// 
					//if (tabKeyDown && command == DataPresenterCommands.CellPrevious)
					if ( tabKeyDown && command == DataPresenterCommands.CellPreviousByTab )
						shiftKeyDown = false;

					Cell cell = this.GetNavigationTargetCell(activeCell, navigationDirection, this as ISelectionHost, shiftKeyDown, ctlKeyDown, navigationStyle);
					if (cell != null)
					{
						SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(cell);
						if (selectionStrategy != null)
						{
							// JJD 7/12/07 - BR19511
							// Set the snaking mode if we active record is the saame as the pivot record 
							// and we are range selecting left or right in grid view
							if (shiftKeyDown && this._pivotCell != null)
							{
								ViewBase view = this.CurrentViewInternal;

								if (view != null)
								{
									Orientation orientation = view.LogicalOrientation;

									if (this._pivotCell.IsOnSameTier(activeCell, orientation))
									{
										if (orientation == Orientation.Vertical)
										{
											if (command == DataPresenterCommands.CellLeft ||
												command == DataPresenterCommands.CellRight)
												this._snaking = true;
										}
										else
										{
											if (command == DataPresenterCommands.CellAbove ||
												command == DataPresenterCommands.CellBelow)
												this._snaking = true;
										}
									}
								}
							}

							// SSP 2/6/09 TFS13647
							// Bring cell into view only if the cell was activated. If activating cell was canceled
							// (maybe because the current active cell is in edit mode with invalid value), then 
							// don't try to it into view.
							// 
							//selectionStrategy.SelectItemViaKeyboard(cell, shiftKeyDown, ctlKeyDown, false);
							//this.BringCellIntoView(cell);
							if (selectionStrategy.SelectItemViaKeyboard(cell, shiftKeyDown, ctlKeyDown, false))
								this.BringCellIntoView(cell);

							// for next and previous we want to enter edit mode
							// SSP 7/19/07 BR21366
							// Added CellNextByTab and CellPreviousByTab commands.
							// 
							//if (command == DataPresenterCommands.CellPrevious || command == DataPresenterCommands.CellNext)
							if (command == DataPresenterCommands.CellPreviousByTab || command == DataPresenterCommands.CellNextByTab)
							{
								if (cell.IsEditingAllowed && cell.IsActive)
								{
									bool startEdit = false;

									// SSP 9/9/09 TFS19158
									// Added GetCellClickActionResolved virtual method on the DataRecord.
									// 
									//switch (cell.Field.CellClickActionResolved)
									switch ( cell.Record.GetCellClickActionResolved( cell.Field ) )
									{
										case CellClickAction.EnterEditModeIfAllowed:
											startEdit = true;
											break;
										case CellClickAction.SelectCell:
										
										
										
										
										case CellClickAction.SelectRecord:
											// only go into edit mode if we were in edit mode
											// on the previous cell
											startEdit = wasInEdit;
											break;
									}

									if (startEdit == true)
										this.ExecuteCommand(DataPresenterCommands.StartEditMode);
								}
							}
						}
						else
						{
							this.BringCellIntoView(cell);
						}

						if (this.IsKeyboardFocusWithin)
							cell.FocusIfActive();
					}
					// JM 07-14-09 - TFS 19108 - Handle the Cell == null case for the CellNextByTab command when 
					// tabbing off the Add Row.
					else
					{
						FieldLayout fl = activeCell.Field.Owner;
						if (tabKeyDown											&&
							command		== DataPresenterCommands.CellNextByTab	&&
							activeCell	!= null									&&
							activeCell.Record.IsAddRecord						&&
							raiseEvents == true									&&
							fl			!= null									&&
							fl.AddNewRecordLocationResolved == AddNewRecordLocation.OnBottom)
						{
							this.CommitChangesToRecord(activeCell.Record);
							this.ExecuteCommandImpl(command, commandParameter, false);
						}
					}

					// AS 7/18/07 BR24579
					// This comment is actually incorrect. We do want to allow tabbing out
					// of the control but we were always handling the keydown. However, since 
					// we don't want arrow keys causing the control to lose focus, we should
					// only not mark it handled if there was a cell to navigate to or if the 
					// tab key was not down (i.e. the arrow keys may have been used).
					//
					//// always mark this as handled because we don't allow tabbing or arrowing out of the DP
					//handled = true;
					handled = cell != null || tabKeyDown == false;
				}

				goto PostExecute;
			}

			if (command == DataPresenterCommands.CellFirstDisplayed ||
				command == DataPresenterCommands.CellLastDisplayed ||
				command == DataPresenterCommands.CellFirstOverall ||
				command == DataPresenterCommands.CellLastOverall ||
				command == DataPresenterCommands.CellFirstInRecord ||
				command == DataPresenterCommands.CellLastInRecord)
			{
				DataRecord record = null;

				if (command == DataPresenterCommands.CellFirstDisplayed)
					record = panelNavigator.GetFirstDisplayedRecord(typeof(DataRecord)) as DataRecord;
				else
					if (command == DataPresenterCommands.CellLastDisplayed)
						record = panelNavigator.GetLastDisplayedRecord(typeof(DataRecord)) as DataRecord;
					else
						if (command == DataPresenterCommands.CellFirstOverall)
							record = this.FirstOverallDataRecord;
						else
							if (command == DataPresenterCommands.CellLastOverall)
								record = this.LastOverallDataRecord;
							else
								if (command == DataPresenterCommands.CellFirstInRecord ||
									command == DataPresenterCommands.CellLastInRecord)
									record = this.ActiveRecord as DataRecord;

				if (record != null)
				{
					Cell cell = null;

					if (command == DataPresenterCommands.CellFirstDisplayed ||
						command == DataPresenterCommands.CellFirstOverall ||
						command == DataPresenterCommands.CellFirstInRecord)
						cell = record.FirstDisplayedCell;
					else
						cell = record.LastDisplayedCell;

					if (cell != null)
					{
						SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(cell);
						if (selectionStrategy != null)
						{
							selectionStrategy.SelectItemViaKeyboard(cell, shiftKeyDown, ctlKeyDown, false);

							// JJD 3/4/07
							// Call updatLayout  to make sure the visual tree matches the control state
							// before calling EnsureRecordIsVisible
							this.UpdateLayout();

							if (command == DataPresenterCommands.CellFirstOverall ||
								command == DataPresenterCommands.CellLastOverall)
							{
								panelNavigator.EnsureRecordIsVisible(record);
							}

							this.BringCellIntoView(cell);

							handled = true;
						}

						if (this.IsKeyboardFocusWithin)
							cell.FocusIfActive();
					}
				}

				goto PostExecute;
			}

			#endregion //Cell Navigation

			#region Cell Page Navigation

			if (command == DataPresenterCommands.CellPageAbove ||
				command == DataPresenterCommands.CellPageBelow ||
				command == DataPresenterCommands.CellPageLeft ||
				command == DataPresenterCommands.CellPageRight)
			{
				Cell activeCell = this.ActiveCell;

				// JJD 3/14/07
				// Rewrote entire routine for cell paging
				//
				// 1st ensure that the active cell is in view
				if (activeCell != null &&
					panelNavigator != null &&
					panelNavigator.EnsureRecordIsVisible(activeCell.Record))
				{
					this.UpdateLayout();

					if (panelNavigator.EnsureCellIsVisible(activeCell))
					{
						bool down = (command == DataPresenterCommands.CellPageRight ||
									 command == DataPresenterCommands.CellPageBelow);

						bool pageInXDimension = (command == DataPresenterCommands.CellPageRight ||
												command == DataPresenterCommands.CellPageLeft);

						// call UpdateLayout to make sure everything is synced up
						this.UpdateLayout();

						#region Find the RecordPresenter of the current active cell

						List<RecordPresenter> beforeInViewRecords = new List<RecordPresenter>();

						// JJD 3/21/07
						// Pass true for the 'excludeFixedRootRecords' param
						this.GetRecordPresentersInViewHelper(this, this.CurrentPanel, beforeInViewRecords, true, pageInXDimension, !pageInXDimension, true, typeof(DataRecord), true );

						
						
						
						
						
						

						DataRecordPresenter drp = null;
						int indexOfDrpInViewBefore = -1;

						// field the record presenter for the active cell
						for (int i = 0; i < beforeInViewRecords.Count; i++)
						{
							DataRecordPresenter inViewDrp = beforeInViewRecords[i] as DataRecordPresenter;

							if (inViewDrp != null &&
								inViewDrp.Record == activeCell.Record)
							{
								indexOfDrpInViewBefore = i;
								drp = inViewDrp;
								break;
							}
						}

						Debug.Assert(indexOfDrpInViewBefore >= 0);

						if (indexOfDrpInViewBefore < 0)
							goto PostExecute;

						#endregion //Find the RecordPresenter of the current active cell

						#region Calculate the original active cell rect in our coordinates

						// get the asscoiated cellvaluepresenter
						CellValuePresenter cvp = activeCell.AssociatedCellValuePresenter;

						Rect originalCellRect;

						// get the cvp rect in coordinates relative to the dp
						if (cvp != null)
							originalCellRect = new Rect(cvp.TranslatePoint(new Point(0, 0), this), new Size(cvp.ActualWidth, cvp.ActualHeight));
						else
							originalCellRect = Rect.Empty;

						#endregion //Calculate the origanl active cell rect in our coordinates

						#region Scroll if necessary

						bool scrollNeeded = false;

                        // JJD 12/23/09 
                        // Cache the scroll direction
                        PanelNavigationScrollType pageDirection = PanelNavigationScrollType.PageAbove;

						if (down)
						{
							if (indexOfDrpInViewBefore >= beforeInViewRecords.Count - 1)
							{
								scrollNeeded = true;
                                // JJD 12/23/09 
                                // Cache the scroll direction
                                //if (pageInXDimension)
                                //    panelNavigator.Scroll(PanelNavigationScrollType.PageRight);
                                //else
                                //    panelNavigator.Scroll(PanelNavigationScrollType.PageBelow);
								if (pageInXDimension)
									pageDirection = PanelNavigationScrollType.PageRight;
								else
									pageDirection = PanelNavigationScrollType.PageBelow;
							}
						}
						else
						{
							if (indexOfDrpInViewBefore < 1)
							{
								scrollNeeded = true;
                                // JJD 12/23/09 
                                // Cache the scroll direction
                                //if (pageInXDimension)
                                //    panelNavigator.Scroll(PanelNavigationScrollType.PageLeft);
                                //else
                                //    panelNavigator.Scroll(PanelNavigationScrollType.PageAbove);
								if (pageInXDimension)
                                    pageDirection = PanelNavigationScrollType.PageLeft;
                                else
                                    pageDirection = PanelNavigationScrollType.PageAbove;
                            }
						}

						#endregion //Scroll if necessary

						#region Get the target RecordPresenter

						RecordPresenter targetRP = null;

                        // JJD 12/23/09
                        // Keep track of the last page of rps
                        List<RecordPresenter> lastInViewRecords = new List<RecordPresenter>(beforeInViewRecords);

                        int pageIterationCount = 0;

                        // JJD 12/23/09 
                        // Page up to 2 times until we get a new cell 
						//if (scrollNeeded)
						while (scrollNeeded && pageIterationCount < 2)
						{
                            targetRP = null;

                            // JJD 12/23/09 
                            // scroll one page in the direction
                            panelNavigator.Scroll(pageDirection);
                            pageIterationCount++;

							// call UpdateLayout to make sure everything is synced up
							this.UpdateLayout();

							List<RecordPresenter> afterInViewRecords = new List<RecordPresenter>();

							// JJD 3/21/07
							// Pass true for the 'excludeFixedRootRecords' param
							this.GetRecordPresentersInViewHelper(this, this.CurrentPanel, afterInViewRecords, true, pageInXDimension, !pageInXDimension, true, typeof(DataRecord), true );

                            // JJD 12/23/09 
                            // if records haven't changed then break out of the while loop
                            if (lastInViewRecords.Count == afterInViewRecords.Count )
                            {
                                bool haveRecordsChanged = false;

                                if (afterInViewRecords.Count > 0)
                                    haveRecordsChanged = lastInViewRecords[0] != afterInViewRecords[0];

								if (!haveRecordsChanged)
								{
									// JJD 07/24/12 - TFS108091
									// If there are no DataRecords in view then clear the active cell.
									// Otherwise we would never be able to page in the same direction again
									// since if there is an active cell the firat thing we do above
									// during a paging command is to bring it into view
									if (lastInViewRecords.Count == 0)
									{
										this.ClearActiveCell();

										activeCell = this.ActiveCell;
									}

									break;
								}
                            }

                            if (afterInViewRecords.Count > 0 &&
                                 afterInViewRecords[0] != beforeInViewRecords[0])
                            {
								// JM 04-21-11 TFS73024.  Choose the last RecordPresenter in afterInViewRecords if we are scrolling down.
								if (down)
									targetRP = afterInViewRecords[afterInViewRecords.Count - 1];
								else
									targetRP = afterInViewRecords[Math.Min(indexOfDrpInViewBefore, afterInViewRecords.Count - 1)];

                                // JJD 12/23/09 
                                // If the record has changed then break out of while loop
                                if (targetRP.Record != activeCell.Record)
                                    break;
                            }

                            // JJD 12/23/09 
                            // Keep track of the last page of rps for the next pass
                            lastInViewRecords = new List<RecordPresenter>(afterInViewRecords);
						}

						if (targetRP == null)
						{
							if (down)
								targetRP = beforeInViewRecords[beforeInViewRecords.Count - 1];
							else
								targetRP = beforeInViewRecords[0];
						}

						if (targetRP == null)
							goto PostExecute;

						#endregion //Get the target RecordPresenter

						#region Get the target cell

						DataRecordPresenter targetDataRecordPresenter = targetRP as DataRecordPresenter;
						Cell targetCell = null;

						// JJD 07/24/12 - TFS108091
						// Make sure we still have an active cell
						//if (targetDataRecordPresenter != null)
						if (targetDataRecordPresenter != null && activeCell != null)
						{
							if (targetDataRecordPresenter.FieldLayout == activeCell.Field.Owner)
								targetCell = targetDataRecordPresenter.DataRecord.Cells[activeCell.Field];
							else
							{
								#region Get closest cell in another fieldLayout record

								CellValuePresenter[] cvps = targetDataRecordPresenter.GetChildCellValuePresenters();

								if (cvps != null && cvps.Length > 0)
								{
									bool isOriginalCellBefore = true;
									bool isOriginalCellBeforePrevious = true;

									for (int i = 0; i < cvps.Length; i++)
									{
										cvp = cvps[i];

										Rect cellRect = new Rect(cvp.TranslatePoint(new Point(0, 0), this), new Size(cvp.ActualWidth, cvp.ActualHeight));

										// since we only want to compare in one dimension sync up the other
										if (pageInXDimension)
										{
											cellRect.Y = originalCellRect.Y;
											cellRect.Height = originalCellRect.Height;
										}
										else
										{
											cellRect.X = originalCellRect.X;
											cellRect.Width = originalCellRect.Width;
										}

										// if the rects intersect we found our target cell
										if (cellRect.IntersectsWith(originalCellRect))
										{
											targetCell = cvp.Cell;
											break;
										}

										// determine if the original cell is before or after this cell
										if (pageInXDimension)
											isOriginalCellBefore = originalCellRect.Left < cellRect.Left;
										else
											isOriginalCellBefore = originalCellRect.Top < cellRect.Top;

										// if the before state has changed from the previus state
										// then use this cell
										if (i > 0 && isOriginalCellBefore != isOriginalCellBeforePrevious)
										{
											targetCell = cvp.Cell;
											break;
										}

										// hold the last flag state
										isOriginalCellBeforePrevious = isOriginalCellBefore;
									}

									// since we didn't get a direct hit use the first or last 
									// cell based on the isOriginalCellBeforePrevious flag
									if (isOriginalCellBeforePrevious)
										targetCell = cvps[0].Cell;
									else
										targetCell = cvps[cvps.Length - 1].Cell;
								}

								#endregion //Get closest cell in another fieldLayout record
							}
						}

						#endregion //Get the target cell

						#region Select the target

						ISelectableItem targetItem;

						// target either the cell or the record 
						if (targetCell != null)
							targetItem = targetCell;
						else
						{
							targetItem = targetRP.Record;
							shiftKeyDown = false;
							ctlKeyDown = false;
						}

						// JJD 04/03/12 - TFS107670
						// If we don't have a targetItem then bail
						if (targetItem == null)
						{
							handled = true;
							goto PostExecute;
						}

						SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(targetItem);

						// select the target
						if (selectionStrategy != null)
							selectionStrategy.SelectItemViaKeyboard(targetItem, shiftKeyDown, ctlKeyDown, false);

						#endregion //Select the target

						#region make sure that the record is active

						if (!targetRP.Record.IsActive)
							this.ActiveRecord = targetRP.Record;

						#endregion //make sure that the record is active	
    
						#region Finally make sure the target cell or record is fully in view

						if (targetCell != null)
							panelNavigator.EnsureCellIsVisible(targetCell);
						
						
						
						
						else if ( null != targetRP.Record )
							panelNavigator.EnsureRecordIsVisible(targetRP.Record);

						this.UpdateLayout();

						#endregion //Make sure the cell or record is fully in view	
    
						handled = true;
					}
				}

				goto PostExecute;
			}

			#endregion //Cell Page Navigation

			#region ToggleActiveCellSelectionState

			if (command == DataPresenterCommands.ToggleActiveCellSelectionState)
			{
				Cell cell = this.ActiveCell;
				if (cell == null || !((ISelectableItem)cell).IsSelectable)
					goto PostExecute;

				SelectionStrategyBase strategy = ((ISelectionHost)this).GetSelectionStrategyForItem(cell);

				if (strategy != null && (strategy.IsMultiSelect || strategy.IsSingleSelect))
				{
                    // JJD 3/2/09
                    // Hold the old selection state
                    bool wasSelected = cell.IsSelected;

					strategy.SelectItemViaKeyboard(cell, shiftKeyDown, ctlKeyDown, true);

                    // JJD 3/2/09
                    // Only return true if the slection state has changed
					//handled = true;
					handled = wasSelected != cell.IsSelected;
				}

				goto PostExecute;
			}

			#endregion //ToggleActiveCellSelectionState

			#region ToggleActiveRecordSelectionState

			if (command == DataPresenterCommands.ToggleActiveRecordSelectionState)
			{
				Record record = this.ActiveRecord;
				if (record == null || !((ISelectableItem)record).IsSelectable)
					goto PostExecute;

				SelectionStrategyBase strategy = ((ISelectionHost)this).GetSelectionStrategyForItem(record);

				if (strategy != null && (strategy.IsMultiSelect || strategy.IsSingleSelect))
				{
                    // JJD 3/2/09
                    // Hold the old selection state
                    bool wasSelected = record.IsSelected;

                    // JJD 3/2/09
                    // first try to clear the active cell
                    if (this.ActiveCell != null)
                    {
                        this.ActiveCell = null;

                        // if de-activating the cell was cancelled the return
                        if ( this.ActiveCell != null )
                            goto PostExecute;
                    }

					strategy.SelectItemViaKeyboard(record, shiftKeyDown, ctlKeyDown, true);
                    
                    // JJD 3/2/09
                    // Only return true if the slection state has changed
                    //handled = true;
                    handled = wasSelected != record.IsSelected;
                }

				goto PostExecute;
			}

			#endregion //ToggleActiveRecordSelectionState

            // JJD 12/30/08 NA 2009 Vol 1 - Record filtering
            #region Filter Commands
            if (command == DataPresenterCommands.ClearActiveCellFilters ||
                command == DataPresenterCommands.ToggleFilterOperatorDropDown)
            {
                FilterCell fc = commandParameter as FilterCell;

                if (fc == null)
                {
                    Field field = commandParameter as Field;

                    if (field != null)
                    {
                        FilterRecord fr = this.ActiveRecord as FilterRecord;

                        if (fr != null && field.Owner == fr.FieldLayout)
                            fc = fr.Cells[field];
                    }
                    else 
                    {
                        FilterCellValuePresenter fcvp = commandParameter as FilterCellValuePresenter;

                        if (fcvp != null)
                            fc = fcvp.Cell as FilterCell;
                    }
                }


                if ( fc == null )
                    fc = this.ActiveCell as FilterCell;

                if (null != fc)
                {
                    if (!fc.IsInEditMode)
                    {
                        // If another cell is in edit mode then try to exit
                        // if the exit was cancelled eat the command
                        if (this.EndEditMode(true, false) == false)
                            goto PostExecute;
                    }

                    if (command == DataPresenterCommands.ClearActiveCellFilters)
                    {
						fc.ClearActiveFilters(true );
                        handled = true;
                    }
                    else
                    {
                        this.BringCellIntoView(fc);

                        this.UpdateLayout();

                        FilterCellValuePresenter fcvp = fc.AssociatedCellValuePresenter as FilterCellValuePresenter;

                        if (fcvp != null && fcvp.Field != null &&
                            fcvp.Field.FilterOperatorVisibilityResolved == Visibility.Visible)
                        {
                            fcvp.IsOperatorDropDownOpen = !fcvp.IsOperatorDropDownOpen;
                            handled = true;
                        }
                    }
                }
                goto PostExecute;
            }

            if (command == DataPresenterCommands.ClearActiveRecordCellFilters)
            {
                FilterRecord fr = commandParameter as FilterRecord;

                if (fr == null)
                {
                    RecordPresenter rp = commandParameter as RecordPresenter;

                    if (rp != null)
                        fr = rp.Record as FilterRecord;
                }

                if ( fr == null )
                    fr = this.ActiveRecord as FilterRecord;

                if (null != fr)
                {
                    fr.ClearActiveFilters(true );
                    handled = true;
                }

                goto PostExecute;
            }

            #endregion //Filter Commands

            // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
            #region Fix/Unfix Commands
            if (command == DataPresenterCommands.FixFieldFar ||
                command == DataPresenterCommands.FixFieldNear ||
                command == DataPresenterCommands.UnfixField)
            {
                Field field = commandParameter as Field;

                if (null != field)
                {
                    FixedFieldLocation newLocation;

                    if (command == DataPresenterCommands.FixFieldNear)
                        newLocation = FixedFieldLocation.FixedToNearEdge;
                    else if (command == DataPresenterCommands.FixFieldFar)
                        newLocation = FixedFieldLocation.FixedToFarEdge;
                    else
                        newLocation = FixedFieldLocation.Scrollable;

                    if (field.FixedLocation != newLocation && field.IsFixedLocationAllowed(newLocation))
                    {
                        FieldPositionChangeReason reason = newLocation == FixedFieldLocation.Scrollable ? FieldPositionChangeReason.Unfixed : FieldPositionChangeReason.Fixed;
                        FieldPositionChangingEventArgs beforePosChangeArgs = new FieldPositionChangingEventArgs(field, reason);

                        this.RaiseFieldPositionChanging(beforePosChangeArgs);

                        if (false == beforePosChangeArgs.Cancel)
                        {
							// AS 6/4/09 NA 2009.2 Undo/Redo
							if (this.IsUndoEnabled)
							{
								FieldPositionAction action = new FieldPositionAction( 
									new Field[] { field },
									// SSP 6/26/09 - NAS9.2 Field Chooser
									// We want to take the snapshot of the current field layout if 
									// _dragFieldLayoutInfo hasn't been created yet (the user hasn't 
									// moved any fields yet). This way when undo is done, we don't
									// go back to auto-generating field layout. We should remain in
									// customized mode even after performing undo.
									// 
									//field.Owner._dragFieldLayoutInfo, 
									field.Owner.GetFieldLayoutInfo( true, true ), 
									FieldPositionAction.GetUndoReason( reason ), 
									field.FixedLocation );

								this.History.AddUndoActionInternal(action);
							}

                            // AS 3/3/09 Optimization
                            // Use a helper method so we can skip the global invalidation.
                            //
                            //field.FixedLocation = newLocation;
                            field.SetFixedLocation(newLocation);

							if (null != field.Owner)
								// AS 7/7/09 TFS19145/Optimization
								// We shouldn't need to bump the internal version for a position change just 
								// like we don't need to when the field visibility changes.
								//
								//field.Owner.InvalidateGeneratedStyles(true, false);
								field.Owner.InvalidateGeneratedStyles(false, false);

                            handled = true;

                            this.RaiseFieldPositionChanged(new FieldPositionChangedEventArgs(field, reason));
                        }
                    }
                }

                goto PostExecute;
            } 
            #endregion //Fix/Unfix Commands

            // JJD 6/10/09 NA 2009 Vol 2 - Record fixing
            #region Fix/Unfix Record Commands
            if (command == DataPresenterCommands.FixRecordTop ||
                command == DataPresenterCommands.FixRecordBottom ||
                command == DataPresenterCommands.UnfixRecord)
            {
                Record record = commandParameter as Record;

                if (null != record)
                {
                    FixedRecordLocation newLocation;

                    if (command == DataPresenterCommands.FixRecordTop)
                        newLocation = FixedRecordLocation.FixedToTop;
                    else if (command == DataPresenterCommands.FixRecordBottom)
                        newLocation = FixedRecordLocation.FixedToBottom;
                    else
                        newLocation = FixedRecordLocation.Scrollable;

                    if (record.FixedLocation != newLocation && record.IsFixedLocationAllowed(newLocation))
                    {
                        RecordFixedLocationChangingEventArgs beforePosChangeArgs = new RecordFixedLocationChangingEventArgs(record, newLocation);

                        this.RaiseRecordFixedLocationChanging(beforePosChangeArgs);

                        if (false == beforePosChangeArgs.Cancel)
                        {
							// AS 6/4/09 NA 2009.2 Undo/Redo
							if (this.IsUndoEnabled)
							{
								RecordFixedStateAction action = new RecordFixedStateAction(new Record[] { record }, record.FixedLocation);
								this.History.AddUndoActionInternal(action);
							}

                            record.FixedLocation = newLocation;

                            handled = true;

                            this.RaiseRecordFixedLocationChanged(new RecordFixedLocationChangedEventArgs(record));
                        }
                    }
                }

                goto PostExecute;
            } 
            #endregion //Fix/Unfix Commands

            // AS 4/14/09 NA 2009.2 ClipboardSupport
            #region Undo/Redo
            if (command == DataPresenterCommands.Undo ||
                command == DataPresenterCommands.Redo)
            {
                handled = null != _history && _history.PerformUndoRedo(command == DataPresenterCommands.Undo);
                goto PostExecute;
            } 
            #endregion //Undo/Redo

            // AS 4/20/09 NA 2009.2 ClipboardSupport
            #region Clipboard Operation
            if (command == DataPresenterCommands.Cut ||
                command == DataPresenterCommands.Copy ||
                command == DataPresenterCommands.Paste ||
                command == DataPresenterCommands.ClearCellContents)
            {
                handled = this.ClipboardOperationInfo.PerformOperation(command);
                goto PostExecute;
            }
            #endregion //Clipboard Operation

			// AS 6/3/09 NA 2009.2 ClipboardSupport
			#region ToggleRecordIsExpanded
			if (command == DataPresenterCommands.ToggleRecordIsExpanded)
			{
				Record record = GetRecord(commandInfo);

				if (null != record)
				{
					handled = record.ExpandCollapse(!record.IsExpanded, true);
				}
				goto PostExecute;
			}
			#endregion //ToggleRecordIsExpanded

			// AS 6/9/09 NA 2009.2 Field Sizing
			#region AutoSizeField
			if (command == DataPresenterCommands.AutoSizeField)
			{
				Field field = commandInfo.Parameter as Field;

				if (null != field)
				{
					field.PerformAutoSize(field.AutoSizeOptionsResolved, field.AutoSizeScopeResolved, true);
					handled = true;
				}
				goto PostExecute;
			}
			#endregion //AutoSizeField

			#region ShowFieldChooser

			// SSP 6/18/09 - NAS9.2 Field Chooser
			// 

			if ( DataPresenterCommands.ShowFieldChooser == command )
			{
				FieldLayout fieldLayout = commandParameter as FieldLayout;
				this.ShowFieldChooser( fieldLayout, true, true );
			}

			#endregion // ShowFieldChooser

			// JM 11/5/09 NA 2010.1 CardView
			#region ToggleCardCollapsedState
			if (command == DataPresenterCommands.ToggleCardCollapsedState)
			{
				Record record = GetRecord(commandInfo);

				if (null != record)
				{
					handled = record.ToggleContainingCardCollapsedState(true);
				}
				goto PostExecute;
			}
			#endregion //ToggleCardCollapsedState

			// JM 11/5/09 NA 2010.1 CardView
			#region ToggleEmptyCardCellsCollapsedState
			if (command == DataPresenterCommands.ToggleEmptyCardCellsCollapsedState)
			{
				Record record = GetRecord(commandInfo);

				if (null != record)
				{
					handled = record.ToggleContainingCardEmptyCellsCollapsedState(true);
				}
				goto PostExecute;
			}
			#endregion //ToggleEmptyCardCellsCollapsedState

			// AS 3/3/11 NA 2011.1 - Async Exporting
			#region CancelExport
			if (command == DataPresenterCommands.CancelExport)
			{
				handled = this.ExportHelper.CancelExport(this);
				goto PostExecute;
			}
			#endregion //CancelExport
		// =========================================================================================

		PostExecute:
			// If the command was executed, fire the 'after executed' event.
            // JJD 2/26/09 - TFS14664
            // Check the raiseEvents flag
            if (raiseEvents && handled == true)
            {
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                //this.RaiseExecutedCommand(new ExecutedCommandEventArgs(command));
				this.RaiseExecutedCommand(new ExecutedCommandEventArgs(command, commandParameter));
            }


			return handled;
		}

		#endregion //ExecuteCommandImpl
    
		#region ExportToXps


        ///// <summary>
        ///// Exports the contents of a <see cref="DataPresenterBase"/> derived control to an XpsDocument.
        ///// </summary>
        ///// <param name="reportSettings">The settings to use when exporting the control to Xps.</param>
        ///// <returns>An XpsDocument instance if report runs to completion, null if it is canceled or an error occurs.</returns>
        //MM Commented 2008.03.20
        //public XpsDocument ExportToXps(DataPresenterReportSettings reportSettings)
        //{
        //    //TODO: Display dialog to capture DataPresenterReportSettings

        //    //TODO: Display PrintDialog to capture print settings?

            
        //    DataPresenterReportControl	dprc	= new DataPresenterReportControl(this, new DataPresenterReportSettings());
        //    Report						report	= new Report();
        //    report.Sections.Add(new EmbeddedVisualReportSection(dprc, dprc.CurrentPanel as IEmbeddedVisualPaginator));

        //    //TODO: cleanup ExportToXps method to Create XpsDocument using Package instead of file
        //    try	{ File.Delete("filename.xps"); }
        //    catch { }

        //    XpsDocument			xpsDocument = new XpsDocument("filename.xps", FileAccess.ReadWrite);
        //    XpsDocumentWriter	writer		= XpsDocument.CreateXpsDocumentWriter(xpsDocument);
        //    writer.Write(((IDocumentPaginatorSource)report).DocumentPaginator);

        //    return xpsDocument;
        //}


		#endregion //ExportToXps	

        // MBS 7/20/09 - NA9.2 Excel Exporting
        #region Export

        /// <summary>
        /// Begins the exporting process between the exporter and the data presenter.
        /// </summary>
        /// <param name="exporter">An object used to process the exporting queues provided by the data presenter.</param>
        /// <param name="options">The set of options controlling the exporting process.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ExcelExporter)]
        public void Export(IDataPresenterExporter exporter, IExportOptions options)
        {
			// AS 3/3/11 NA 2011.1 - Async Exporting
			//if (null == exporter)
			//    throw new ArgumentNullException("exporter");
			//
			//if (null == options)
			//    throw new ArgumentNullException("options");
			//
			//DataPresenterExportControl dataPresenterControl = new DataPresenterExportControl(this, exporter);
			//try
			//{
			//    // AS 8/19/09 TFS20860
			//    // Since no one was calling BeginInit, the Initialized event was lazily raised by the frameworkelement. In this 
			//    // case it was happening when the first logical child was added to the DataPresenter. This should be controlled 
			//    // so that it doesn't happen in the middle of the field layout's initialization logic.
			//    //
			//    dataPresenterControl.BeginInit();
			//
			//    // Set a flag that says that the control is being used for exporting so that we don't allow anyone to set the
			//    // DataSource except for when we copy it from the source control.
			//    dataPresenterControl.IsExporting = true;
			//
			//    // MBS 8/25/09
			//    // Previously we were using a TabularReportView due to the shared logic of ReportViewBase, but now 
			//    // that was refactored since we don't really need that view.  However, since we do need *a* view,
			//    // create a new one here before cloning the DataPresenter.
			//    dataPresenterControl.CurrentViewInternal = new ExportView();
			//
			//    dataPresenterControl.CloneSourceDataPresenter(null, options);
			//
			//    // AS 8/19/09 TFS20860
			//    dataPresenterControl.EndInit();
			//
			//    // Force the templates to be generated at this point because we'll need all that information when determining
			//    // where all of the rows should be positioned.
			//    //
			//    // TODO: Test to see if a FieldLayout can be generated after this, causing us to have improper data available
			//    foreach (FieldLayout fieldLayout in dataPresenterControl.FieldLayouts)
			//    {
			//        fieldLayout.EnsureStyleGeneratorInitialized();
			//        fieldLayout.VerifyStyleGeneratorTemplates();
			//    }
			//
			//    // Notify the exporter that we're about to begin the exporting process.  Note that we haven't actually
			//    // created/cloned any of the records at this point since we haven't set the data source.  This event
			//    // is mainly used for the basic initialization pre-binding.  Since the various DP events should be firing
			//    // after the binding, the developer should have the standard customization ability at that point.
			//    exporter.BeginExport(dataPresenterControl, options);
			//
			//    // We can bind the control at this point
			//    dataPresenterControl.BindToDataSource();
			//
			//    // Iterate through rows
			//    bool cancelled = !dataPresenterControl.ProcessRecords(options);
			//
			//    // Finally notify the exporter that the process has completed
			//    exporter.EndExport(cancelled);
			//}
			//finally
			//{
			//    dataPresenterControl.IsExporting = false;
			//}
			this.ExportHelper.Export(exporter, options);
        }
        #endregion //Export

		// AS 3/3/11 NA 2011.1 - Async Exporting
		#region ExportAsync

		/// <summary>
		/// Begins an asynchronous exporting process between the exporter and the data presenter.
		/// </summary>
		/// <param name="exporter">An object used to process the exporting queues provided by the data presenter.</param>
		/// <param name="options">The set of options controlling the exporting process.</param>
		/// <param name="showExportStatus">A boolean indicating whether the export status window should be displayed during the operation.</param>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public void ExportAsync(IDataPresenterExporterAsync exporter, IExportOptions options, bool showExportStatus)
		{
			this.ExportHelper.ExportAsync(exporter, options, showExportStatus);
		}

		/// <summary>
		/// Begins an asynchronous exporting process between the exporter and the data presenter.
		/// </summary>
		/// <param name="exporter">An object used to process the exporting queues provided by the data presenter.</param>
		/// <param name="options">The set of options controlling the exporting process.</param>
		/// <param name="showExportStatus">A boolean indicating whether the export status window should be displayed during the operation.</param>
		/// <param name="duration">The amount of time that should be used to perform the export each time the <paramref name="interval"/> elapses.</param>
		/// <param name="interval">The amount of time to wait after performing the export for the amount of time specified by the <paramref name="duration"/>.</param>
		/// <exception cref="ArgumentOutOfRangeException">The <paramref name="duration"/> and <paramref name="interval"/> must have a tick value greater than 0.</exception>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public void ExportAsync(IDataPresenterExporterAsync exporter, IExportOptions options, bool showExportStatus, TimeSpan duration, TimeSpan interval)
		{
			this.ExportHelper.ExportAsync(exporter, options, showExportStatus, duration, interval);
		}

		#endregion //ExportAsync

		#region GetCellsInView

		// SSP 2/2/10 - CellsInViewChanged Event 
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 
		/// <summary>
		/// Gets the cells that are currently in view.
		/// </summary>
		/// <returns>A collection of <see cref="VisibleDataBlock"/> objects.</returns>
		/// <remarks>
		/// <para class="body">
		/// <b>GetCellsInView</b> method returns a list of <see cref="VisibleDataBlock"/> objects where
		/// each <i>VisibleDataBlock</i> represents cells from a <see cref="RecordManager"/> that are
		/// currently in view. <i>VisibleDataBlock</i> contains a list of <see cref="DataRecord"/>s and
		/// <see cref="Field"/>s that effectively represent the cells that are in view.
		/// </para>
		/// </remarks>
		/// <seealso cref="CellsInViewChanged"/>
		/// <seealso cref="VisibleDataBlock"/>
		public List<VisibleDataBlock> GetCellsInView( )
		{
			return VisibleDataBlock.Create( this );
		}

		#endregion // GetCellsInView

		#region GetRecordFromDataItem

		/// <summary>
		/// Gets the <b>DataRecord</b> associated with a specific item in the DataSource.
		/// </summary>
		/// <param name="dataItem">An object from the underlying data source</param>
		/// <param name="recursive">If true will check all descendant records as well.</param>
		/// <returns>The associated <see cref="DataRecord"/> or null if not found.</returns>
		/// <remarks>Infragistics.Windows.DataPresenter this may be an expensive operation depending on the size and structure of the data. The logic first checks all of the DataRecords at the root level and if a match is not found then checks all of the descendant records.</remarks>
		/// <seealso cref="Records"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="DataRecord.DataItem"/>
		/// <seealso cref="DataSource"/>
		public DataRecord GetRecordFromDataItem(object dataItem, bool recursive)
		{
			if (dataItem == null)
				throw new ArgumentNullException("dataItem");

			DataRecord record = ((DataRecordCollection)(this.RecordManager.Unsorted)).GetDataRecordFromDataItem(dataItem, recursive);

			if (record != null &&
				record.DataPresenter != this)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_7"));

			return record;
		}

		#endregion //GetRecordFromDataItem

		#region GetRecordsInView

		/// <summary>
		/// Gets the <b>Record</b>s that are currntly in view.
		/// </summary>
		/// <param name="recursive">If true will include descendant records as well.</param>
		/// <returns>An array which contains all the records that are currently in view.</returns>
		/// <remarks>
		/// <para class="note"><b>Note: </b>Since <see cref="Record"/> is an abstract base class for <see cref="DataRecord"/>, <see cref="GroupByRecord"/> and <see cref="ExpandableFieldRecord"/> you may have to cast this property to the appropiate derived class to access specific properties, e.g. the <see cref="DataRecord"/>'s <see cref="DataRecord.Cells"/> collection.</para>
		/// </remarks>
		/// <seealso cref="DataRecord"/>
		/// <seealso cref="GroupByRecord"/>
		/// <seealso cref="ExpandableFieldRecord"/>
		/// <seealso cref="Records"/>
		/// <seealso cref="RecordManager"/>
		/// <seealso cref="RecordsInViewChanged"/>
		/// <seealso cref="BringRecordIntoView(Record)"/>
		/// <seealso cref="BringCellIntoView(Cell)"/>
		/// <seealso cref="RecordPresenter.FromRecord(Record)"/>
		/// <seealso cref="CellValuePresenter.FromRecordAndField(DataRecord,Field)"/>
		public Record[] GetRecordsInView(bool recursive)
		{
			// AS 2/26/10 TFS28159
			return GetRecordsInView(recursive, false);
		}

		// AS 2/26/10 TFS28159
		// I added a new overload because at least in the case of autosizing we 
		// are concerned with the records that will be in view and not care 
		// about the fact that they may be out of view temporarily as they 
		// are being animated into view.
		//
		internal Record[] GetRecordsInView(bool recursive, bool ignoreAnimations)
		{
			
			
			
			
			
			List<RecordPresenter> recordPresenters = this.GetRecordPresentersInView( recursive, ignoreAnimations );
			
#region Infragistics Source Cleanup (Region)












#endregion // Infragistics Source Cleanup (Region)

			

			Record[] recordArray = new Record[recordPresenters.Count];

			// fill the array with the rps' Records
			for (int i = 0; i < recordPresenters.Count; i++)
				recordArray[i] = recordPresenters[i].Record;

			return recordArray;
		}

		// SSP 2/1/10
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 
		internal List<RecordPresenter> GetRecordPresentersInView( bool recursive, bool ignoreAnimations )
		{
			// JJD 7/22/08 - BR34098
			// Make sure we don't have any pending invalidations
			if ( this._invalidateGeneratedStylesPending )
				this.OnInvalidateGeneratedStyles( );

			// first update the layout so any pending changes get applied
			this.UpdateLayout( );

			List<RecordPresenter> recordPresenters = new List<RecordPresenter>( );

			Panel panel = this.CurrentPanel;

			if ( panel != null )
				this.GetRecordPresentersInViewHelper( panel, panel, recordPresenters, recursive && this.CurrentViewInternal.IsNestedPanelsSupported, false, false, false, null, ignoreAnimations );

			return recordPresenters;
		}

        // JJD 12/23/09 - Added restrictToRecordType param
		//private void GetRecordPresentersInViewHelper(FrameworkElement parent, Panel topLevelPanel, List<RecordPresenter> recordPresenters, bool recursive, bool onlyFullyInViewInXDimension, bool onlyFullyInViewInYDimension, bool excludeFixedRootRecords)
		private void GetRecordPresentersInViewHelper(FrameworkElement parent, Panel topLevelPanel, List<RecordPresenter> recordPresenters, bool recursive, bool onlyFullyInViewInXDimension, bool onlyFullyInViewInYDimension, bool excludeFixedRootRecords, Type restrictToRecordType, bool ignoreAnimations )
		{
			// AS 9/4/09 Optimization
			//RecordPresenter firstRecord = Utilities.GetDescendantFromType(parent, typeof(RecordPresenter), true,) as RecordPresenter;
			RecordPresenter firstRecord = Utilities.GetDescendantFromType<RecordPresenter>(parent, true , null, new Type[] { typeof(RecordCellAreaBase) });

			if (firstRecord == null)
				return;

            // JJD 8/7/09  NA 2009 Vol 2 - Enhanced grid view
            bool isFlatView = this.IsFlatView;

			Visual stopAtVisual = VisualTreeHelper.GetParent(parent) as Visual;

			Panel parentPanel = topLevelPanel;

			DependencyObject descendant = firstRecord;

			// wlak up the ancestor chain to find the parent panel that implements IViewPanel
			while (parentPanel != null)
			{
				parentPanel = Utilities.GetAncestorFromType(descendant, typeof(Panel), true, stopAtVisual) as Panel;

				// JJD 2/8/11 - TFS65143
				// Allow IEmbeddedVisualPaginator panels to handle printing
				if (parentPanel is IViewPanel || parentPanel is IEmbeddedVisualPaginator)
					break;

				descendant = parentPanel;
			}

			Debug.Assert(parentPanel != null || Utilities.GetAncestorFromType(firstRecord, typeof(GridViewPanelAdorner), true, stopAtVisual) != null);

			if (parentPanel == null)
				return;

			// JM 01-19-10 - Get the ScrollContentPresenter's rect and use that as the constraining rect since not all panels have a size that 
			// that is the same viewable area size - e.g., GridViewPanel does but CardViewPanel does not.
			//Rect topLevelPanelRect = new Rect(new Size(topLevelPanel.ActualWidth, topLevelPanel.ActualHeight));
			Rect topLevelPanelRect;
			ScrollContentPresenter scp = Utilities.GetAncestorFromType(topLevelPanel, typeof(ScrollContentPresenter), true, this) as ScrollContentPresenter;
			if (scp != null)
				topLevelPanelRect = new Rect(new Size(scp.ActualWidth, scp.ActualHeight));
			else
				topLevelPanelRect = new Rect(new Size(topLevelPanel.ActualWidth, topLevelPanel.ActualHeight));

			IList children;

			// JJD 6/05/07
			// For RecyclingItemsPanel get the shadowed Children collection
			if (parentPanel is RecyclingItemsPanel)
				// AS 7/9/07
				//children = ((RecyclingItemsPanel)parentPanel).Children;
				children = ((RecyclingItemsPanel)parentPanel).ChildElements;
			else
				children = parentPanel.Children;

			// AS 2/26/10 TFS28159
			TilesPanelBase tilesPanel = parentPanel as TilesPanelBase;

			// JJD 6/05/07
			//foreach (UIElement child in parentPanel.Children)
			foreach (UIElement child in children)
			{
				// see if the immediate child is a RecordPresenter
				RecordPresenter rp = child as RecordPresenter;

				// if not get a descendant that is
				if (rp == null)
				{
					rp = Utilities.GetDescendantFromType(child, typeof(RecordPresenter), true) as RecordPresenter;

					if (rp == null)
						continue;
				}

				// bypass hidden rps
				if (rp.Visibility != Visibility.Visible || rp.Opacity < .0001)
					continue;

                // JJD 8/7/09  NA 2009 Vol 2 - Enhanced grid view
                // bypass header records
                if (rp.Record.RecordType == RecordType.HeaderRecord)
                    continue;

                // JJD 12/23/09
                // If restrictToRecordType param is specified make sure 
                // the record is of that type
                if (restrictToRecordType != null &&
                    !restrictToRecordType.IsAssignableFrom(rp.Record.GetType()))
                    continue;

				Rect rectinTopLevelPanelCoordinates;

				// AS 2/26/10 TFS28159
				// If the tiles panel is animating then the transformed location could be out of view 
				// even if the record is to be positioned in view. In some case, like when autosizing 
				// the fields, we want the records that will be in view so we'll ask the tiles panel 
				// in that case where the container will be.
				//
				//GeneralTransform transform = rp.TransformToAncestor(topLevelPanel);
				GeneralTransform transform = null;

				Rect tileClipRect = Rect.Empty;
				Rect tileRect = Rect.Empty;

				if (ignoreAnimations && null != tilesPanel)
				{
					tileClipRect = tilesPanel.GetInViewRect(child);

					Debug.Assert(tileClipRect.Width != 0 || tileClipRect.Height != 0, "This should probably be treated as an empty rect?");

					// if we're ignoring animations and the tile is not in view then skip it
					// we don't want to consider the transformed rect because it may be in 
					// view right now but animating out of view
					if (tileClipRect.IsEmpty)
						continue;

					tileRect = new Rect(child.RenderSize);
				}
				else
				{
					transform = rp.TransformToAncestor(topLevelPanel);

					// get the rp's rect in the toplevelpanel coordinates
					if (transform != null)
						rectinTopLevelPanelCoordinates = new Rect(transform.Transform(new Point(0, 0)), new Size(rp.ActualWidth, rp.ActualHeight));
					else
						rectinTopLevelPanelCoordinates = new Rect(rp.TranslatePoint(new Point(0, 0), topLevelPanel), new Size(rp.ActualWidth, rp.ActualHeight));

					// if they don't intersect then bypass the rp
					if (!rectinTopLevelPanelCoordinates.IntersectsWith(topLevelPanelRect))
						continue;
				}

				bool allParentsAreVisible = true;

				DependencyObject rpParent = VisualTreeHelper.GetParent(rp);

				// walk up the parent chain making sure all ancestors up to this panel
				// are visible and not transparent
				while (allParentsAreVisible == true && rpParent != null && rpParent != parentPanel)
				{
					FrameworkElement fe = rpParent as FrameworkElement;

					if (fe != null && (fe.Visibility != Visibility.Visible || fe.Opacity < .0001))
						allParentsAreVisible = false;
					else
						rpParent = VisualTreeHelper.GetParent(rpParent);
				}

				if (allParentsAreVisible)
				{
					bool addToRecordPresentersList = rp.ShouldDisplayRecordContent && rp.Record.OccupiesScrollPosition;

					// JJD 3/21/07 
					// Added logic to bypass fixed records
					if (excludeFixedRootRecords == true &&
						addToRecordPresentersList == true)
					{
						if (rp.Record.IsFixed)
							addToRecordPresentersList = false;
					}

					// JJD 3/14/07 
					// Added logic to bypass records that weren't completely in view in one or both dimensions
					if ( addToRecordPresentersList == true )
					{
						FrameworkElement contentSite = rp.GetRecordContentSite();

						if (contentSite != null)
						{
							// AS 2/26/10 TFS28159
							// If we have a tile rect then we want to check whether the container is in view 
							// and not the record within the card since the card could be fully in view but 
							// the record could be scrolled within the card. Otherwise perform the logic 
							// we used to based on where the record content is within the panel.
							//
							if (!tileRect.IsEmpty)
							{
								if (onlyFullyInViewInXDimension == true && !GridUtilities.AreClose(tileRect.Width, tileClipRect.Width))
								{
									addToRecordPresentersList = false;
								}

								if (onlyFullyInViewInYDimension == true && !GridUtilities.AreClose(tileRect.Height, tileClipRect.Height))
								{
									addToRecordPresentersList = false;
								}
							}
							else
							{
								transform = contentSite.TransformToAncestor(topLevelPanel);

								// get the contentSite's rect in the toplevelpanel coordinates
								if (transform != null)
									rectinTopLevelPanelCoordinates = new Rect(transform.Transform(new Point(0, 0)), new Size(contentSite.ActualWidth, contentSite.ActualHeight));
								else
									rectinTopLevelPanelCoordinates = new Rect(contentSite.TranslatePoint(new Point(0, 0), topLevelPanel), new Size(contentSite.ActualWidth, contentSite.ActualHeight));

								if (onlyFullyInViewInXDimension == true)
								{
									if (rectinTopLevelPanelCoordinates.Left < topLevelPanelRect.Left ||
										 rectinTopLevelPanelCoordinates.Right > topLevelPanelRect.Right)
										addToRecordPresentersList = false;
									else
									{
										// JJD 11/16/11 - TFS58104
										// Check to see if we are clipping the rp in this dimension such
										// that its content isn't completely in view. If that is the
										// case then don't return the rp since it isn't fully in view.
										RectangleGeometry clip = rp.InternalClip as RectangleGeometry;

										if (clip != null && clip.Bounds.Width < rectinTopLevelPanelCoordinates.Width)
											addToRecordPresentersList = false;
									}
								}

								if (onlyFullyInViewInYDimension == true)
								{
									if (rectinTopLevelPanelCoordinates.Top < topLevelPanelRect.Top ||
										 rectinTopLevelPanelCoordinates.Bottom > topLevelPanelRect.Bottom)
										addToRecordPresentersList = false;
									else
									{
										// JJD 11/16/11 - TFS58104
										// Check to see if we are clipping the rp in this dimension such
										// that its content isn't completely in view. If that is the
										// case then don't return the rp since it isn't fully in view.
										RectangleGeometry clip = rp.InternalClip as RectangleGeometry;

										if (clip != null && clip.Bounds.Height < rectinTopLevelPanelCoordinates.Height)
											addToRecordPresentersList = false;
									}

								}
							}
						}
					}

					// add the rp to the passed in list if its content is displayed
					if (addToRecordPresentersList == true)
						recordPresenters.Add(rp);

					// if the record is expanded and the recursive flag is true then call this method recurively

                    // JJD 8/7/09  NA 2009 Vol 2 - Enhanced grid view
                    // With flat view we don't need to drill down recursively
                    //if (recursive && rp.IsExpanded)
					if (recursive && isFlatView == false && rp.IsExpanded)
					{
						// JJD 3/21/07 
						// Always pass false in for the 'excludeFixedRootRecords' param since fixed records in nested panels 
						// scroll with their islands
						this.GetRecordPresentersInViewHelper(rp, topLevelPanel, recordPresenters, recursive, onlyFullyInViewInXDimension, onlyFullyInViewInYDimension, false, restrictToRecordType, ignoreAnimations );
					}
				}
			}
		}

		#endregion //GetRecordsInView

		#region HasRegisteredFieldChoosers

		// SSP 7/2/09 - NAS9.2 Field Chooser
		// 
		/// <summary>
		/// Returns true if there are any registered enumerables.
		/// </summary>
		/// <returns>True if there at least one registered enumerable. False otherwise.</returns>
		internal bool HasRegisteredFieldChoosers( )
		{
			return null != _registeredFieldChoosers
				// SSP 6/28/10 TFS23257
				// Renamed the existing GetCount to GetCountNonOptimized and added the new GetCount
				// to alleviate some confusion.
				// 
				//&& GridUtilities.GetCount( _registeredFieldChoosers ) > 0;
				&& GridUtilities.GetCountNonOptimized( _registeredFieldChoosers ) > 0;
		}

		#endregion // HasRegisteredFieldChoosers

		#region Print

		//#if !EXPRESS
//        /// <summary>
//        /// Prints the contents of a <see cref="DataPresenterBase"/> derived control.
//        /// </summary>
//        /// <param name="reportSettings">The settings to use when printing the control.</param>
//        /// <returns>True if report runs to completion, false if it is canceled or an error occurs.</returns>
//        public bool Print(DataPresenterReportSettings reportSettings)
//        {
//            //TODO: implement Print in DataPresenterBase
//            throw new NotImplementedException("Feature not yet implemented.");
//        }
//#endif

		#endregion //Print	
    
		// JM 08-04-08 Load/Save Customizations
		#region LoadCustomizations

		/// <summary>
		/// Loads user Customizations that were saved with the <see cref="SaveCustomizations(Stream)"/> method.
		/// </summary>
		/// <param name="stream">The stream containing the saved Customizations.</param>
		public void LoadCustomizations(Stream stream)
		{
			this.CustomizationsManager.LoadCustomizations(stream);
		}

		/// <summary>
		/// Loads user Customizations that were saved with the <see cref="SaveCustomizations()"/> method.
		/// </summary>
		/// <param name="Customizations">The string containing the saved Customizations</param>
		public void LoadCustomizations(string Customizations)
		{
			this.CustomizationsManager.LoadCustomizations(Customizations);
		}

		#endregion //LoadCustomizations

		#region RegisterFieldChooser

		// SSP 6/24/09 - NAS9.2 Field Chooser
		// 
		internal void RegisterFieldChooser( FieldChooser fieldChooser )
		{
			WeakList<FieldChooser> list = _registeredFieldChoosers;

			if ( null == list )
				_registeredFieldChoosers = list = new WeakList<FieldChooser>( );

			if ( ! list.Contains( fieldChooser ) )
				list.Add( fieldChooser );
		}

		#endregion // RegisterFieldChooser

		// JM 08-04-08 Load/Save Customizations
		#region SaveCustomizations
		/// <summary>
		/// Saves information about the current user customizations to the specified stream.
		/// </summary>
		/// <param name="stream">The stream to which the Customizations should be saved.</param>
		public void SaveCustomizations(Stream stream)
		{
			this.CustomizationsManager.SaveCustomizations(stream);
		}

		/// <summary>
		/// Saves information about the current user customizations and returns that as a string.
		/// </summary>
		///	<returns>A string that contains the Customizations information.</returns>
		public string SaveCustomizations()
		{
			return this.CustomizationsManager.SaveCustomizations();
		}
		#endregion //SaveCustomizations

		#region ShowFieldChooser

		// SSP 6/18/09 - NAS9.2 Field Chooser
		// 

		/// <summary>
		/// Displays a FieldChooser that allows the user to select which fields are displayed in the data presenter.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>ShowFieldChooser</b> displays a <see cref="FieldChooser"/> that allows the user to 
		/// select which fields are displayed in the data presenter. The FieldChooser control will 
		/// be displayed using a <see cref="ToolWindow"/>.
		/// </para>
		/// <para class="body">
		/// You can control aspects of the FieldChooser by hooking into <see cref="FieldChooserOpening"/>
		/// event. The associated event args provides the instance of the FieldChooser that will be displayed
		/// as well as the ToolWindow that will be used to display it.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldChooser"/>
		/// <seealso cref="FieldChooserOpening"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public void ShowFieldChooser( )
		{
			this.ShowFieldChooserHelper( null, true, true, null );
		}

		/// <summary>
		/// Displays a FieldChooser that allows the user to select which fields are displayed in 
		/// the data presenter.
		/// </summary>
		/// <param name="fieldLayout">Field layout for which the FieldChooser will be displayed. Can be null
		/// in which case the root field layout will be pre-selected and the user will be allowed to
		/// select a different field layout.
		/// </param>
		/// <param name="allowFieldLayoutSelection">
		/// Specifies whether the user will be allowed to change the field layout and select fields 
		/// of a different field layout.
		/// </param>
		/// <remarks>
		/// <para class="body">
		/// <b>ShowFieldChooser</b> displays a <see cref="FieldChooser"/> that allows the user to 
		/// select which fields of the specified field layout are displayed in the data presenter. 
		/// The FieldChooser control will be displayed using a <see cref="ToolWindow"/>.
		/// </para>
		/// <para class="body">
		/// You can control aspects of the FieldChooser by hooking into <see cref="FieldChooserOpening"/>
		/// event. The associated event args provides the instance of the FieldChooser that will be displayed
		/// as well as the ToolWindow that will be used to display it.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that if the <i>fieldLayout</i> parameter is specified, the fields of that
		/// field layout will be displayed in the FieldChooser. Otherwise the root field layout's fields
		/// will be displayed. The <i>AllowFieldLayoutSelection</i> parameter specifies
		/// whether the the user will be allowed to change the field layout and select fields of other 
		/// field layouts. FieldChooser's <see cref="FieldChooser.FieldGroupSelectorVisibility"/> property
		/// will be initialized based on that parameter.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldChooser"/>
		/// <seealso cref="FieldChooserOpening"/>
		/// <seealso cref="FieldChooser.FieldGroupSelectorVisibility"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public void ShowFieldChooser( FieldLayout fieldLayout, bool allowFieldLayoutSelection )
		{
			this.ShowFieldChooserHelper( fieldLayout, allowFieldLayoutSelection, true, null );
		}


		/// <summary>
		/// Displays a FieldChooser that allows the user to select which fields are displayed in 
		/// the data presenter.
		/// </summary>
		/// <param name="fieldLayout">Field layout for which the FieldChooser will be displayed. Can be null
		/// in which case the root field layout will be pre-selected and the user will be allowed to
		/// select a different field layout.
		/// </param>
		/// <param name="allowFieldLayoutSelection">
		/// Specifies whether the user will be allowed to change the field layout and select fields 
		/// of a different field layout.
		/// </param>
		/// <param name="retainFieldChooser">
		/// Specifies whether the data presenter should retain the FieldChooser that's displayed 
		/// so that it can reuse it the next time this method is called instead of having to create
		/// a new one. This also retains the state of the FieldChooser.
		/// </param>
		/// <remarks>
		/// <para class="body">
		/// <b>ShowFieldChooser</b> displays a <see cref="FieldChooser"/> that allows the user to 
		/// select which fields of the specified field layout are displayed in the data presenter. 
		/// The FieldChooser control will be displayed using a <see cref="ToolWindow"/>.
		/// </para>
		/// <para class="body">
		/// You can control aspects of the FieldChooser by hooking into <see cref="FieldChooserOpening"/>
		/// event. The associated event args provides the instance of the FieldChooser that will be displayed
		/// as well as the ToolWindow that will be used to display it.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that if the <i>fieldLayout</i> parameter is specified, the fields of that
		/// field layout will be displayed in the FieldChooser. Otherwise the root field layout's fields
		/// will be displayed. The <i>AllowFieldLayoutSelection</i> parameter specifies
		/// whether the the user will be allowed to change the field layout and select fields of other 
		/// field layouts. FieldChooser's <see cref="FieldChooser.FieldGroupSelectorVisibility"/> property
		/// will be initialized based on that parameter.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldChooser"/>
		/// <seealso cref="FieldChooserOpening"/>
		/// <seealso cref="FieldChooser.FieldGroupSelectorVisibility"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public void ShowFieldChooser( FieldLayout fieldLayout, bool allowFieldLayoutSelection,
			bool retainFieldChooser )
		{
			this.ShowFieldChooserHelper( fieldLayout, allowFieldLayoutSelection, retainFieldChooser, null );
		}

		/// <summary>
		/// Displays a FieldChooser that allows the user to select which fields are displayed in 
		/// the data presenter.
		/// </summary>
		/// <param name="fieldLayout">Field layout for which the FieldChooser will be displayed. Can be null
		/// in which case the root field layout will be pre-selected and the user will be allowed to
		/// select a different field layout.
		/// </param>
		/// <param name="allowFieldLayoutSelection">
		/// Specifies whether the user will be allowed to change the field layout and select fields 
		/// of a different field layout.
		/// </param>
		/// <param name="retainFieldChooser">
		/// Specifies whether the data presenter should retain the FieldChooser that's displayed 
		/// so that it can reuse it the next time this method is called instead of having to create
		/// a new one. This also retains the state of the FieldChooser.
		/// </param>
		/// <param name="windowCaption">
		/// Specifies the caption of the window in which the FieldChooser is displayed. If null
		/// is specified the default caption is used. Specify empty string to not display any caption.
		/// </param>
		/// <remarks>
		/// <para class="body">
		/// <b>ShowFieldChooser</b> displays a <see cref="FieldChooser"/> that allows the user to 
		/// select which fields of the specified field layout are displayed in the data presenter. 
		/// The FieldChooser control will be displayed using a <see cref="ToolWindow"/>.
		/// </para>
		/// <para class="body">
		/// You can control aspects of the FieldChooser by hooking into <see cref="FieldChooserOpening"/>
		/// event. The associated event args provides the instance of the FieldChooser that will be displayed
		/// as well as the ToolWindow that will be used to display it.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that if the <i>fieldLayout</i> parameter is specified, the fields of that
		/// field layout will be displayed in the FieldChooser. Otherwise the root field layout's fields
		/// will be displayed. The <i>AllowFieldLayoutSelection</i> parameter specifies
		/// whether the the user will be allowed to change the field layout and select fields of other 
		/// field layouts. FieldChooser's <see cref="FieldChooser.FieldGroupSelectorVisibility"/> property
		/// will be initialized based on that parameter.
		/// </para>
		/// </remarks>
		/// <seealso cref="FieldChooser"/>
		/// <seealso cref="FieldChooserOpening"/>
		/// <seealso cref="FieldChooser.FieldGroupSelectorVisibility"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public void ShowFieldChooser( FieldLayout fieldLayout, bool allowFieldLayoutSelection,
			bool retainFieldChooser, string windowCaption )
		{
			this.ShowFieldChooserHelper( fieldLayout, allowFieldLayoutSelection, retainFieldChooser, windowCaption );
		}

		private void ShowFieldChooserHelper( FieldLayout fieldLayout, bool allowFieldLayoutSelection,
			bool retainFieldChooser, string windowCaption )
		{
			ToolWindow toolWindow;
			bool reusedFlag;

			if ( null != _retainedFieldChooserWindow )
			{
				toolWindow = _retainedFieldChooserWindow;
				reusedFlag = true;
			}
			else
			{
				reusedFlag = false;
				toolWindow = new ToolWindow( );
				toolWindow.AllowClose = true;
				// SSP 8/25/09 TFS20375
				// Resizer grip overlaps the contents so don't show it.
				// 
				//toolWindow.ResizeMode = ResizeMode.CanResizeWithGrip;
				toolWindow.ResizeMode = ResizeMode.CanResize;
			}

			if ( retainFieldChooser )
				_retainedFieldChooserWindow = toolWindow;

			if ( null != windowCaption )
			{
				toolWindow.Title = windowCaption;
			}
			else
			{
				DynamicResourceString title = Infragistics.Windows.DataPresenter.Resources.GetDynamicResourceString( "FieldChooser_Title", null, null );
				toolWindow.SetBinding( ToolWindow.TitleProperty, Utilities.CreateBindingObject( "Value", BindingMode.OneWay, title ) );
			}

			if ( ! reusedFlag )
			{
				toolWindow.Width = 200;
				toolWindow.Height = 300;
			}

			FieldChooser fieldChooser = toolWindow.Content as FieldChooser;
			Debug.Assert( ! reusedFlag || null != fieldChooser );
			
			if ( null == fieldChooser )
			{
				fieldChooser = new FieldChooser( );
				toolWindow.Content = fieldChooser;
				fieldChooser.DataPresenter = this;
			}

			fieldChooser.FieldGroupSelectorVisibility = allowFieldLayoutSelection ? (Visibility?)null : Visibility.Collapsed;

			FieldChooserGroup currentGroup = fieldChooser.CurrentFieldGroup;
			if ( null != fieldLayout && fieldLayout != currentGroup.FieldLayout )
				fieldChooser.CurrentFieldGroup = new FieldChooserGroup( fieldLayout, null );

			FieldChooserOpeningEventArgs eventArgs = new FieldChooserOpeningEventArgs( toolWindow, fieldChooser );
			this.RaiseFieldChooserOpening( eventArgs );
			if ( ! eventArgs.Cancel )
			{
				if ( ! toolWindow.IsVisible )
					toolWindow.Show( this );
				else
					toolWindow.Activate( );
			}
		}

		#endregion // ShowFieldChooser

		#region UnregisterFieldChooser

		// SSP 6/24/09 - NAS9.2 Field Chooser
		// 
		internal void UnregisterFieldChooser( FieldChooser fieldChooser )
		{
			WeakList<FieldChooser> list = _registeredFieldChoosers;

			if ( null != list )
				list.Remove( fieldChooser );
		}

		#endregion // UnregisterFieldChooser

		#endregion //Public Methods

		#region Internal Methods

		// AS 3/17/11 NA 2011.1 - Async Exporting
		#region AddStatusControl
		internal void AddStatusControl(RecordExportStatusControl ctrl)
		{
			// don't do anything with it until the template is applied
			if (ctrl != null && _dataAreaGrid != null)
			{
				Debug.Assert(VisualTreeHelper.GetParent(ctrl) == null, "Status already parented?");

				if (VisualTreeHelper.GetParent(ctrl) == null)
					_dataAreaGrid.Children.Add(ctrl);
			}
		}
		#endregion //AddStatusControl

		#region BringFieldIntoView
		// JJD 7/14/09 - TFS18784 - added
		internal void BringFieldIntoView(Field field)
		{
			// JJD 7/14/09 - TFS18784 
			// check bypass flag
			if (this._bypassScrollIntoView)
				return;

			Record[] inViewRecords = this.GetRecordsInView(true);
			FieldLayout fieldLayout = field.Owner;

			foreach (Record rcd in inViewRecords)
			{
				// JJD 10/26/11 - TFS91364 
				// Bypass HeaderReords 
				if (rcd is HeaderRecord)
					continue;

				if (rcd is DataRecord && rcd.FieldLayout == fieldLayout)
				{
					IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;
					if (panelNavigator != null)
						panelNavigator.EnsureCellIsVisible(((DataRecord)rcd).Cells[field]);

					break;
				}
			}
		} 
		#endregion //BringFieldIntoView

		// JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
        #region BumpGroupByAreaStyleVersion

        internal void BumpGroupByAreaStyleVersion()
        {
            GroupByAreaBase gba = this.GetGroupByAreaResolved(false);

            if (gba != null)
                gba.StyleVersionNumber++;
        }

        #endregion //BumpGroupByAreaStyleVersion	
    
        #region BumpOverallSortVersion

        // JJD 2/19/09 - TFS13979
        // Maintain an overall sort version that gets bumped whenever
        // a sorting change is made on any field layout
        internal void BumpOverallSortVersion()
        {
			// JM 04/09 CrossBandGrouping feature
			//this._overallSortVersion++;
			this.OverallSortVersion++;
        }

        #endregion //BumpOverallSortVersion	
    
		#region BumpRecordsInViewVersion

		internal void BumpRecordsInViewVersion()
		{
			// bump the records ion view version
			int version = this.RecordsInViewVersion;

			if (version == int.MaxValue)
				version = 1;
			else
				version++;

			this.SetValue(RecordsInViewVersionPropertyKey, version);

			// SSP 2/2/10
			// Added CellsInViewChanged event to the DataPresenterBase.
			// 
			this.RaiseCellsInViewChangedAsyncHelper( );
		}

		#endregion //BumpRecordsInViewVersion

		#region BumpScrollableRecordCountVersion

		internal void BumpScrollableRecordCountVersion()
		{
			// JJD 10/18/10 - TFS30715
			// Clear the pending operation member
			this._bumpScrollCountOperation = null;

			// JM 09-26-07 BR26775
			//this._scrollableRowCountVersion++;
			this.ScrollableRecordCountVersion++;

			
		}

		#endregion //BumpScrollableRecordCountVersion

		#region BumpSortVersion

		internal void BumpSortVersion()
		{
			if (this._fieldLayouts == null || this._fieldLayouts.Count < 1)
				return;

			foreach (FieldLayout fl in this.FieldLayouts)
			{
				fl.BumpSortVersion();
			}
		}

		#endregion //BumpSortVersion

		#region CalculateNewSelection



#region Infragistics Source Cleanup (Region)







#endregion // Infragistics Source Cleanup (Region)

		internal SelectedItemHolder CalculateNewSelection(ISelectableItem item,
			bool clearExistingSelection,
			bool select)
		{
			// get the selected items and add/or remove specified item
			SelectedItemHolder selected = new SelectedItemHolder(this);

			if (!clearExistingSelection)
			{
				// copy existing selected items

				// if its a record, don't copy cells collection (mutually exclusive)
				if (!(item is Record) && this.SelectedItems.Cells.Count > 0)
					selected.Cells.InternalAddRange(this.SelectedItems.Cells);

				// if its a cell, don't copy records collection (mutually exclusive)
				if (!(item is Cell) && this.SelectedItems.Records.Count > 0)
					selected.Records.InternalAddRange(this.SelectedItems.Records);

				if (this.SelectedItems.Fields.Count > 0)
					selected.Fields.InternalAddRange(this.SelectedItems.Fields);
			}
			else
			// if we are clearing the existing selection, we must still check 
			// for the special case of control key being down
			{
				bool ctlKeyDown = (Keyboard.Modifiers & ModifierKeys.Control) == ModifierKeys.Control;

				// check for the ctl key and that the item is either a Cell or a Row				
				if (ctlKeyDown && (item is Cell || item is Record))
				{
					// since the columns selection does not change with the control 
					// key down, add it to the selection
					if (this.SelectedItems.Fields.Count > 0)
					{
						selected.SetFields(this.SelectedItems.Fields);
					}
				}

				// check for the ctl key and that the item is either a Field
				if (ctlKeyDown && (item.GetType() == typeof(Field)))
				{
					// since the cells and rows selection does not change with the control 
					// key down, add them to the selection
					if (this.SelectedItems.Cells.Count > 0)
					{
						selected.SetCells(this.SelectedItems.Cells);
					}

					if (this.SelectedItems.Records.Count > 0)
					{
						selected.SetRecords(this.SelectedItems.Records);
					}
				}
			}

			if (select)
				this.AddToSelectedCollection(selected, item);
			else
				this.RemoveFromSelectedCollection(selected, item);

			// Make sure the number of selected items doesn't exceed the max.
			//
			if (null != item && select)
				this.EnsureItemsWithinMaxSelectedItemsBounds(item, selected);

			// return the newly created Selected object
			return selected;
		}

		#endregion //CalculateNewSelection

		#region CalculateNewSelectionRange



#region Infragistics Source Cleanup (Region)







#endregion // Infragistics Source Cleanup (Region)

		internal SelectedItemHolder CalculateNewSelectionRange(ISelectableItem item,
			bool clearExistingSelection,
			bool select)
		{
			// get the selected items and add/or remove specified item
			// have each item calculate its new range
			SelectedItemHolder newSelection = new SelectedItemHolder(this);

			if (item is Record)
				this.CalculateSelectionRange(item as Record, newSelection, clearExistingSelection, select);
			else
				if (item is Cell)
					this.CalculateSelectionRange(item as Cell, newSelection, clearExistingSelection, select);
				else
					if (item is Field)
						this.CalculateSelectionRange(item as Field, newSelection, clearExistingSelection, select);

			// Call EnsureItemsWithingMaxSelectedItemsBounds method to ensure that we
			// don't exceed the max selected item settings.
			//
			this.EnsureItemsWithinMaxSelectedItemsBounds(item, newSelection);

			return newSelection;
		}

		#endregion //CalculateNewSelectionRange

		#region ClearActiveCell







		internal bool ClearActiveCell()
		{
			return this.ClearActiveCell(false, false);
		}
		internal bool ClearActiveCell(bool shutdown)
		{
			return this.ClearActiveCell(shutdown, false);
		}

		internal bool ClearActiveCell(bool shutdown, bool calledFromSetActiveCell)
		{
			if (this._activeCell == null)
				return true;

			if (!shutdown)
			{
				if (this._activeCell.IsInEditMode)
				{
					// exit edit mode from the existing cell 
					//
					this._activeCell.EndEditMode();

					if (null != this._activeCell && this._activeCell.IsInEditMode)
						return false;
				}

				Debug.Assert(null == this.EditHelper.CellValuePresenter);

				// We don't want to attempt to exit the edit mode twice on the cell.
				// 
				//if (this._cellValuePresenterInEditMode != null)
				//{
				//    Debug.Assert(this._cellValuePresenterInEditMode.Cell == this._activeCell);

				//    this._cellValuePresenterInEditMode.EndEditMode(true, false);

				//    if (this._cellValuePresenterInEditMode != null)
				//        return false;
				//}

				// Raise the CellDeactivating event. 
				//
				CellDeactivatingEventArgs deactivatingEventArgs = new CellDeactivatingEventArgs(this._activeCell);
				this.RaiseCellDeactivating(deactivatingEventArgs);

				// if the cancel flag was set then bail
				if (deactivatingEventArgs.Cancel)
					return false;

				// If the form was unloaded in the event above then return false
				// to cancel
				//
				if (this._activeCell == null)
					return false;

			}

			Cell tmpCell = this._activeCell;

			// Finally clear the activeCell reference
			//
			try
			{
				// set an anti-recursion flag
				this._clearingActiveCell = true;

				if (calledFromSetActiveCell)
					this._activeCell = null;
				else
					this.ActiveCell = null;
			}
			finally
			{
				// clear the anti-recursion flag
				this._clearingActiveCell = false;

				// JM 08-01-07 BR25314
				if (shutdown)
					// AS 7/27/09 NA 2009.2 Field Sizing
					//this._cellValuePresenterInEditMode = null;
					this.EditHelper.ClearCellValuePresenter();
			}

			// Let the cell know that it is no longer the active cell
			//
			if (!calledFromSetActiveCell)
				tmpCell.OnActiveCellChanged();

			return true;
		}

		#endregion //ClearActiveCell

		#region ClearActiveRecord

		/// <summary>
		///  Clears the active record without firing any events
		/// </summary>
		internal void ClearActiveRecord()
		{
			// JM 08-01-07 BR25314
			//this.ActiveCell = null;
			//this.ActiveRecord = null;
			this.ClearActiveRecord(false);
		}

		// JM 08-01-07 BR25314
		internal void ClearActiveRecord(bool force)
		{
			this._forceClearActiveRecord	= force;

			try
			{
				this.ActiveCell = null;
				this.ActiveRecord = null;
			}
			finally { this._forceClearActiveRecord = false; }
		}

		#endregion //ClearActiveRecord

		#region ClearAllSelected







		internal bool ClearAllSelected()
		{
			System.Type typeCleared = null;

			// Get the type of the selection that is being cleared to
			// pass into SelectNewSelection which fires the events
			//
			if (this.SelectedItems.Cells != null && this.SelectedItems.Cells.Count > 0)
				typeCleared = this.SelectedItems.Cells[0].GetType();
			else
				if (this.SelectedItems.Records != null && this.SelectedItems.Records.Count > 0)
					typeCleared = this.SelectedItems.Records[0].GetType();
				else
					if (this.SelectedItems.Fields != null && this.SelectedItems.Fields.Count > 0)
						typeCleared = this.SelectedItems.Fields[0].GetType();
					else
					{
						// if there is nothing selected then just return true
						return true;
					}

			SelectedItemHolder selected = new SelectedItemHolder(this);

			bool cancel = !SelectNewSelection(typeCleared, selected);

			if (cancel)
				return false;

			// clear pivotitem
			// AS 4/12/11 TFS62951
			this.SetPivotMember(ref _pivotRecord, null); //this._pivotRecord = null;
			this.SetPivotMember(ref _pivotField, null); //this._pivotCell = null;
			this.SetPivotMember(ref _pivotCell, null); //this._pivotField = null;

			return true;
		}

		#endregion //ClearAllSelected

        // JJD 11/11/09 - TFS24665 - added
        #region ClearPendingActiveRecordPresenter

        internal void ClearPendingActiveRecordPresenter()
        {
            if (this._pendingActiveRecordPresenter != null)
            {
                this._pendingActiveRecordPresenter.ClearContainerForItem(this._pendingActiveRecordPresenter.Record);
                this._pendingActiveRecordPresenter = null;
            }
        }

        #endregion //ClearPendingActiveRecordPresenter	
    
		#region ClearSelectedItemsOfType

		internal bool ClearSelectedItemsOfType(ISelectableItem item)
		{
			if (item is Cell)
				return this.ClearSelectedCells();

			if (item is Field)
				return this.ClearSelectedFields();

			if (item is Record)
				return this.ClearSelectedRecords();

			Debug.Fail("item not Cell, Field or Record in DataPresenterBase.ClearSelectedItemsOfType");

			return false;
		}

		#endregion //ClearSelectedItemsOfType

		#region ClearGroupBy

		internal void ClearGroupBy()
		{
			if (this.DefaultFieldLayout == null)
				return;

            if (this.DefaultFieldLayout.HasGroupBySortFields)
            {
                this.DefaultFieldLayout.SortedFields.Clear();
                this.OnProcessSortCriteria(this.DefaultFieldLayout);
            }
		}

		#endregion //ClearGroupBy

		#region ClearItemsHost

		internal void ClearItemsHost()
		{
			if (this._currentRecordListControl != null)
				DataPresenterBase.SetPanelSettings(this._currentRecordListControl, null);
			//this._itemsHost = null;
			//this._isHeaderInitialized = false;
		}

		#endregion //ClearItemsHost

		#region ClearSelectedCells



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

		internal bool ClearSelectedCells()
		{
			if (this.SelectedItems.Cells != null && this.SelectedItems.Cells.Count > 0)
			{
				SelectedItemHolder selected = new SelectedItemHolder(this);

				bool cancel = !SelectNewSelection(typeof(Cell), selected);

				if (cancel)
					return false;

				// clear pivotitem
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotRecord, null); //this._pivotRecord = null;
				this.SetPivotMember(ref _pivotCell, null); //this._pivotCell = null;
			}

			return true;
		}

		#endregion //ClearSelectedCells

		#region ClearSelectedFields

		internal bool ClearSelectedFields()
		{
			if (this.SelectedItems.Fields != null && this.SelectedItems.Fields.Count > 0)
			{
				SelectedItemHolder selected = new SelectedItemHolder(this);

				bool cancel = !SelectNewSelection(typeof(Field), selected);

				if (cancel)
					return false;

				// clear pivotitem
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotField, null); //this._pivotField = null;
			}

			return true;
		}

		#endregion //ClearSelectedFields

		#region ClearSelectedRecords



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

		internal bool ClearSelectedRecords()
		{
			if (this.SelectedItems.Records != null && this.SelectedItems.Records.Count > 0)
			{
				SelectedItemHolder selected = new SelectedItemHolder(this);

				bool cancel = !SelectNewSelection(typeof(Record), selected);

				if (cancel)
					return false;

				// clear pivotitem
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotRecord, null); //this._pivotRecord = null;
			}

			return true;
		}

		#endregion //ClearSelectedRecords

		#region ClearStyleCache

		internal void ClearStyleCache()
		{
			



		}

		#endregion //ClearStyleCache

		// AS 5/7/09 NA 2009.2 ClipboardSupport
		// Refactored the DeleteSelectedRecords method.
		//
		#region DeleteRecords
		/// <summary>
		/// Deletes the deletable data records in the specified list.
		/// </summary>
		/// <param name="recordList">The records to delete</param>
		/// <param name="displayPromptMessage">Determines the default state for whether the delete message prompt will be shown</param>
		/// <param name="addToUndo">Boolean indicating if the action should be added to the undo stack</param>
		/// <returns>True if the deletion was attempted. otherwise false if cancelled.</returns>
		internal bool DeleteRecords(IList<Record> recordList, bool displayPromptMessage, bool addToUndo)
		{
			if (addToUndo && this.IsUndoEnabled)
			{
				DeleteRecordsAction action = new DeleteRecordsAction(this, recordList, displayPromptMessage);
				return this.History.PerformAction(action, null);
			}
			else
			{
				UndeleteRecordsAction undoAction;
				int deletionCount;
				return this.DeleteRecords(recordList, displayPromptMessage, false, out undoAction, out deletionCount);
			}
		}

		internal bool DeleteRecords(IList<Record> recordList, bool displayPromptMessage, bool createUndoAction, out UndeleteRecordsAction undoAction, out int deletionCount)
		{
			undoAction = null;
			deletionCount = 0;

			Debug.Assert(null != recordList);
			if (null == recordList)
				return false;

			// JJD 2/20/07 - BR19932
			// filter out records that are not elibible for deletion
			// create a list to hold all the selected records that are eligible for deletion
			List<DataRecord> recordsToDelete = new List<DataRecord>();

			foreach (Record record in recordList)
			{
				Debug.Assert(record is DataRecord || record.CanDelete == false);

				DataRecord dataRecord = record as DataRecord;

				if (null != dataRecord && dataRecord.CanDelete)
					recordsToDelete.Add(dataRecord);
			}

			if (recordsToDelete.Count == 0)
				return false;

			DataRecord[] records = recordsToDelete.ToArray();

			RecordsDeletingEventArgs args = new RecordsDeletingEventArgs(records, displayPromptMessage);

			// raise the RecordsDeleting event
			this.RaiseRecordsDeleting(args);

			// if cancelled just return
			if (args.Cancel == true)
				return false;

			if (args.DisplayPromptMessage)
			{
				MessageBoxResult result;
				string msgString;

				string captionString;

				// Use plural if more than 1 row.
				//
				if (args.Records.Count > 1)
				{
					msgString = DataPresenterBase.GetString("DeleteMultipleRecordsPrompt", records.Length);
					captionString = DataPresenterBase.GetString("DeleteRecordsMessageTitle");
				}
				else
				{
					msgString = DataPresenterBase.GetString("DeleteSingleRecordPrompt");
					captionString = DataPresenterBase.GetString("DeleteSingleRecordMessageTitle");
				}

				// display the prompt message to the user
				// AS 10/23/08 TFS9546
				//result = MessageBox.Show(
				result = Utilities.ShowMessageBox(this,
					msgString,
					captionString,
					MessageBoxButton.YesNo,
					MessageBoxImage.Question);

				// if the user clicked the no button then return
				if (result != MessageBoxResult.Yes)
					return false;
			}

			// AS 5/13/09 NA 2009.2 Undo/Redo
			UndeleteRecordsStrategy strategy = args.UndeleteStrategy;
			UndeleteRecordsStrategy.RecordInfo[] tempOldRecords = null;
			List<UndeleteRecordsStrategy.RecordInfo> oldRecords = null;
			DescendantRecordInfo descendantInfo = null;

			// if we have a strategy that we can use to undo the deletion and this 
			// operation should result in an undo action then create a snapshot
			// of the record information before the delete
			if (null != strategy && createUndoAction)
			{
				oldRecords = new List<UndeleteRecordsStrategy.RecordInfo>();
				int recordsWithChildren = 0;
				tempOldRecords = new UndeleteRecordsStrategy.RecordInfo[records.Length];

				// cache the record info in the same order we will process them
				for (int i = records.Length - 1; i >= 0; i--)
				{
					DataRecord record = records[i];

					UndeleteRecordsStrategy.RecordInfo recordInfo = UndeleteRecordsStrategy.RecordInfo.Create(record);
					tempOldRecords[i] = recordInfo;

					if (record.HasChildren)
						recordsWithChildren++;
				}

				// if undo actions for descendant records are to be maintained...
				if (recordsWithChildren > 0 && strategy.RestoreDescendantActions)
				{
					// build a tree of the descendants from the undo history
					descendantInfo = this.History.CreateUndeleteDescendantInfo(records);

					// then store the children recordinfos in the record infos
					for (int i = 0; i < records.Length; i++)
					{
						UndeleteRecordsStrategy.RecordInfo recordInfo = tempOldRecords[i];
						
						if (null != recordInfo)
							recordInfo.AddChildren(records[i], descendantInfo);
					}
				}
			}

			RecordManager activeRecordManager = null;
			int activeRecordSortedIndex = -1;


			Record activeRecord = this.ActiveRecord;

			for (int i = records.Length - 1; i >= 0; i--)
			{
				DataRecord record = records[i];
				try
				{
					int sortedIndex = -1;

					// AS 5/18/09 NA 2009.2 Undo/Redo
					// This doesn't happen usually but in the case of undo/redo it can.
					// If the record being deleted is an ancestor of the active record then 
					// we want to activate the sibling record.
					//
					//if (record.IsActive)
					if (record.IsActive || (null != activeRecord && record.IsAncestorOf(activeRecord)))
					{
						activeRecordManager = record.ParentCollection.ParentRecordManager;
						sortedIndex = record.SortIndex;
					}

					bool wasAddRecord = record.IsAddRecord;
					object oldDataItem = record.DataItem;

					record.DeleteHelper();

					// AS 5/13/09 NA 2009.2 Undo/Redo
					// keep track of how many records were actually deleted
					// JJD 11/18/11 - TFS79001 
					// Use the GridUtilities.AreEqual helper method instead
					//if (record.IsDeleted || (wasAddRecord && (record.IsAddRecordTemplate || record.DataItem != oldDataItem)))
					if (record.IsDeleted || (wasAddRecord && (record.IsAddRecordTemplate || false == GridUtilities.AreEqual( record.DataItem, oldDataItem))))
					{
						if (null != tempOldRecords && null != tempOldRecords[i])
							oldRecords.Add(tempOldRecords[i]);

						deletionCount++;
					}

					if (sortedIndex >= 0)
						activeRecordSortedIndex = sortedIndex;
				}
				catch (Exception e)
				{
					this.RaiseDataError(record, null, e, DataErrorOperation.RecordDelete,
						DataPresenterBase.GetString("DataErrorDeleteRecordUnableToDelete", e.Message));
				}
			}

			// AS 5/13/09 NA 2009.2 Undo/Redo
			// If there were items removed then create the undo action
			//
			if (null != oldRecords && oldRecords.Count > 0)
			{
				// since we deleted the records in reverse we should really undelete
				// then in the actual order so reverse the old records
				oldRecords.Reverse();

				undoAction = new UndeleteRecordsAction(this, oldRecords, strategy);
			}

			// clear the selection
			this.SelectedItems.Records.InternalClear();

			// reselect the next record at the sort index
			if (activeRecordManager != null)
				activeRecordManager.ReselectRecordAtSortedIndex(activeRecordSortedIndex);

			// raise the after event
			this.RaiseRecordsDeleted(new RecordsDeletedEventArgs());

			return true;
		}
		#endregion //DeleteRecords

		#region DeleteSelectedRecords

		internal bool DeleteSelectedRecords(bool displayPromptMessage)
		{
			if (this.SelectedItems.Records.Count == 0)
				return false;

			#region Refactored
			
#region Infragistics Source Cleanup (Region)





































































































#endregion // Infragistics Source Cleanup (Region)

			#endregion //Refactored
			return this.DeleteRecords(this.SelectedItems.Records.ToArray(), displayPromptMessage, true);
		}

		#endregion //DeleteSelectedRecords

		#region DirtyFieldChooserFields

		// SSP 8/31/09 TFS21539
		// 
		internal void DirtyFieldChooserFields( )
		{
			WeakList<FieldChooser> list = _registeredFieldChoosers;
			if ( null != list )
			{
				foreach ( FieldChooser fc in list )
				{
					if ( null != fc )
						fc.ReInitializeCurrentFields( );
				}
			}
		}

		#endregion // DirtyFieldChooserFields

		#region EndEditMode

		/// <summary>
		/// Ends edit mode. Returns true if succeeded or no cell was in edit mode to begin with.
		/// </summary>
		/// <param name="acceptChanges">If true then accept any changes made while in edit mode.</param>
		/// <param name="force">If true then ignore event cancellation.</param>
		/// <returns>True if the operation completed successfully</returns>
		internal bool EndEditMode(bool acceptChanges, bool force)
		{
			Cell cell = this.ActiveCell;

			if (cell != null && cell.IsInEditMode)
				return cell.EndEditMode(acceptChanges, force);

			return true;
		}

		#endregion //EndEditMode

		#region FindResourceForStylingPoint

		internal object FindResourceForStylingPoint(Type elementType, bool walkResourceChain)
		{

			if (this._themeRegistered_DP_ResourceSet != null &&
				this._themeRegistered_DP_ResourceSet.Contains(elementType))
			{
				object resource = this._themeRegistered_DP_ResourceSet[elementType];

				Debug.Assert(resource != null);

				if (resource != null || !walkResourceChain)
					return resource;
			}

			return this.FindResource(elementType);
		}

		#endregion //FindResourceForStylingPoint

		#region GetDefaultResource

		internal object GetDefaultResource(Type key, bool walkResourceChain)
		{
			if (this._themeRegistered_DP_ResourceSet != null)
				return this.FindResourceForStylingPoint(key, walkResourceChain);

			return GetGenericResource(key);
		}

		#endregion //GetDefaultResource

        // AS 1/9/09 NA 2009 Vol 1 - Fixed Fields
        #region GetFixedFieldInfo
        internal FixedFieldInfo GetFixedFieldInfo(RecordPresenter rp)
        {
            FieldLayout fl = rp.FieldLayout;

            if (null == fl || !fl.IsFixedFieldsEnabled)
                return null;

            return this.CurrentViewInternal.GetFixedFieldInfo(rp);
        }
        #endregion //GetFixedFieldInfoImpl
        
        // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
        #region GetGroupByAreaResolved



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

        internal GroupByAreaBase GetGroupByAreaResolved(bool allocateIfNecessary)
        {
            ViewBase view = this.CurrentViewInternal;

            if (view != null && view.IsGroupBySupported == false)
                return null;

            if (this.GroupByAreaMode == GroupByAreaMode.DefaultFieldLayoutOnly)
            {
                if (this._groupByArea == null &&
                    allocateIfNecessary &&
                    this.GroupByAreaLocation != GroupByAreaLocation.None)
                {
                    return this.GroupByArea;
                }

                return this._groupByArea;
            }
            else
            {
                if (this._groupByAreaMulti == null &&
                    allocateIfNecessary &&
                    this.GroupByAreaLocation != GroupByAreaLocation.None)
                {
                    this.GroupByAreaMulti = new GroupByAreaMulti();
                }

                return this._groupByAreaMulti;
            }
        }

        #endregion //GetGroupByAreaResolved	
    
		#region GetGenericResource

		internal static object GetGenericResource(Type key)
		{
			if (Infragistics.Windows.Themes.DataPresenterGeneric.Instance.Contains(key))
				return Infragistics.Windows.Themes.DataPresenterGeneric.Instance[key];

			if (Infragistics.Windows.Themes.PrimitivesGeneric.Instance.Contains(key))
				return Infragistics.Windows.Themes.PrimitivesGeneric.Instance[key];

			if (Infragistics.Windows.Themes.EditorsGeneric.Instance.Contains(key))
				return Infragistics.Windows.Themes.EditorsGeneric.Instance[key];

			return null;
		}

		#endregion //GetGenerictResource

		#region GetHighlightPrimaryFieldResolved

		internal bool GetHighlightPrimaryFieldResolved(FieldLayout layout)
		{
			HighlightPrimaryField setting = HighlightPrimaryField.Default;

			if (layout != null && layout.HasSettings)
				setting = layout.Settings.HighlightPrimaryField;

            // JJD 12/21/07
            // Check HasFieldLayoutSettings property instead
            //if (setting == HighlightPrimaryField.Default &&
            //    this.FieldLayoutSettings != null)
			if (setting == HighlightPrimaryField.Default &&
				this.HasFieldLayoutSettings)
				setting = this.FieldLayoutSettings.HighlightPrimaryField;

			switch (setting)
			{
				case HighlightPrimaryField.Highlight:
					return true;

				case HighlightPrimaryField.SameAsOtherFields:
					return false;

				default:
					{
						if (layout == null)
							layout = this.DefaultFieldLayout;

						if (layout != null)
						{
							FieldLayoutTemplateGenerator generator = layout.StyleGenerator;

							return (generator != null && !(generator is GridViewFieldLayoutTemplateGenerator));
						}

						return false;
					}
			}
		}

		#endregion //GetHighlightPrimaryFieldResolved

		#region GetString
		internal static string GetString(string name)
		{
			return GetString(name, null);
		}

		internal static string GetString(CultureInfo culture, string name)
		{
#pragma warning disable 436
			return SR.GetString(culture, name);
#pragma warning restore 436
		}

		internal static string GetString(string name, params object[] args)
		{
#pragma warning disable 436
			return SR.GetString(name, args);
#pragma warning restore 436
		}
		#endregion // GetString

		#region InternalAddLogicalChild






        // JJD 11/21/08 - TFS6743/BR35763 
        // allow any object as a logical child
        //internal void InternalAddLogicalChild(IFrameworkInputElement child)
        internal void InternalAddLogicalChild(object child)
        {
            // JJD 10/01/08
            // First make sure we don't already have the element in our logical children collection
            if (!this._logicalChildren.Contains(child))
            {
                this.AddLogicalChild(child);

                // JJD 10/01/08
                // Add the element to the logical children collection so it is included in the
                // enumerator returned from the LogicalChildren property
                this._logicalChildren.Add(child);
            }
            else
            {
                Debug.Fail("Element is already a logical child of us.");
            }

		}
		#endregion //InternalAddLogicalChild

		#region InitializeItemsPanel

		internal void InitializeItemsPanel()
		{
			if (this._contentSiteGrid == null)
				return;

			ViewBase currentView = this.CurrentViewInternal;
			Type panelType = currentView.ItemsPanelType;

			// JJD 6/14/07
			// Use IsAssignableFrom instead of IsSubclassOf since that is 10x more efficient
			//if (panelType.IsAbstract == true || panelType.IsSubclassOf(typeof(Panel)) == false)
			if (panelType.IsAbstract == true || typeof(Panel).IsAssignableFrom(panelType) == false)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_8"));

			if (this._itemsPanel == null ||
				 this._itemsPanel.VisualTree.Type != panelType)
			{
				RecordListControl oldRootRecordListControl = this._rootRecordListControl;
				if (oldRootRecordListControl != null)
				{
					this.ClearGroupBy();
                    // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                    // use the BumpGroupByAreaStyleVersion method instead of the GroupByArea property
                    //this.GroupByArea.StyleVersionNumber++;
                    this.BumpGroupByAreaStyleVersion();
				}

				// AS 6/3/09 TFS18192
				// We need to clear the binding on the old record list control first
				// or else it will have another CarouselViewPanel created and hook the 
				// RecordCollapsed of the datapresenter only to have that control released.
				//
				if (null != _currentRecordListControl)
					BindingOperations.ClearBinding(_currentRecordListControl, ItemsControl.ItemsPanelProperty);

				// the current listbox holds the current island of scrolling records
				// JJD 2/22/12 - TFS101199 
				// Pass true in for the isRoot parameter
				//this._rootRecordListControl = this._currentRecordListControl = new RecordListControl(this);
				this._rootRecordListControl = this._currentRecordListControl = new RecordListControl(this, true);

				this._itemsPanel = this.InitializeRecordListControlPanel(this._currentRecordListControl, panelType);

				this.SetValue(DataPresenterBase.ItemsPanelPropertyKey, this._itemsPanel);

				this._currentRecordListControl.SetBinding(ItemsControl.ItemsPanelProperty, Utilities.CreateBindingObject(DataPresenterBase.ItemsPanelProperty, BindingMode.OneWay, this));

				// AS 6/3/09 TFS18192
				// Since the record list control holds a reference to its descendant panel
				// we should invalidate its measure to make sure it will update that reference
				// in its next measure.
				//
				_currentRecordListControl.InvalidateMeasure();

				// JJD 3/26/07
				// Update the horz and vert scrollbar visibility properties
				this.UpdateScrollBarVisibility();

				// JJD 3/26/07
				// Bind to the new horz and vert scrollbar visibility properties so we pick up any changes to
				// the view
				//this._currentRecordListControl.SetValue(RecordListControl.HorizontalScrollBarVisibilityProperty, KnownBoxes.FromValue(currentView.HorizontalScrollBarVisibility));
				//this._currentRecordListControl.SetValue(RecordListControl.VerticalScrollBarVisibilityProperty, KnownBoxes.FromValue(currentView.VerticalScrollBarVisibility));
				this._currentRecordListControl.SetBinding(RecordListControl.HorizontalScrollBarVisibilityProperty, Utilities.CreateBindingObject(DataPresenterBase.HorizontalScrollBarVisibilityProperty, BindingMode.OneWay, this));
				this._currentRecordListControl.SetBinding(RecordListControl.VerticalScrollBarVisibilityProperty, Utilities.CreateBindingObject(DataPresenterBase.VerticalScrollBarVisibilityProperty, BindingMode.OneWay, this));
			}

		}

		#endregion //InitializeItemsPanel

		#region InternalRemoveLogicalChild






        // JJD 11/21/08 - TFS6743/BR35763 
        // allow any object as a logical child
        //internal void InternalAddLogicalChild(IFrameworkInputElement child)
        internal void InternalRemoveLogicalChild(object child)
        {
            this.RemoveLogicalChild(child);

            // JJD 10/01/08
            // Remove the element from the logical children collection 
            if (this._logicalChildren.Contains(child))
                this._logicalChildren.Remove(child);
		}
		#endregion //InternalRemoveLogicalChild

		#region InternalSelectItem

		/// <summary>
		/// Select or unselect the specified item, based on the select parameter.
		/// The clearExistingSelection parameter specifies if the existing selection
		/// should be cleared.
		/// </summary>
		/// <param name="item"></param>
		/// <param name="clearExistingSelection"></param>
		/// <param name="select"></param>
		/// <returns></returns>
		internal bool InternalSelectItem(ISelectableItem item,
			bool clearExistingSelection,
			bool select)
		{
			
			
			
			
			
			
			
			
			

			// if the item isn't selectable then do the clear and return
			if (item != null && !item.IsSelectable)
			{
				if (clearExistingSelection)
					this.ClearSelectedItemsOfType(item);
				return false;
			}

			// If the item is already selected, then don't select it again.
			//
			if (!clearExistingSelection && select
				&& item.IsSelected &&
				null != this._selectedItems &&
				this.SelectedItems.IsItemInCollection(item))
			{
				return true;
			}

			// We don't allow selecting items across field layouts. If a row, cell, or column that's being 
			// selected doesn't match the band of already selected rows, cells or columns then
			// clear the current selection.
			//
			// ------------------------------------------------------------------------------------
			if (!clearExistingSelection && !this.IsItemSelectableWithCurrentSelection(item))
				this.SelectedItems.ClearItemsOfType(item);
			// ------------------------------------------------------------------------------------

			SelectedItemHolder selected = this.CalculateNewSelection(item, clearExistingSelection, select);


			// If the selection is not going to change, then return without doing 
			// anything (more importanty without firing any events) because if the
			// selection is not going to change, then we shouldn't fire any events
			// either.
			// 
			// ------------------------------------------------------------------------------
			if (null != this._selectedItems && null != this._selectedItems && null != item
				&& this._selectedItems.IsSelectionSameForItemType(item.GetType(), selected))
			{
				return true;
			}
			// ------------------------------------------------------------------------------

			bool cancel = !this.SelectNewSelection(item.GetType(), selected);

			// update display if not canceled
			if (cancel)
				return false;
			else
			{
				//this.Update();
				return true;
			}
		}

		#endregion //InternalSelectItem

		#region InternalSelectRange

		internal bool InternalSelectRange(ISelectableItem item,
		bool clearExistingSelection,
		bool select)
		{
			
			
			
			
			
			
			
			
			

			SelectedItemHolder newSelection = this.CalculateNewSelectionRange(item,
				clearExistingSelection,
				select);

			bool cancel = this.SelectNewSelection(item.GetType(), newSelection);

			if (cancel)
				return false;

			return true;
		}

		#endregion //InternalSelectRange

		#region InvalidateFormatSettings

		internal void InvalidateFormatSettings()
		{
			// SSP 9/9/09 TFS18914
			// Pass in true for acceptChanges instead of false. Otherwise the entered value can
			// get lost when some property that invalidates the format settings is changed.
			// 
			//this.EndEditMode(false, true);
			this.EndEditMode( true, true );

			// AS 3/16/07
			// This has to be moved down. See the notes on OnFormatSettingsInvalidated for info.
			//
			//this.ResetGroupBySettings();

			FieldLayout defaultLayout = this.DefaultFieldLayout;
			ViewBase currentView = this.CurrentViewInternal;
			if (defaultLayout != null)
			{
				// AS 10/13/09 NA 2010.1 - CardView
				defaultLayout.OnCurrentViewChanged(true);

				defaultLayout.Reset();

				Panel panel = this.CurrentPanel;

				bool bumpDefaultLayouVersion = defaultLayout.IsInitialized;

				if (panel != null)
				{
					panel.InvalidateMeasure();

					FieldLayoutTemplateGenerator fli = currentView.GetFieldLayoutTemplateGenerator(defaultLayout);

					if (fli != null)
					{
						defaultLayout.Initialize(fli);
						bumpDefaultLayouVersion = false;
					}
				}

				if (bumpDefaultLayouVersion)
					defaultLayout.InternalVersion++;

				// AS 10/13/09
				defaultLayout.BumpSpecialRecordsVersion();

				if (this.FieldLayouts.Count > 1)
				{
					foreach (FieldLayout fl in this.FieldLayouts)
					{
						// AS 10/13/09
						// Moved within the if block below and also added outside the containing 
						// if block because we would only bump the special records version for 
						// the default field layout if we had multiple field layouts.
						//
						//// JJD 8/25/09 - NA 2009 Vol 2 - Record fixing
						//// Bump each fieldlayout's special records version incase
						//// the view's support for record fixing has changed. Bumping
						//// this version number will trigger a re-verification of the
						//// fixed records in each data island
						//fl.BumpSpecialRecordsVersion();

						if (fl != defaultLayout)
						{
							// AS 10/13/09 NA 2010.1 - CardView
							fl.OnCurrentViewChanged(true);

							// JJD 8/25/09 - NA 2009 Vol 2 - Record fixing
							// Bump each fieldlayout's special records version incase
							// the view's support for record fixing has changed. Bumping
							// this version number will trigger a re-verification of the
							// fixed records in each data island
							fl.BumpSpecialRecordsVersion();

							fl.Reset();
							FieldLayoutTemplateGenerator fli = currentView.GetFieldLayoutTemplateGenerator(fl);

							if (fli != null)
							{
								fl.Initialize(fli);
							}
						}
					}
				}
			}

			// AS 3/16/07
			// Moved from above. See the notes on OnFormatSettingsInvalidated for info.
			//
			this.ResetGroupBySettings();
		}

		#endregion //InvalidateFormatSettings

		#region InvalidateGeneratedStyles

		internal void InvalidateGeneratedStyles(bool bumpVersion, bool clearGroupBy)
		{
			// MD 3/17/11 - TFS34785
			// Moved all code to new overload.
			this.InvalidateGeneratedStyles(bumpVersion, clearGroupBy, true);
		}

		// MD 3/17/11 - TFS34785
		// Added a new overload to take the regenerateTemplates parameter.
		internal void InvalidateGeneratedStyles(bool bumpVersion, bool clearGroupBy, bool regenerateTemplates)
		{
			if (!this.HasFieldLayouts)
				return;

			if (clearGroupBy)
				this.ClearGroupBy();

			// force the exit of the edit mode
			// SSP 9/9/09 TFS18914
			// Pass in true for acceptChanges instead of false. Otherwise the entered value can
			// get lost when some property that invalidates the generated styles is changed.
			// 
			//this.EndEditMode(false, true);
			this.EndEditMode( true, true );

            // JJD 11/11/09 - TFS24665
            // Clear any pending cached record presenter
            this.ClearPendingActiveRecordPresenter();

			// MD 3/17/11 - TFS34785
			// If an async InvalidateGeneratedStyles call was made, regenerateTemplates would have been passed as True
			// when the actual call was made. Since this call is now taking the place of the pending call, force the 
			// regenerateTemplates value to True.
			if (_invalidateGeneratedStylesPending)
				regenerateTemplates = true;

            // AS 2/26/09 Optimization
            // If we have a delayed generatestyles pending, make sure we clear that flag
            // so we don't invalidate again.
            //
            this._invalidateGeneratedStylesPending = false;

			// MD 3/17/11 - TFS34785
			// Pass off the new regenerateTemplates parameter.
			//this.FieldLayouts.InvalidateGeneratedStyles(bumpVersion);
			this.FieldLayouts.InvalidateGeneratedStyles(bumpVersion, regenerateTemplates);

			Panel panel = this.CurrentPanel;

			if (panel != null)
			{
				panel.InvalidateMeasure();
				this.BumpRecordsInViewVersion();
			}

			//this.SetValue(GroupByAreaStyleResolvedPropertyKey, this.GroupByAreaStyleResolved);

			// JJD 4/25/07
			// Optimization - there is no need to invalidate the style property
			//this.InvalidateProperty(StyleProperty);

		}

		#endregion //InvalidateGeneratedStyles

        // JJD 7/21/08 - BR34098 - Optimization - added
        #region InvalidateGeneratedStylesAsync

        // JJD 7/21/08 - BR34098 - Optimization
        // Added new method to invalidate the generated styles asynchronously so that if alot of
        // changes are made in a tight loop that only one invalidation will take place
        internal void InvalidateGeneratedStylesAsync()
        {
            // JJD 7/21/08 - BR34098 - Optimization
            // If no templates have been generated then we can bail
            if (!this._haveAnyTemplatesBeenGenerated)
                return;

            // JJD 7/21/08 - BR34098 - Optimization
            // If there is already a pending invalidation we don't need to queue another
            if (this._invalidateGeneratedStylesPending)
                return;

            // JJD 7/21/08 - BR34098 - Optimization
            // If we are in a report we can't do asynchronous operations so call
            // InvalidateGeneratedStyles here
            //
            // MBS 7/29/09 - NA9.2 Excel Exporting
            //if (this.IsReportControl)
            if(this.IsSynchronousControl)
            {
                this.InvalidateGeneratedStyles(true, false);
            }
            else
            {
                // do a begininvoke to post an invalidation request
                this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new GridUtilities.MethodDelegate(OnInvalidateGeneratedStyles));

                // set a flag so we never have more than one of these queued
                this._invalidateGeneratedStylesPending = true;
            }
        }

        #endregion //InvalidateGeneratedStylesAsync	
    
		#region InvalidateItemsHost

		internal void InvalidateItemsHost()
		{
			Panel panel = this.CurrentPanel;

			if (panel != null)
				panel.InvalidateMeasure();
		}

		#endregion //InvalidateItemsHost

		// MD 7/16/10 - TFS26592
		#region IsEventSuppressed

		internal bool IsEventSuppressed(RoutedEvent routedEvent)
		{
			if (_suppressedEvents == null)
				return false;

			return _suppressedEvents.IsEventSuppressed(routedEvent);
		} 

		#endregion // IsEventSuppressed

		#region IsInitializeRecordSuspendedFor

		// SSP 3/3/09 TFS11407
		// Added Suspend/Resume InitializeRecordFor methods.
		// 
		internal bool IsInitializeRecordSuspendedFor( Record record )
		{
			return this._initializeRecordSuspendedFor == record
				|| null != this._initializeRecordSuspendedFor_List
				   && this._initializeRecordSuspendedFor_List.Contains( record );
		}

		#endregion // IsInitializeRecordSuspendedFor

		#region IsItemSelectableWithCurrentSelection



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

		internal bool IsItemSelectableWithCurrentSelection(ISelectableItem item)
		{
			Record record = item as Record;

			// if the item is a record check current selected records
			//
			if (record != null)
			{
				if (this.SelectedItems.Records.Count < 1)
					return true;

				// Return false if the field layouts don't match
				//
				if (this.SelectedItems.Records[0].FieldLayout != record.FieldLayout)
					return false;

				//// return true only if the records are at the same nesting level
				//return record.NestingDepth == this.SelectedItems.Records[0].NestingDepth;
				// JM 10-17-08 [BR35905 TFS6838] Go back to checking nesting depth only so we can select across parents at the same nesting depth.
				//return record.ParentRecord == this.SelectedItems.Records[0].ParentRecord;
				return record.NestingDepth == this.SelectedItems.Records[0].NestingDepth;
			}

			Cell cell = item as Cell;

			// if the item is a cell check current selected cells
			//
			if (cell != null)
			{
				if (this.SelectedItems.Cells.Count < 1)
					return true;

				// Return false if the field layouts don't match
				//
				if (this.SelectedItems.Cells[0].Field.Owner != cell.Field.Owner)
					return false;

				// AS 1/6/12 TFS29076
				// Do not allow selection of template record cells to be mixed with selection of regular records.
				//
				if (GridUtilities.IsAddRecordTemplate(this.SelectedItems.Cells[0].Record) != GridUtilities.IsAddRecordTemplate(cell.Record))
					return false;

				//// return true only if the records are at the same nesting level
				//return this.SelectedItems.Cells[0].Record.NestingDepth == cell.Record.NestingDepth;
				// JM 10-17-08 [BR35905 TFS6838] Go back to checking nesting depth only so we can select across parents at the same nesting depth.
				//return this.SelectedItems.Cells[0].Record.ParentRecord == cell.Record.ParentRecord;
				return this.SelectedItems.Cells[0].Record.NestingDepth == cell.Record.NestingDepth;
			}

			Field field = item as Field;

			// if the item is a field check current selected field
			//
			if (field != null)
			{
				if (this.SelectedItems.Fields.Count < 1)
					return true;

				// Return true only if the field layouts match
				//
				return (this.SelectedItems.Fields[0].Owner == field.Owner);
			}

			Debug.Fail("Invalid Item passed into DataPresnter IsItemSelectableWithCurrentSelection. Item: " + item != null ? item.ToString() : "null");

			return true;
		}

		#endregion // IsItemSelectableWithCurrentSelection

        // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
        #region IsFixedFieldsSupportedResolved

        internal bool IsFixedFieldsSupportedResolved
        {
            get 
            {



                ViewBase currentView = this.CurrentViewInternal;

                return null != currentView && currentView.IsFixedFieldsSupported && currentView.HasLogicalOrientation; 

            }
        }

        #endregion //IsFixedFieldsSupportedResolved

        // JJD 6/8/09 NA 2009 Vol 2 - Fixed Records
        #region IsFixedRecordsSupportedResolved

        internal bool IsFixedRecordsSupportedResolved
        {
            get 
            {



                ViewBase currentView = this.CurrentViewInternal;

                return null != currentView && currentView.IsFixedRecordsSupported; 

            }
        }

        #endregion //IsFixedRecordsSupportedResolved

		// AS 2/11/11 NA 2011.1 Word Writer
		#region IsFilterRecordSupportedResolved

		internal bool IsFilterRecordSupportedResolved
		{
			get
			{
				ViewBase currentView = this.CurrentViewInternal;
				return null != currentView && currentView.IsFilterRecordSupported;
			}
		}

		#endregion //IsFilterRecordSupportedResolved

		// AS 3/10/11 NA 2011.1 - Async Exporting
		#region IsOperationAllowed
		internal bool IsOperationAllowed(UIOperation operation)
		{
			if (_cachedExportStatus != RecordExportStatus.NotExporting)
			{
				switch (operation)
				{
					// this has to be disabled through the export operation
					// since it affects the state of records/cells
					case UIOperation.Edit:
					case UIOperation.FieldGrouping:
					case UIOperation.RecordResizing:
					case UIOperation.DeleteRecord:
					case UIOperation.RecordFixing:
					case UIOperation.RecordFiltering:
					case UIOperation.RecordExpandCollapse:
					case UIOperation.Paste:
					case UIOperation.ClearCellContents:
					case UIOperation.Undo:
						return false;

					// once we have copied the layout we can allow this
					case UIOperation.FieldMoving:
					case UIOperation.FieldFixing:
					case UIOperation.FieldVisibility:
					case UIOperation.FieldAutoSizing:
					case UIOperation.FieldResizing:
					case UIOperation.FieldSorting:
					case UIOperation.FieldSummaries:
						return _cachedExportStatus == RecordExportStatus.Exporting;

					default:
						Debug.Fail("Unrecognized operation:" + operation.ToString());
						return true;
				}
			}

			return true;
		}
		#endregion //IsOperationAllowed

		#region OnActiveRecordChanged

		/// <summary>
		/// Called when the active record is set
		/// </summary>
		internal bool OnActiveRecordChange(Record newActiveRecord, bool scrollIntoView)
		{
            if (newActiveRecord == null)
                return false;

			//raise the before event
			RecordActivatingEventArgs beforeEventArgs = new RecordActivatingEventArgs(newActiveRecord);
			this.RaiseRecordActivating(beforeEventArgs);

            // JJD 6/16/08 - BR33518
            // If the RecordActivating event was cancelled then return false
            if (beforeEventArgs.Cancel == true)
                return false;
            
			//set activerecord to the newactiverecord
			this._activeRecord = newActiveRecord;

			if (null != this._activeRecord)
			{
				this._activeRecord.OnActiveRecordChanged();

				// JJD 9/2/10 - TFS37394
				// Verify that the active record hasn't been cleared
				if (this._activeRecord == null)
					return false;
			}

			//raise the after event
			RecordActivatedEventArgs afterEventArgs = new RecordActivatedEventArgs(newActiveRecord);
			this.RaiseRecordActivated(afterEventArgs);

			// JJD 3/12/07
			// Check to make sure the new active record is not null
			if (null != this._activeRecord)
			{
				if (scrollIntoView)
				{
					this.BringRecordIntoView(this._activeRecord);
					this.UpdateLayout();

					// JJD 9/2/10 - TFS37394
					// Verify that the active record hasn't been cleared
					if (this._activeRecord == null)
						return false;
				}

                // JJD 12/23/09 - TFS25757
                // Moved call to FocusIfAppropriate outside 'if (scrollIntoView)'
                // bloack above because focusing the record should have nothing to
                // do with scrolling it into view
				RecordPresenter rp = this._activeRecord.AssociatedRecordPresenter;

				// JJD 3/14/07
				// if the associated record presenter doesn't have focus then give it to it now
				if (rp != null && rp.IsVisible)
					rp.FocusIfAppropriate();

				// JJD 9/2/10 - TFS37394
				// Verify that the active record hasn't been cleared
				if (this._activeRecord != null)
				{
					// Let the panel know that a record has been activated.
					
					
					
					IViewPanel panel = this.CurrentPanel as IViewPanel;
					if (panel != null)
						panel.OnActiveRecordChanged(this._activeRecord);
				}
            }

			return true;
		}

		#endregion //OnActiveRecordChanged

		#region OnActiveRecordCleared

		/// <summary>
		/// Internal method called to clear the active record
		/// </summary>
		internal bool OnActiveRecordCleared(bool update)
		{
			// when we clear the active record we also need to clear the active cell
			// but we don't need to invalidate the active cell since that will
			// be taken care of when we invalidate the record
			//
			if (!this.ClearActiveCell())
				return false;

			if (this._activeRecord != null)
			{
				// Store the current active record into a variable because _activeRecord
				// member variable could get set to null when for example RecordDeactivating
				// event is fired below.
				//
				Record activeRecord = this._activeRecord;

				// Fire the RecordDeactivating event. If it is cancelled
				// then return false.
				// 
				// If the active record is invalid (when a group by record is the active record and
				// the group by hierarchy changes, we regenerate the group by records and then 
				// the active record would become invalid and ActiveRecord property's get will
				// return null. So we only want to fire the event if the ActiveRecord property 
				// returns a record.
				// Added if check for the code inside.
				//
				if (null != activeRecord)
				{

					RecordDeactivatingEventArgs deactivatingEventArgs = new RecordDeactivatingEventArgs(this._activeRecord);

					this.RaiseRecordDeactivating(deactivatingEventArgs);

					if (deactivatingEventArgs.Cancel)
						return false;

					DataRecord dr = activeRecord as DataRecord;

					if (dr != null && dr.IsDataChanged)
					{
						// if the update mode is not update on update then comm
						// commit any changes at this point
						if (this.UpdateMode != UpdateMode.OnUpdate)
						{
							// JJD 1/29/07 - BR19574
							// If the commit didn't work or was cancelled then don't
							// allow the active record to be cleared
							// JJD 5/23/07 - BR23169
							// Call the Update method instead so the RecordUpdating and RecordUpdated events get raised
							//if (!dr.CommitChanges())
							if (!dr.Update())
								return false;
						}
					}
				}

				//if (update &&
				//    Infragistics.Win.UltraWinGrid.UpdateMode.OnUpdate != this.UpdateMode)
				//{
				//    // Use the activeRecord local variable instead of _activeRecord member variable
				//    // because when above BeforeRecordDeactivate is fired, the _activeRecord may
				//    // get set to null.
				//    // 
				//    //bool succeeded = this._activeRecord.Update();					
				//    bool succeeded = activeRecord.Update();

				//    if (!succeeded)
				//        return false;

				//    // Recheck _activeRecord
				//    //
				//    if (this._activeRecord == null)
				//        return true;
				//}

				Record tmpRecord = this._activeRecord;

				// finally clear the active record
				//
				this._activeRecord = null;

				// Added OnActiveStateChanged on record and cell.
				//
				if (null != tmpRecord)
					tmpRecord.OnActiveRecordChanged();

				// SSP 1/7/09 - NAS9.1 Record Filtering
				// While a record is active, we don't filter it when its values are 
				// changed. Howeever when the record is de-activated, we should 
				// filter it at that point.
				// 
				this.ProcessRecordWithPendingFilterHelper( tmpRecord );

			}
			return true;
		}

		#endregion //OnActiveRecordCleared

		// JM 08-04-08 Load/Save Customizations
		#region OnAfterApplyCustomizations

		internal void OnAfterApplyCustomizations()
		{
			// JJD 06/22/11 - TFS34793
			// Invalidate the styles asynchronously in case we are in the middle of a measure pass
			// on a record presenter.
			//this.InvalidateGeneratedStyles( true, false );
			this.InvalidateGeneratedStylesAsync();
		}

		#endregion //OnAfterApplyCustomizations

		// JM 08-04-08 Load/Save Customizations
		#region OnBeforeApplyCustomizations

		internal void OnBeforeApplyCustomizations()
		{
		}

		#endregion //OnBeforeApplyCustomizations

		#region OnCurrentRecordListControlSelectionChanged

		internal void OnCurrentRecordListControlSelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			if (e.AddedItems.Count == 1)
				this.SetActiveRecord(e.AddedItems[0] as Record, false);
			else
				if (e.RemovedItems.Count == 1)
					this.SetActiveRecord(null, false);
		}

		#endregion //OnCurrentRecordListControlSelectionChanged

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region OnAutoSizeAllRecordsChanged
		internal void OnAutoSizeAllRecordsChanged(FieldLayout fl, bool hasAllRecords)
		{
			_fieldLayoutAutoSizeAllRecordsCount += hasAllRecords ? 1 : -1;
			Debug.Assert(_fieldLayoutAutoSizeAllRecordsCount <= _fieldLayouts.Count && _fieldLayoutAutoSizeAllRecordsCount >= 0);

			if (!hasAllRecords)
			{
				// if a field layout had auto sized fields with a scope of all and it doesn't any 
				// longer then we need to recalculate the maximum depth that does have autosized 
				// fields for all records
				this.ResetAllRecordsAutoSizeMaxDepth();
			}
			else
			{
				_allRecordsAutoSizeMaxDepth = Math.Max(_allRecordsAutoSizeMaxDepth, fl.MaxRecordManagerDepth);
			}
		}
		#endregion //OnAutoSizeAllRecordsChanged

		// AS 6/26/09 NA 2009.2 Field Sizing
		#region OnAutoSizePending
		/// <summary>
		/// Invoked when a field layout has pending autosize operations
		/// </summary>
		/// <param name="fieldLayout">The field layout that has pending field auto size operations</param>
		internal void OnAutoSizePending(FieldLayout fieldLayout)
		{
			Debug.Assert(null != fieldLayout);

			if (_fieldLayoutsAutoSizePending == null)
				_fieldLayoutsAutoSizePending = new List<FieldLayout>();

			Debug.Assert(!_fieldLayoutsAutoSizePending.Contains(fieldLayout));

			_fieldLayoutsAutoSizePending.Add(fieldLayout);

			// we don't want to start the async measurement callback while we are processing or if 
			// we have already started it
			if (!_processingFieldAutoSize && _pendingFieldAutoSize == null)
				this.SetupAsyncAutoSize();
		}

		#endregion //OnAutoSizePending

		// JJD 7/21/08 - BR34098 - Optimization - added
        #region OnFieldLayoutTemplateGeneration

        internal void OnFieldLayoutTemplateGeneration()
        {
            // set a flag so we know that at least one style generation has happened
            this._haveAnyTemplatesBeenGenerated = true;
        }

        #endregion //OnFieldLayoutTemplateGeneration

		#region OnFormatSettingsInvalidated

		internal void OnFormatSettingsInvalidated()
		{
			if (this.DefaultFieldLayout == null)
				return;

			// AS 3/16/07
			// Clearing the groupby can lead to the InvalidateGeneratedStyles
			// of a field layout which can cause a HeaderAreaTemplate property
			// change. When that happens, an object bound to that property 
			// will ask for the template which cause the templates to be 
			// regenerated but before the styleGenerator reference on the field 
			// layout has been reinitialized/cleared out. That means we're using
			// the old generator which when going from horizontal to vertical or 
			// vice versa in grid view means the grid's orientation and that of the style 
			// generator will be out of sync. This came up when using group by and then 
			// changing the orientation.
			//
			//this.ClearGroupBy();
			this.InvalidateFormatSettings();
			this.ClearGroupBy();
		}

		#endregion //OnFormatSettingsInvalidated

		#region OnIsFocusWithinChanged

		/// <summary>
		/// Called when the element either recieves or loses the logical focus.
		/// </summary>
		/// <param name="gotFocus"></param>
		internal void OnIsFocusWithinChanged(bool gotFocus)
		{
			if (!gotFocus)
			{
				// AS 7/19/07 BR25005
				// Moved up from below - We should come out of edit mode before we update.
				// Also, if the control is hidden - as it would be when the form is closing -
				// we will force the exit.
				//
				// AS 7/18/07 BR25005
				// When the Focus is no longer within the DataPresenter, we should
				// try to come out of edit mode.
				//
				this.EndEditMode(true, this.IsVisible == false);

				switch (this.UpdateMode)
				{
					case UpdateMode.OnCellChangeOrLostFocus:
					case UpdateMode.OnRecordChangeOrLostFocus:

						DataRecord dr = this.ActiveRecord as DataRecord;

						if (dr != null && dr.IsDataChangedSinceLastCommitAttempt)
						{
							// JJD 5/23/07 - BR23169
							// Call the Update method instead so the RecordUpdating and RecordUpdated events get raised
							//dr.CommitChanges();
							dr.Update();
						}
						break;
				}

				// AS 7/19/07
				// Moved up - We should come out of edit mode before we update.
				//
				// AS 7/18/07 BR25005
				// When the Focus is no longer within the DataPresenter, we should
				// try to come out of edit mode.
				//
				//this.EndEditMode(true, false);
			}
			else
			{
				// AS 7/18/07 BR25005
				// I talked to Sandip about this one. Basically, when you tab back 
				// into the control, we should be focusing the active cell or record.
				// If we don't, then the grid retains the focus. To limit the case 
				// when we intervene we'll only do this if the grid is focused.
				//
				DependencyObject scope = FocusManager.GetFocusScope(this);

				if (scope != null && FocusManager.GetFocusedElement(scope) == this)
				{
					Cell activeCell = this.ActiveCell;
					CellValuePresenter cvp = activeCell != null ? activeCell.AssociatedCellValuePresenter : null;

					if (null != cvp)
						cvp.FocusIfAppropriate();
					else
					{
						Record record = this.ActiveRecord;
						RecordPresenter rp = record != null ? record.AssociatedRecordPresenter : null;

						if (null != rp)
							rp.FocusIfAppropriate();
					}
				}
			}
		}

		#endregion // OnIsFocusWithinChanged

		#region OnRecordExpandStateChanged

		internal bool OnRecordExpandStateChanged(Record record, bool isExpanded)
		{
			// AS 6/3/09 NA 2009.2 Undo/Redo
			return OnRecordExpandStateChanged(record, isExpanded, false);
		}

		internal bool OnRecordExpandStateChanged(Record record, bool isExpanded, bool addToUndo)
		{
			// AS 6/3/09 NA 2009.2 Undo/Redo
			List<Record> recordsChanged = addToUndo && this.IsUndoEnabled ? new List<Record>() : null;

			bool changed = OnRecordExpandStateChanged(record, isExpanded, recordsChanged);

			// AS 6/3/09 NA 2009.2 Undo/Redo
			// To be consistent with what happens when the RecordExpansionAction is being
			// executed, we will not add the entry to the undo stack until after the after
			// event has been invoked.
			//
			if (changed && null != recordsChanged)
				this.History.AddUndoActionInternal(new RecordExpansionAction(recordsChanged, !isExpanded));

			return changed;
		}

		// AS 6/3/09 NA 2009.2 Undo/Redo
		internal bool OnRecordExpandStateChanged(Record record, bool isExpanded, List<Record> recordsChanged)
		{
			//if (!(record is DataRecord))
			//{
			//    // get current active record which may have to change
			//    Record activeRecord = this.ActiveRecord;

			//    // get current drill down record 
			//    Record oldDrillDownRecord = this.DrillDownRecord;

			//    if (isExpanded)
			//    {
			//        if (record == oldDrillDownRecord)
			//            return;

			//        if (!record.HasChildren || !this.IsDrillDownMode)
			//            return;

			//        this.DrillDownToRecord(record, false);
			//    }
			//    else
			//    {
			//        // drill up to the parent of this record
			//        this.DrillUpToRecord(record.ParentRecord, false);
			//    }
			//}

			// raise the approriate before event
			if (isExpanded == true)
			{
				RecordExpandingEventArgs e = new RecordExpandingEventArgs(record);
				this.RaiseRecordExpanding(e);

				// if the event was cancelled return false
				if (e.Cancel == true)
					return false;
			}
			else
			{
				// SSP 8/20/09 TFS20765
				// If a descendant cell is in edit mode then exit the edit mode on 
				// it before collapsing the ancestor record. Otherwise when the 
				// record is expanded, the cell presenter for the cell will be a
				// different instance and won't reflect the edited value anyways.
				// ------------------------------------------------------------------
				Cell activeCell = this.ActiveCell;
				if ( null != activeCell && activeCell.IsInEditMode 
					&& null != activeCell.Record && record.IsTrivialAncestorOf( activeCell.Record ) )
				{
					activeCell.EndEditMode( true, false );
					if ( activeCell.IsInEditMode )
						return false;
				}
				// ------------------------------------------------------------------

				RecordCollapsingEventArgs e = new RecordCollapsingEventArgs(record);
				this.RaiseRecordCollapsing(e);

				// if the event was cancelled return false
				if (e.Cancel == true)
					return false;
			}

			// set the state on the record
			// AS 6/3/09 NA 2009.2 Undo/Redo
			//record.SetIsExpanded(isExpanded);
			record.SetIsExpanded(isExpanded, recordsChanged);

			// confirm that the new state was in fact set
			if (record.IsExpanded != isExpanded)
				return false;

			// raise the approriate after event
			if (isExpanded == true)
			{
				RecordExpandedEventArgs e = new RecordExpandedEventArgs(record);
				this.RaiseRecordExpanded(e);
			}
			else
			{
				RecordCollapsedEventArgs e = new RecordCollapsedEventArgs(record);
				this.RaiseRecordCollapsed(e);
			}

			return true;
		}

		#endregion //OnRecordExpandStateChanged

        // JJD 1/14/08 
        #region OnRootCollectionChanged

        // JJD 1/14/08 
        // Handle receiving change notifications on other threads
        internal void OnRootCollectionChanged()
        {
            // see if we are on the correct thread
            if (this.CheckAccess())
            {
                // since we are we can coerce the DataSourceInternalProperty
                this.CoerceValue(DataSourceInternalProperty);

                // clear the _asyncChangePending member
                this._asyncChangePending = null;
            }
            else
            {
                // JJD 3/29/08 - added support for printing.
                // We can't do asynchronous operations during a print
                //
                // MBS 7/29/09 - NA9.2 Excel Exporting
                //if (this.IsReportControl)
                if(this.IsSynchronousControl)
                    this.OnRootCollectionChanged();
                else
                {
                    // If we don't already have a request pending then dispatch one now
                    if (this._asyncChangePending == null)
                        this._asyncChangePending = this.Dispatcher.BeginInvoke(DispatcherPriority.DataBind, new GridUtilities.MethodDelegate(OnRootCollectionChanged));
                }
            }
        }

        #endregion //OnRootCollectionChanged	

		// JJD 3/15/11 - TFS65143 - Optimization
		#region ProcessLayoutUpdatedCallbackList

		// JJD 3/15/11 - TFS65143 - Optimization
		// Process pending callbacks that are waiting for layout updated 
		private void ProcessLayoutUpdatedCallbackList(object sender, EventArgs e)
		{
			// first unwire the event
			this.LayoutUpdated -= new EventHandler(this.ProcessLayoutUpdatedCallbackList);

			if (_layoutUpdatedCallbacks != null &&
				_layoutUpdatedCallbacks.Count > 0)
			{
				// First copy the hashset into a stack list
				// AS 11/16/11 TFS95167
				//ArrayList list = new ArrayList(_layoutUpdatedCallbacks);
				var list = _layoutUpdatedCallbacks.ToArray<GridUtilities.MethodDelegate>();

				// clear the hashset before beginning processing
				_layoutUpdatedCallbacks.Clear();

				// AS 11/16/11 TFS95167
				// I found this while testing. Since we store the delegates in a hashset, the order we process them 
				// is random. This is causing a problem because sometimes we process the datapresenter before some 
				// or all of the virtualizingdatarecordcellpanels so while doing the autosize calculations the 
				// cell elements were not yet allocated.
				//
				Comparison<GridUtilities.MethodDelegate> comparison = delegate(GridUtilities.MethodDelegate d1, GridUtilities.MethodDelegate d2) {
					if (d1 == null)
						return d2 == null ? 0 : -1;
					else if (d2 == null)
						return 1;

					if (d1.Target != d2.Target)
					{
						// process the data presenter callbacks after the descendants
						if (d1.Target is DataPresenterBase)
							return 1;
						else if (d2.Target is DataPresenterBase)
							return -1;
					}

					return 0;
				};

				Utilities.SortMergeGeneric(list, Utilities.CreateComparer(comparison));

				// callback all interested parties
				foreach (GridUtilities.MethodDelegate callback in list)
					callback();
			}

		}

		#endregion //ProcessLayoutUpdatedCallbackList	
    
		#region ProcessRecordWithPendingFilterHelper

		// SSP 1/7/09 - NAS9.1 Record Filtering
		// While a record is active, we don't filter it when its values are 
		// changed. However when the record is de-activated, we should 
		// filter it at that point.
		// 
		internal void ProcessRecordWithPendingFilterHelper( Record record )
		{
			Record tmp = _activeRecordWithPendingDirtyFilterState;
			if ( null != tmp && ( tmp == record || null == record ) )
			{
				_activeRecordWithPendingDirtyFilterState = null;

				FieldLayout fl = tmp.FieldLayout;
				if ( null != fl && fl.ReevaluateFiltersOnDataChangeResolved )
					tmp.DirtyFilterState( );
			}
		}

		#endregion // ProcessRecordWithPendingFilterHelper

        // JJD 3/16/09 - Optimization
        #region QueueNestedContentInitializationRequest

        // Maintain a queue of record presenters that are waiting to
        // have their nested content initailiazed
        internal void QueueNestedContentInitializationRequest(RecordPresenter rp)
        {
            if (this._recordsPendingNestedContentInitialization == null)
                this._recordsPendingNestedContentInitialization = new Queue<RecordPresenter>();

            if (this._recordsPendingNestedContentInitialization.Count == 0)
            {
                // on the 1st request wire up the LayoutUpdated event
				
				// JJD 3/15/11 - TFS65143 - Optimization
				// Instead of having every element wire LayoutUpdated we can maintain a list of pending callbacks
				// and just wire LayoutUpdated on the DP
				//EventHandler args = new EventHandler(OnLayoutUpdated);
				//this.LayoutUpdated -= args;
				//this.LayoutUpdated += args;
				this.WireLayoutUpdated(this.OnLayoutUpdated);
            }

            this._recordsPendingNestedContentInitialization.Enqueue(rp);
        }

        #endregion //QueueNestedContentInitializationRequest	

		// AS 3/17/11 NA 2011.1 - Async Exporting
		#region RemoveStatusControl
		internal void RemoveStatusControl(RecordExportStatusControl ctrl)
		{
			if (ctrl != null && _dataAreaGrid != null)
			{
				Debug.Assert(VisualTreeHelper.GetParent(ctrl) == _dataAreaGrid, "Status not within grid?");

				if (VisualTreeHelper.GetParent(ctrl) == _dataAreaGrid)
					_dataAreaGrid.Children.Remove(ctrl);
			}
		}
		#endregion //RemoveStatusControl

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region ResetAllRecordsAutoSizeMaxDepth
		internal void ResetAllRecordsAutoSizeMaxDepth()
		{
			_allRecordsAutoSizeMaxDepth = -2;
		}
		#endregion //ResetAllRecordsAutoSizeMaxDepth

		#region ResetGroupBySettings

        internal void ResetGroupBySettings()
		{
			if (this.FieldLayouts != null)
			{
				foreach (FieldLayout fl in this.FieldLayouts)
				{
					if (fl.HasGroupBySortFields)
						fl.SortedFields.Clear();
				}
			}
		}

		#endregion //ResetGroupBySettings

		#region ResetItemsPanel

		internal void ResetItemsPanel()
		{
			Panel panel = this.CurrentPanel;

			if (panel != null)
			{
				panel.InvalidateMeasure();
				DataPresenterBase.SetPanelSettings(this._currentRecordListControl, null);
			}

			if (this.DefaultFieldLayout != null)
				this.DefaultFieldLayout.Reset();

			// this.SetValue(InternalItemStyleSelectorPropertyKey, this._itemStyleSelector);
		}

		#endregion //ResetItemsPanel

		// AS 7/24/09 NA 2009.2 Field Sizing
		#region ResumeEndEditOnScroll
		internal void ResumeEndEditOnScroll()
		{
			_endEditOnScrollSuspendCount--;
			Debug.Assert(_endEditOnScrollSuspendCount >= 0);
		}
		#endregion //ResumeEndEditOnScroll

		#region ResumeInitializeRecordFor

		// SSP 3/3/09 TFS11407
		// Added Suspend/Resume InitializeRecordFor methods.
		// 
		internal void ResumeInitializeRecordFor( Record record )
		{
			if ( record == this._initializeRecordSuspendedFor )
			{
				this._initializeRecordSuspendedFor = null;
				if ( null != this._initializeRecordSuspendedFor_List )
				{
					int lastIndex = this._initializeRecordSuspendedFor_List.Count - 1;
					if ( lastIndex >= 0 )
					{
						this._initializeRecordSuspendedFor = this._initializeRecordSuspendedFor_List[lastIndex];

						this._initializeRecordSuspendedFor_List.RemoveAt( lastIndex );
					}

					if ( 0 == lastIndex )
						this._initializeRecordSuspendedFor_List = null;
				}
			}
			else if ( null != this._initializeRecordSuspendedFor_List )
			{
				this._initializeRecordSuspendedFor_List.Remove( record );
				if ( 0 == this._initializeRecordSuspendedFor_List.Count )
					this._initializeRecordSuspendedFor_List = null;
			}
		}

		#endregion // ResumeInitializeRecordFor

		#region SelectNewSelection



#region Infragistics Source Cleanup (Region)






#endregion // Infragistics Source Cleanup (Region)

		internal bool SelectNewSelection(System.Type type, SelectedItemHolder selected)
		{
			// Exit edit mode first.  If cancelled return false
			if (this.ActiveCell != null &&
				!this.ActiveCell.EndEditMode())
				return false;

			// raise the before event. If cancelled return false
			SelectedItemsChangingEventArgs e = new SelectedItemsChangingEventArgs(type, selected);
			this.RaiseSelectedItemsChanging(e);
			if (e.Cancel)
				return false;

			// unselect all items that were originally selected but no longer are and
			// select items that weren't
			this.UpdateSelectedItems(selected);

			// fire after event
			SelectedItemsChangedEventArgs afterEventArgs = new SelectedItemsChangedEventArgs(type);
			this.RaiseSelectedItemsChanged(afterEventArgs);

			return true;
		}

		#endregion //SelectNewSelection

		#region SetActiveCell

		private void SetActiveCell(Cell newValue)
		{
			// JJD 8/18/20 - TFS37033
			// Make sure this is being called on the DP's thread
			VerifyAccess();

			if (newValue == this._activeCell)
				return;

			if (newValue != null)
			{
				// JJD 8/18/20 - TFS37033
				// If the cell's record is null then return
				if (newValue.Record == null)
				{
					Debug.Fail("Cell record should not be null");
					return;
				}

				if (newValue.Record.DataPresenter != this)
					throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_9"));
			}

			if (newValue != null && newValue.Record != this.ActiveRecord)
			{
				// set the active record
				this.ActiveRecord = newValue.Record;

				// if the operation was cancelled then return
				if (this.ActiveRecord != newValue.Record)
				{
					this._activeCell = this.ActiveCell;
					return;
				}
			}

			Cell oldValue = this._activeCell;

			// clear the old active cell first
			if (oldValue != null)
			{

				// JM 08-01-07 BR25314
				//this.ClearActiveCell(false, true);
				this.ClearActiveCell(this._forceClearActiveRecord, true);

				// if that operation was cancelled then return
				if (this._activeCell != null)
					return;
			}

			if (newValue != null)
			{
				// raise the CellActivating event
				CellActivatingEventArgs args = new CellActivatingEventArgs(newValue);

				this.RaiseCellActivating(args);

				// if the event was cancelled then return
				if (args.Cancel == true)
				{
					// AS 7/27/11 TFS82797
					// If the developer changed the active cell in the CellActivating and 
					// we had an old cell then we need to have it send change notifications 
					// so any associated CVP will update its state.
					//
					if (_activeCell != oldValue && oldValue != null)
						oldValue.OnActiveCellChanged();

					return;
				}
			}

			this._activeCell = newValue;

			if (this._activeCell != null)
			{
				// JJD 8/18/20 - TFS37033
				// Do a sanity check to make sure ActiveRecord matchs active cell's record
				if (this._activeRecord == null ||
					this._activeRecord != this._activeCell.Record)
				{
					Debug.Fail("Cell's record should match the active record");
					this._activeCell = null;
				}
				else
				{
					// get the Record's preseenter
					RecordPresenter rp = this._activeRecord.AssociatedRecordPresenter;

					if (rp != null)
					{
						Field field = this._activeCell.Field;

						// call the FromRecordAndField static method which will find the cellvaluepresenter
						CellValuePresenter cvp = CellValuePresenter.FromRecordAndField(this._activeCell.Record, field);

						// make sure the AssociatedCellValuePresenter is set
						if (cvp != null)
							this._activeCell.AssociatedCellValuePresenterInternal = cvp;

						#region Obsolete code

						//// get the 1st Cell presenter for the record
						//CellPresenter cp = Utilities.GetDescendantFromType(rp, typeof(CellPresenter), false) as CellPresenter;

						//if (cp != null)
						//{
						//    // if the field doesn't match then find the sibling cell presenter that does match
						//    if (cp.Field != field)
						//    {
						//        Grid parentGrid = cp.Parent as Grid;

						//        if (parentGrid != null)
						//        {
						//            foreach (UIElement child in parentGrid.Children)
						//            {
						//                if (child is CellPresenter &&
						//                     ((CellPresenter)child).Field == field)
						//                {
						//                    cp = (CellPresenter)child;
						//                    break;
						//                }
						//            }
						//        }
						//    }

						//    if (cp != null && cp.Field == field)
						//    {
						//        // get the CellValuePresenter for the cell
						//        CellValuePresenter cvp = Utilities.GetDescendantFromType(cp, typeof(CellValuePresenter), false) as CellValuePresenter;

						//        // cache it on the active cell
						//        if (cvp != null && cvp.Field == field)
						//            this._activeCell.AssociatedCellValuePresenter = cvp;
						//    }
						//}

						#endregion //Obsolete code
					}

					// JJD 8/18/20 - TFS37033
					// check that _activeCell is not null
					if ( this._activeCell != null )
						this._activeCell.OnActiveCellChanged();
				}
			}

			if (oldValue != null)
				oldValue.OnActiveCellChanged();

			if (this._activeCell != null)
			{
				// raise the CellActivated event
				CellActivatedEventArgs args = new CellActivatedEventArgs(this._activeCell);

				this.RaiseCellActivated(args);
			}


		}

		#endregion //SetActiveCell

		#region SetActiveRecord

		internal void SetActiveRecord(Record record, bool scrollIntoView)
		{
			// JJD 8/18/20 - TFS37033
			// Make sure this is being called on the DP's thread
			VerifyAccess();

			if (record == this._activeRecord)
				return;

			if (null != record && !record.IsEnabledResolved)
				return;

			// JM 08-01-07 BR25314
            if (null == record && this._forceClearActiveRecord)
            {
                // JJD 3/9/10 - TFS28437
                // Hold onto the active rcd ad cell before nulling them out
                Record rcd = this._activeRecord;
                Cell cell = this._activeCell;

                this._activeRecord = null;
                this._activeCell = null;

                // JJD 3/9/10 - TFS28437
                // Let the record and cell know about their change in status
                // so they can send out the appropriate notifications
                if (cell != null)
                    cell.OnActiveCellChanged();

                if (rcd != null)
                    rcd.OnActiveRecordChanged();

                return;
            }

			if (record != null)
			{
				if (record.DataPresenter != this)
					throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_10"));
			}

			// We need to pass in true for update so that the record
			// get's updated if the update mode is OnRecordChange
			if (this.OnActiveRecordCleared(true))
			{
                // JJD 7/14/09 - TFS18784 
                // check bypass flag
                //this.OnActiveRecordChange(record, scrollIntoView);
                this.OnActiveRecordChange(record, scrollIntoView && !this._bypassScrollIntoView);

                // JJD 12/08/08 - added IsSynchronizedWithCurrentItem property
                // Make sure the current item gets synched up
                if (this.IsSynchronizedWithCurrentItem)
                {
                    // JJD 12/21/09 - TFS25835
                    // For this record and all of its ancestor data records synchronize
                    // their current items by walking up the DataRecord ancestor chain. 
                    // Note: for descendant records we only synchronize down the
                    // chain of the active record. It wouldn't
                    // make sense to listen to multiple child collections current postion
                    // changed events and try to sync the ActiveRecord with that.
                    if (record == null)
                        this.RecordManager.SetCurrentItemFromActiveRecord();
                    else
                    {
                        #region Synchronize all collection views down the new ActiveRecord ancestor chain

                        DataRecord dr = record.RecordType == RecordType.DataRecord
                        ? record as DataRecord
                        : record.ParentDataRecord;

                        // JJD 12/21/09 - TFS25835
                        // Create a stack for the datarecord chain since
                        // we need to process the chain from the top (root level)
                        // on down
                        Stack<DataRecord> drChain = new Stack<DataRecord>();

                        while (dr != null)
                        {
                            drChain.Push(dr);

                            // walk up the DataRecord ancestor chain
                            dr = dr.ParentDataRecord;
                        }

                        bool isRootDataRecord = true;

                        // JJD 12/21/09 - TFS25835
                        // sync each level's current item 
                        // Note: if SetCurrentItemFromActiveRecord returns false we need 
                        // to break out of the while loop. 
                        // This happens when the current position of the
                        // bound collection prevents moving to the new position. In this
                        // case the logic would have re-synched the active record to the
                        // current item at that level
                        if (drChain.Count == 0)
                        {
                            // since we don't have an active data record call the 
                            // root manager's SetCurrentItemFromActiveRecord to 
                            // set the current position to -1
                            this.RecordManager.SetCurrentItemFromActiveRecord();
                        }
                        else
                        while (drChain.Count > 0)
                        {
                            dr = drChain.Pop();
                            RecordManager rm = dr.RecordManager;

                            if (!rm.SetCurrentItemFromActiveRecord())
                                break;

                            // Bypass the root record because the root RecordManager always
                            // is wired into its CollectionView's CurrentChanging/Changed events
                            if (isRootDataRecord == true)
                                isRootDataRecord = false;
                            else
                            {
                                // See if the RecordManager is bound to a CollectinView
                                if (rm.IsCollectionView)
                                {
                                    bool isAlreadyWired = false;

                                    if (this._nonRootCurrencyTrackingManagers == null)
                                        this._nonRootCurrencyTrackingManagers = new WeakList<RecordManager>();
                                    else
                                        isAlreadyWired = this._nonRootCurrencyTrackingManagers.Contains(rm);

                                    // if is isn't already wired then wire the CurrentChanging/Changed events up now
                                    if (!isAlreadyWired)
                                    {
                                        rm.WireCollectionViewEvents();

                                        // Add the RecordManager to the tracking list so we can know to unwire it later
                                        // when it is no longer in the active rcd chain
                                        this._nonRootCurrencyTrackingManagers.Add(rm);
                                    }
                                }
                            }
                        }

                        #endregion //Synchronize all collection views down the new ActiveRecord ancestor chain
                    }
                }

                #region Unwire RecordManagers from old active record ancestor chain

                // JJD 12/21/09 - TFS25835
                // The _nonRootCurrencyTrackingManagers contains the non-root rcd managers that
                // are wired into their respective collectionView's CurrentChanging/Changed events
                // loop over the list and unwire any RecordManager that is no longer in the
                // chain of the current active record
                if (this._nonRootCurrencyTrackingManagers != null &&
                 this._nonRootCurrencyTrackingManagers.Count > 0)
                {
                    List<RecordManager> oldManagersToUnwire = null;

                    foreach (RecordManager rm in this._nonRootCurrencyTrackingManagers)
                    {
                        if (!rm.IsInActiveRecordChain)
                        {
                            if (oldManagersToUnwire == null)
                                oldManagersToUnwire = new List<RecordManager>();

                            oldManagersToUnwire.Add(rm);
                        }
                    }

                    if (oldManagersToUnwire != null)
                    {
                        int count = oldManagersToUnwire.Count;

                        for (int i = 0; i < count; i++)
                        {
                            RecordManager rm = oldManagersToUnwire[i];

                            // remove the RecordManager from the list 
                            this._nonRootCurrencyTrackingManagers.Remove(rm);

                            // unwire the events
                            rm.UnwireCollectionViewEvents();
                        }
                    }
                }

                #endregion //Unwire RecordManagers from old active record ancestor chain
            }
        }

		#endregion //SetActiveRecord

		#region SetDefaultValue

		internal static bool SetDefaultValue(DataPresenterBase dp,
										FrameworkElement target,
										DependencyProperty targetProperty,
										DependencyProperty sourceProperty,
										bool extractTargetPropifSourceNotFound)
		{
			Style defaultStyle;
			if (dp != null)
				defaultStyle = dp.GetDefaultResource(target.GetType(), false) as Style;
			else
				defaultStyle = GetGenericResource(target.GetType()) as Style;

			Debug.Assert(defaultStyle != null);

			bool rtn = false;

			if (defaultStyle != null)
			{
				rtn = Utilities.SetPropertyFromStyle(target, targetProperty, defaultStyle, sourceProperty, true);

				if (rtn == false &&
					extractTargetPropifSourceNotFound == true)
				{
					// set the target with the sources's targetProperty since the sourceProperty value was not found
					rtn = Utilities.SetPropertyFromStyle(target, targetProperty, defaultStyle, targetProperty, true);

					Debug.Assert(rtn == true);
				}
			}

			return rtn;
		}

		#endregion //SetDefaultValue

		#region SetFieldDragManagerHelper

		// SSP 6/24/09 - NAS9.2 Field Chooser
		// Added InitializeFieldDragManager method.
		// 
		internal void SetFieldDragManagerHelper( FieldDragManager fieldDragManager )
		{
			Debug.Assert( null == _fieldDragManager || null == fieldDragManager );

			_fieldDragManager = fieldDragManager;

			WeakList<FieldChooser> registeredFieldChoosers = _registeredFieldChoosers;
			if ( null != registeredFieldChoosers )
			{
				foreach ( FieldChooser fieldChooser in registeredFieldChoosers )
				{
					fieldChooser.UpdateIsDraggingItemFromDataPresenter( );
				}
			}
		}

		#endregion // SetFieldDragManagerHelper

		#region StartFieldDragHelper

		// SSP 5/20/09 TFS17816
		// Added StartFieldDragHelper method.
		// 

		internal bool StartFieldDragHelper( Field field, MouseEventArgs e )
		{
			DependencyObject obj = e.Source as DependencyObject;
			LabelPresenter label = null != obj
				? (LabelPresenter)Utilities.GetAncestorFromType( obj, typeof( LabelPresenter ), true )
				: null;

			if ( null == label )
			{
				obj = this.InputHitTest( e.GetPosition( this ) ) as DependencyObject;
				label = null != obj
					? (LabelPresenter)Utilities.GetAncestorFromType( obj, typeof( LabelPresenter ), true )
					: null;
			}

			if ( null != label && label.Field == field && label.StartDragHelper( e, false ) )
				return true;

			return false;
		}


		#endregion // StartFieldDragHelper

		// AS 7/24/09 NA 2009.2 Field Sizing
		#region SuspendEndEditOnScroll
		internal void SuspendEndEditOnScroll()
		{
			_endEditOnScrollSuspendCount++;
		}
		#endregion //SuspendEndEditOnScroll

		#region SuspendInitializeRecordFor

		// SSP 3/3/09 TFS11407
		// Added Suspend/Resume InitializeRecordFor methods.
		// 
		/// <summary>
		/// Takes no actions if the InitializeRecord for the specified record is already suspended.
		/// </summary>
		/// <param name="record"></param>
		/// <returns>Returns true if the record was already suspended, false otherwise.</returns>
		internal bool SuspendInitializeRecordFor( Record record )
		{
			if ( null == this._initializeRecordSuspendedFor )
			{
				this._initializeRecordSuspendedFor = record;
			}
			else if ( record == this._initializeRecordSuspendedFor )
			{
				// Return true if the record is already suspended.
				// 
				return true;
			}
			else
			{
				if ( null == this._initializeRecordSuspendedFor_List )
				{
					this._initializeRecordSuspendedFor_List = new List<Record>( );
				}
				else if ( this._initializeRecordSuspendedFor_List.Contains( record ) )
					// Return true if the record is already suspended.
					// 
					return true;

				this._initializeRecordSuspendedFor_List.Add( this._initializeRecordSuspendedFor );
				this._initializeRecordSuspendedFor = record;
			}

			// Return false if the record wasn't already suspended when this method got called.
			// 
			return false;
		}

		#endregion // SuspendInitializeRecordFor

		// JJD 10/18/11 - TFS24665 - added 
		#region ToggleFocusAsync

		internal void ToggleFocusAsync()
		{
			// temporarily take to focus away from the active cell
			// JJD 02/17/12 - TFS99868
			// Move Focus() call below so we can get the textbox with focus (if there is one inside the active cell)
			//this.Focus();

			// invoke an async call to RefocusActiveCell if the active cell 
			// is in edit mode
			Cell activeCell = this.ActiveCell;

			if (activeCell != null && activeCell.IsInEditMode)
			{
				// JJD 02/17/12 - TFS99868
				// See if there is a TextBox inside the active cell's visual tree that has focus.
				// If so then gets its selectionStart and selectionLength so that we can
				// restore those values asynchronously
				int? selectionStart		= null;
				int? selectionLength	= null;
				TextBox tb = this.GetActiveCellTextBoxWithFocus();
				if (tb != null)
				{
					selectionStart = tb.SelectionStart;
					selectionLength = tb.SelectionLength;
				}

				// JJD 02/17/12 - TFS99868
				// Added selectionStart and selectionLength parameters
				//this.Dispatcher.BeginInvoke(DispatcherPriority.Render, new GridUtilities.MethodDelegate(RefocusActiveCell));
				this.Dispatcher.BeginInvoke(DispatcherPriority.Render, new RefocusActiveCellDelegate(RefocusActiveCell), selectionStart, selectionLength);
				
				// JJD 02/17/12 - TFS99868
				// now we can temporarily take to focus away from the active cell
				this.Focus();
			}

		}

		#endregion //ToggleFocusAsync	

		#region VerifyCurrentPanel

		// JJD 2/22/08 - BR30660
        // Changed method signature to return the panel so the caller doesn't need to re-get it
		//internal void VerifyCurrentPanel()
		internal Panel VerifyCurrentPanel()
		{
			if (this._currentRecordListControl == null)
				return null;

			ListBoxPanelSettings ps = DataPresenterBase.GetPanelSettings(this._currentRecordListControl);

			Panel panel = this._currentRecordListControl.Panel;

            if (panel != null)
            {
                if (ps != null && ps.Panel == panel)
                    return panel;

                if (panel != null)
                    this.CachePanelSettings(panel, this._currentRecordListControl);

            }

            return panel;
		}

		internal void VerifyCurrentPanel(object item, DependencyObject container)
		{
			if (this.CurrentPanel != null)
				return;

			Visual visual = container as Visual;

			if (visual == null)
				visual = item as Visual;

			Panel panel = null;

			if (visual != null)
				panel = Utilities.GetItemsHostFromItem(visual) as Panel;

			if (panel != null)
			{
				ListBoxPanelSettings ps = null;

				ItemsControl ic = ItemsControl.GetItemsOwner(panel);

				if (ic != null)
				{
					ps = DataPresenterBase.GetPanelSettings(ic);

					// If we haven't cached it already get the items host from the container or the item
					if (ps == null || ps.Panel == null)
						this.CachePanelSettings(panel, ic);
				}
			}
		}

		#endregion //VerifyCurrentPanel

        // JJD 7/23/09 - NA 2009 vol 2 - Enhanced grid view
        #region VerifyInternalRecords

        internal void VerifyInternalRecords()
        {
            ViewBase view = this.CurrentViewInternal;

            if (view == null)
                return;

            bool useFlattenedList = this.IsFlatView;

            ViewableRecordCollection vrc = this.ViewableRecords;
			RecordManager recordManager = this.RecordManager;

            if (useFlattenedList)
            {
                FlatScrollRecordsCollection flatList = this.InternalRecords as FlatScrollRecordsCollection;

                if (flatList != null &&
                    flatList.RecordManager == recordManager)
                    return;

                this.SetValue(InternalRecordsProperty, new FlatScrollRecordsCollection(recordManager));
            }
            else
            {
                this.SetBinding(InternalRecordsProperty, Utilities.CreateBindingObject(ViewableRecordsProperty, BindingMode.OneWay, this));
            }

        }

        #endregion //VerifyInternalRecords	

		// AS 3/10/11 NA 2011.1 - Async Exporting
		#region VerifyOperationIsAllowed
		internal bool VerifyOperationIsAllowed(RoutedEventArgs args)
		{
			UIOperation operation;

			if (args is EditModeStartingEventArgs)
				operation = UIOperation.Edit;
			else if (args is FieldPositionChangingEventArgs)
			{
				FieldPositionChangingEventArgs posChangeArgs = args as FieldPositionChangingEventArgs;
				switch (posChangeArgs.ChangeReason)
				{
					case FieldPositionChangeReason.Moved:
						operation = UIOperation.FieldMoving;
						break;
					case FieldPositionChangeReason.Hidden:
					case FieldPositionChangeReason.Displayed:
						operation = UIOperation.FieldVisibility;
						break;
					case FieldPositionChangeReason.Unfixed:
					case FieldPositionChangeReason.Fixed:
						operation = UIOperation.FieldFixing;
						break;
					default:
						Debug.Fail("Unrecognized reason:" + posChangeArgs.ChangeReason.ToString());
						return true;
				}
			}
			else if (args is GroupingEventArgs)
				operation = UIOperation.FieldGrouping;
			else if (args is RecordsDeletingEventArgs)
				operation = UIOperation.DeleteRecord;
			else if (args is RecordFixedLocationChangingEventArgs)
				operation = UIOperation.RecordFixing;
			else if (args is RecordFilterChangingEventArgs)
				operation = UIOperation.RecordFiltering;
			else if (args is RecordExpandingEventArgs || args is RecordCollapsingEventArgs)
				operation = UIOperation.RecordExpandCollapse;
			else if (args is SummarySelectionControlOpeningEventArgs)
				operation = UIOperation.FieldSummaries;
			else if (args is SortingEventArgs)
				operation = UIOperation.FieldSorting;
			else if (args is ClipboardPastingEventArgs)
				operation = UIOperation.Paste;
			else
				return true;

			if (this.VerifyOperationIsAllowed(operation))
				return true;

			// cancel the associated event
			CancelableRoutedEventArgs cancelArgs = args as CancelableRoutedEventArgs;

			if (null != cancelArgs)
				cancelArgs.Cancel = true;
			else
			{
				EditModeStartingEventArgs editStartingArgs = args as EditModeStartingEventArgs;

				if (editStartingArgs != null)
					editStartingArgs.Cancel = true;
				else
				{
					Debug.Fail("Unrecognized event args");
				}
			}

			return false;
		}

		internal bool VerifyOperationIsAllowed(UIOperation operation)
		{
			if (this.IsOperationAllowed(operation))
				return true;

			string resource = "UIOperation_" + operation.ToString();
			string message = GetString("ExportOperationDisabled_Message", GetString(resource));
			string title = GetString("ExportOperationDisabled_Title");
			MessageBox.Show(message, title, MessageBoxButton.OK, MessageBoxImage.Warning);
			return false;
		}
		#endregion //VerifyOperationIsAllowed

        // JJD 1/10/08 - BR29572 - added
        #region VerifyRecordManagerDataSource

        internal void VerifyRecordManagerDataSource()
        {
            // JJD 1/12/07 - BR29627
            // We need to wait until we are initialized before we hook up the RecordManager's DataSource
            if (!this.IsInitialized &&
                // MBS 7/29/09 - NA9.2 Excel Exporting
                // In the cases where we're not actually relying on elements in order to use the DataPresenter,
                // we don't really need to wait until we're initialized.
                (!this.IsExportControl || this.IsReportControl))
                return;

            // if the DataSource is null then set the DataSourceInternal to any items
            // that were added explicitly

            // JJD 11/21/08 - TFS6743/BR35763 
            // We don't need the _addChildCacheItemsControl to wrap our DataItems
            // we are now binding to that colleciton directly when the DataSource 
            // property is not set
            //if (this.DataSource == null &&
            //    this._addChildCacheItemsControl != null &&
            //    this._addChildCacheItemsControl.Items.Count > 0)
            //    this.SetValue(DataSourceInternalPropertyKey, this._addChildCacheItemsControl.Items);
            if (this.DataSource == null &&
                this._dataItems != null &&
                this._dataItems.Count > 0)
                this.SetValue(DataSourceInternalPropertyKey, this._dataItems);

            // set the DataSource property of the RecordManager
            // JJD 12/14/07
            // We need to cast the DataSourceInternal to IEnumerable for the record manager's DataSource property
            // This is actually safwe to do because the coerce of DataAourceInteral will always return either
            // amn IEnumerable or null.
            //this.RecordManager.DataSource = this.DataSourceInternal;
            this.RecordManager.DataSource = this.DataSourceInternal as IEnumerable;

            // JJD 1/10/08 - BR29572
            // Set the flag to true so we know to come thru here again on any change
            if (this.RecordManager.DataSource != null)
                this._isRecordManagerDataSourceInitialized = true;

			// SSP 9/9/11 Calc
			// 
			GridUtilities.NotifyCalcAdapter( this, this, "DataSource", null );
       }

        #endregion //VerifyRecordManagerDataSource	
    
		// JJD 3/15/11 - TFS65143 - Optimization
		#region WireLayoutUpdated

		// JJD 3/15/11 - TFS65143 - Optimization
		// Instead of having every element wire LayoutUpdated we can maintain a list of pending callbacks
		// and just wire LayoutUpdated on the DP
		internal void WireLayoutUpdated(GridUtilities.MethodDelegate callback)
		{
			if (_layoutUpdatedCallbacks == null)
				_layoutUpdatedCallbacks = new HashSet();

			int oldCount = _layoutUpdatedCallbacks.Count;

			_layoutUpdatedCallbacks.Add(callback);

			// when we go from 0 to 1 callback wire the event
			if (oldCount == 0)
				this.LayoutUpdated += new EventHandler(this.ProcessLayoutUpdatedCallbackList);
		}

		#endregion //WireLayoutUpdated	
        
		#endregion //Internal Methods

		#region Protected Methods

		#region GetRecordListControlStyle

		/// <summary>
		/// Gets the style for a RecordListControl created to hold items using a specific format
		/// </summary>
		/// <param name="fieldLayout">The field layout</param>
		protected internal virtual Style GetRecordListControlStyle(FieldLayout fieldLayout)
		{
			Style style = null;
			if (fieldLayout != null && fieldLayout.HasSettings)
				style = fieldLayout.Settings.RecordListControlStyle;

			if (style != null &&
				 this.HasFieldLayoutSettings)
				style = this.FieldLayoutSettings.RecordListControlStyle;

			// finally get the default style based on the look specified
			//return this.FindResourceForStylingPoint(typeof(RecordListControl)) as Style;
			return this.FindResource(typeof(RecordListControl)) as Style;
		}

		#endregion //GetRecordListControlStyle

		// JJD 8/18/20 - TFS36399 - added IWeakEventListener
		#region OnReceiveWeakEvent

		/// <summary>
		/// Called when a weak event is received
		/// </summary>
		/// <param name="managerType">The type of the weak event manager</param>
		/// <param name="sender">The source of the event</param>
		/// <param name="e">The event parameters</param>
		/// <returns></returns>
		protected virtual bool OnReceiveWeakEvent(Type managerType, object sender, EventArgs e)
		{
			if (managerType == typeof(PropertyChangedEventManager))
			{
				PropertyChangedEventArgs args = e as PropertyChangedEventArgs;

				if (args != null)
				{
					if (sender is FieldLayoutSettings)
						this.OnFieldLayoutSettingsPropertyChanged(sender, args);
					else if (sender is FieldSettings)
						this.OnFieldSettingsPropertyChanged(sender, args);

					return true;
				}
				Debug.Fail("Invalid args in ReceiveWeakEvent for DataPresenterBase, arg type: " + e != null ? e.ToString() : "null");
			}

			Debug.Fail("Invalid managerType in ReceiveWeakEvent for DataPresenterBase, type: " + managerType != null ? managerType.ToString() : "null");

			return false;
		}

		#endregion// OnReceiveWeakEvent

		#region OnSortCriteriaChanged

		private delegate void ProcessSortCriteria(FieldLayout fieldLayout);

		/// <summary>
		/// Called when the sort criteria has changed for a field layout
		/// </summary>
		/// <param name="fieldLayout">The affected field layout</param>
		internal protected virtual void OnSortCriteriaChanged(FieldLayout fieldLayout)
		{
            // JJD 12/08/08 - TFS8630
            // If we are already loaded then process the sort criteria synchronously
			if ( this.IsLoaded )
				this.OnProcessSortCriteria( fieldLayout );
			else
            {
                // JJD 2/19/09 - support for printing.
                // We can't do asynchronous operations during a report operation
                //
                // MBS 7/29/09 - NA9.2 Excel Exporting
                //if ( this.IsReportControl == false )
                if (this.IsSynchronousControl == false)
                    this.Dispatcher.BeginInvoke(DispatcherPriority.Input, new ProcessSortCriteria(this.OnProcessSortCriteria), fieldLayout);
                // MBS 8/2/09 - NA9.2 Excel Exporting
                // If we require synchronous processing, we should be calling this method now, except in the
                // case of the report control, which doesn't need this
                else if (this.IsReportControl == false)
                    this.OnProcessSortCriteria(fieldLayout);                    
            }
		}

		#endregion //OnSortCriteriaChanged

		#region GetDefaultResource

		//private object GetDefaultCellStyle(DataRecord record)
		//{
		//    return ;
		//}

		#endregion //GetDefaultResource

		#endregion //Protected Methods

		#region Private Methods

		#region AddToSelectedCollection

		private void AddToSelectedCollection(SelectedItemHolder selected, ISelectableItem item)
		{
			Debug.Assert(selected != null);

			if (item is Record)
			{
				selected.Records.InternalAdd(item as Record);
				return;
			}

			if (item is Cell)
			{
				selected.Cells.InternalAdd(item as Cell);
				return;
			}

			if (item is Field)
			{
				selected.Fields.InternalAdd(item as Field);
				return;
			}

			Debug.Fail("Invalid item type in DataPresenterBase.AddToCollection");
		}

		#endregion //AddToSelectedCollection

		#region AnimateExpandStateChange // commented out

		//private void AnimateExpandStateChange(bool expand,
		//                                    FrameworkElement fe,
		//                                    VisualBrush vb,
		//                                    Point itemOffset,
		//                                    Size itemSize,
		//                                    double overallWidth,
		//                                    double overallHeight,
		//                                    Orientation expandOrientation)
		//{
		//    this._drillAnimating = true;

		//    #region Setup the background lens animation

		//    this._expansionLensBackground.Background = vb;
		//    this._expansionLensBackgroundClipElement.Visibility = Visibility.Visible;

		//    TranslateTransform transform = new TranslateTransform();

		//    if (expand)
		//    {
		//        Utilities.AnimateTranslateTransform(transform,
		//                                        0, -itemOffset.X,
		//                                        0, -itemOffset.Y,
		//                                        ExpandRecordAnimationDuration, false, null);
		//    }
		//    else
		//    {
		//        Utilities.AnimateTranslateTransform(transform,
		//                                        -itemOffset.X, 0,
		//                                        -itemOffset.Y, 0,
		//                                        CollapseRecordAnimationDuration, false, null);
		//    }

		//    this._expansionLensBackground.RenderTransform = transform;

		//    #endregion //Setup the background lens animation

		//    #region Setup the animation for the new record presenter

		//    transform = new TranslateTransform();

		//    if (expand)
		//    {
		//        Utilities.AnimateTranslateTransform(transform,
		//                                        itemOffset.X, 0,
		//                                        itemOffset.Y, 0,
		//                                        ExpandRecordAnimationDuration, false, null);
		//    }
		//    else
		//    {
		//        Utilities.AnimateTranslateTransform(transform,
		//                                        0, itemOffset.X,
		//                                        0, itemOffset.Y,
		//                                        CollapseRecordAnimationDuration, false, null);
		//    }

		//    fe.RenderTransform = transform;

		//    // also set this on the opaque background
		//    this._opaqueBackground.RenderTransform = transform;
		//    this._opaqueBackground.Visibility = Visibility.Visible;

		//    #endregion //Setup the animation for the new record presenter

		//    #region Setup the foreground lens animation

		//    this._expansionLensForegroundInner.Width = overallWidth;
		//    this._expansionLensForegroundInner.Height = overallHeight;

		//    this._expansionLensForegroundOuter.Width = overallWidth;
		//    this._expansionLensForegroundOuter.Height = overallHeight;

		//    this._expansionLensForegroundInner.Background = vb;
		//    this._expansionLensForegroundClipElement.Visibility = Visibility.Visible;

		//    transform = null;

		//    if (expandOrientation == Orientation.Vertical)
		//        transform = new TranslateTransform(0, -(itemOffset.Y + itemSize.Height));
		//    else
		//        transform = new TranslateTransform(-(itemOffset.X + itemSize.Width), 0);

		//    this._expansionLensForegroundInner.RenderTransform = transform;

		//    transform = new TranslateTransform();

		//    if (expand)
		//    {
		//        if (expandOrientation == Orientation.Vertical)
		//        {
		//            Utilities.AnimateTranslateTransform(transform,
		//                                                0, 0,
		//                                                itemOffset.Y + itemSize.Height, overallHeight,
		//                                                ExpandRecordAnimationDuration, false, this.OnExpandAnimationCurrentStateInvalidated);
		//        }
		//        else
		//        {
		//            Utilities.AnimateTranslateTransform(transform,
		//                                                itemOffset.X + itemSize.Width, overallWidth,
		//                                                0, 0,
		//                                                ExpandRecordAnimationDuration, false, this.OnExpandAnimationCurrentStateInvalidated);
		//        }
		//    }
		//    else
		//    {
		//        if (expandOrientation == Orientation.Vertical)
		//        {
		//            Utilities.AnimateTranslateTransform(transform,
		//                                                0, 0,
		//                                                overallHeight, itemOffset.Y + itemSize.Height,
		//                                                CollapseRecordAnimationDuration, false, this.OnCollapseAnimationCurrentStateInvalidated);
		//        }
		//        else
		//        {
		//            Utilities.AnimateTranslateTransform(transform,
		//                                                overallWidth, itemOffset.X + itemSize.Width,
		//                                                0, 0,
		//                                                CollapseRecordAnimationDuration, false, this.OnCollapseAnimationCurrentStateInvalidated);
		//        }
		//    }

		//    this._expansionLensForegroundOuter.RenderTransform = transform;

		//    // also set this on the opaque foreground
		//    this._opaqueForeground.RenderTransform = transform;
		//    this._opaqueForeground.Visibility = Visibility.Visible;

		//    #endregion //Setup the foreground lens animation
		//}

		#endregion //AnimateExpandStateChange

		#region CachePanelSettings

		private void CachePanelSettings(Panel panel, ItemsControl ic)
		{
			Debug.Assert(panel != null);
			Debug.Assert(ic != null);

			if (panel == null ||
				 ic == null)
				return;

			ListBoxPanelSettings ps = new ListBoxPanelSettings();

			//ps.Layout = fieldLayout;
			ps.Panel = panel;

			DataPresenterBase.SetPanelSettings(ic, ps);

			//this.InitializePanelWithSettings(panel);
		}

		#endregion //CachePanelSettings

		#region CalculateSelectionRange

		#region CalculateSelectionRange(Cell)

		private void CalculateSelectionRange(Cell cell,
	SelectedItemHolder newSelection,
	bool clearExistingSelection,
	bool select)
		{
			if (this._pivotCell == null || cell == null)
				return;

			Record record = cell.Record;
			Record pivotRecord = this._pivotCell.Record;

			Debug.Assert(record != null);
			Debug.Assert(pivotRecord != null);

			if (record == null || pivotRecord == null)
				return;

			// FieldLayouts must be the same
			Debug.Assert(pivotRecord.FieldLayout == record.FieldLayout, "FieldLayout don't match!");

			
			
			

			RangeSelectionEvaluator evaluator = new RangeSelectionEvaluator(this._pivotCell, cell, this._snaking);
			SelectedRecordCollection records = this.GetRecordsForSelection(select, evaluator);
			SelectedFieldCollection fields = this.GetFieldsForSelection(select, evaluator);

			for (int i = 0; i < records.Count; i++)
			{
				for (int j = 0; j < fields.Count; j++)
				{
					DataRecord dr = records[i] as DataRecord;

					Debug.Assert(dr != null);

					if (dr == null)
						continue;

					Field fld = fields[j];

					// we need to test every cell and bypass
					// cells out of the range
					if (!evaluator.IsCellInRange(dr, fld, false, false))
						continue;

					Cell cellInRange = dr.Cells[fld];

					// only add cells that are selectable
					if (cellInRange != null &&
						((ISelectableItem)cellInRange).IsSelectable)
						newSelection.Cells.InternalAdd(cellInRange);
				}
			}

			if (!clearExistingSelection)
			{
				// loop over the original selection snapshot and add any
				// records that would't have already been included in the range
				foreach (Cell oldCell in this.SelectionSnapshot.Cells)
				{
					if (!evaluator.IsCellInRange(oldCell.Record, oldCell.Field, !select, false))
						newSelection.Cells.InternalAdd(oldCell);
				}

				// Copy over the selected fields also
				//
				newSelection.Fields.InternalAddRange(this.SelectedItems.Fields);
			}
		}

		#endregion //CalculateSelectionRange(Cell)

		#region CalculateSelectionRange(Field)

		private void CalculateSelectionRange(Field field,
	SelectedItemHolder newSelection,
	bool clearExistingSelection,
	bool select)
		{
			if (this._pivotField == null)
				((ISelectionHost)this).SetPivotItem(field, false);

			Debug.Assert(this._pivotField != null);

			// FieldLayouts must be the same
			Debug.Assert(this._pivotField.Owner == field.Owner, "FieldLayout don't match!");

			RangeSelectionEvaluator evaluator = new RangeSelectionEvaluator(this._pivotField, field, this._snaking);

			newSelection.Fields.InternalAddRange(this.GetFieldsForSelection(select, evaluator));

			if (!clearExistingSelection)
			{
				// loop over the original selection snapshot and add any
				// fields that would't have already been included in the range
				foreach (Field oldField in this.SelectionSnapshot.Fields)
				{
					if (!evaluator.IsFieldInRange(oldField, !select, false))
						newSelection.Fields.InternalAdd(oldField);
				}

				// Copy over the selected cells and records as well
				//
				newSelection.Cells.InternalAddRange(this.SelectedItems.Cells);
				newSelection.Records.InternalAddRange(this.SelectedItems.Records);
			}
		}

		#endregion //CalculateSelectionRange(Field)

		#region CalculateSelectionRange(Record)

		private void CalculateSelectionRange(Record record,
	SelectedItemHolder newSelection,
	bool clearExistingSelection,
	bool select)
		{
			if (this._pivotRecord == null)
				((ISelectionHost)this).SetPivotItem(record, false);

			Debug.Assert(this._pivotRecord != null);

			// FieldLayouts must be the same
			Debug.Assert(this._pivotRecord.FieldLayout == record.FieldLayout, "FieldLayout don't match!");

			// Parent records must be the same
			Debug.Assert(this._pivotRecord.ParentRecord == record.ParentRecord, "Parent records don't match!");

			RangeSelectionEvaluator evaluator = new RangeSelectionEvaluator(this._pivotRecord, record, this._snaking);

			newSelection.Records.InternalAddRange(this.GetRecordsForSelection(select, evaluator));

			if (!clearExistingSelection)
			{
				// loop over the original selection snapshot and add any
				// records that would't have already been included in the range
				foreach (Record oldRecord in this.SelectionSnapshot.Records)
				{
					if (!evaluator.IsRecordInRange(oldRecord, !select, false))
						newSelection.Records.InternalAdd(oldRecord);
				}

				// Copy over the selected fields also
				//
				newSelection.Fields.InternalAddRange(this.SelectedItems.Fields);
			}
		}

		#endregion //CalculateSelectionRange(Record)

		#endregion //CalculateSelectionRange

		#region CalculateScrollOffsetFactorInRecords

		private double CalculateScrollOffsetFactorInRecords(ScrollSpeed speed, double viewportExtent)
		{

			switch (speed)
			{
				//case ScrollSpeed.Fastest:
				//    return 3.0;
				case ScrollSpeed.Fast:
					return 2.0;
				default:
					return 1.0;
			}
		}

		#endregion //CalculateScrollOffsetFactorInRecords

		#region CalculateScrollOffsetFactorInPixels

		private double CalculateScrollOffsetFactorInPixels(ScrollSpeed speed, double viewportExtent)
		{

			switch (speed)
			{
				case ScrollSpeed.Slowest:
					return 2.0;
				case ScrollSpeed.Slower:
					return 8.0;
				case ScrollSpeed.Slow:
					return 16.0;
				case ScrollSpeed.Medium:
					return 30.0;
				case ScrollSpeed.Fast:
					return Math.Max(35, Math.Min(50.0, viewportExtent / 5));
				case ScrollSpeed.Faster:
					return Math.Max(40, Math.Min(100.0, viewportExtent / 4));
				case ScrollSpeed.Fastest:
				default:
					return Math.Max(50, Math.Min(200.0, viewportExtent / 3));
			}
		}

		#endregion //CalculateScrollOffsetFactorInPixels

		// AS 6/9/09 NA 2009.2 Field Sizing
		#region CanAutoSizeField
		private bool CanAutoSizeField(ExecuteCommandInfo commandInfo)
		{
			Field f = commandInfo.Parameter as Field;

			return null != f && f.AutoSizeOptionsResolved != FieldAutoSizeOptions.None;
		}
		#endregion //CanAutoSizeField

		// AS 1/12/11 TFS59619
		#region CanExecuteUndoCommand
		private bool CanExecuteUndoCommand(ExecuteCommandInfo commandInfo)
		{
			if (!this.IsUndoEnabled)
			{
				commandInfo.ContinueRouting = true;
				return false;
			}

			if (_history == null)
				return false;

			if (commandInfo.Command == DataPresenterCommands.Undo)
				return _history.CanUndo();
			else if (commandInfo.Command == DataPresenterCommands.Redo)
				return _history.CanRedo();

			return false;
		}
		#endregion //CanExecuteUndoCommand

        // AS 6/3/09 NA 2009.2 Undo/Redo
		#region CanToggleIsExpanded
		/// <summary>
		/// Helper method to determine 
		/// </summary>
		/// <param name="commandInfo">Provides information about the command whose can execute is being determined.</param>
		private static bool CanToggleIsExpanded(ExecuteCommandInfo commandInfo)
		{
			Record record = GetRecord(commandInfo);
			return null != record;
		}
		#endregion //CanToggleIsExpanded

		// JM 11/5/09 NA 2010.1 CardView
		#region CanToggleCardCollapsedState
		/// <summary>
		/// Helper method to determine if a Card's collapsed state can be toggled.
		/// </summary>
		/// <param name="commandInfo">Provides information about the command whose can execute is being determined.</param>
		private static bool CanToggleCardCollapsedState(ExecuteCommandInfo commandInfo)
		{
			Record record = GetRecord(commandInfo);
			return null != record;
		}
		#endregion //CanToggleCardCollapsedState

		// JM 11/5/09 NA 2010.1 CardView
		#region CanToggleEmptyCardCellsCollapsedState
		/// <summary>
		/// Helper method to determine if a Card's empty cells collapsed state can be toggled.
		/// </summary>
		/// <param name="commandInfo">Provides information about the command whose can execute is being determined.</param>
		private static bool CanToggleEmptyCardCellsCollapsedState(ExecuteCommandInfo commandInfo)
		{
			Record record = GetRecord(commandInfo);
			return null != record;
		}
		#endregion //CanToggleEmptyCardCellsCollapsedState

		// JJD 7/19/07 - BR22682
		// Added CommitChangesToRecord helper method to support new EndEditModeAndCommitRecord command
		#region CommitChangesToRecord

		private void CommitChangesToRecord(DataRecord record)
		{
			if (record == null || !record.IsDataChanged)
				return;

			bool isAddReordWithDataItem = record.IsAddRecord &&
											  !record.IsAddRecordTemplate;

			// SSP 8/10/07 BR25635
			// Only proceed if the Update call succeeded.
			// 
			//record.Update();
			//if (isAddReordWithDataItem)
			if ( record.Update( ) && isAddReordWithDataItem )
			{
                // JJD 7/22/08 - BR34098
                // Make sure we don't have any pending invalidations
                if (this._invalidateGeneratedStylesPending)
                    this.OnInvalidateGeneratedStyles();
                
                // JJD 3/4/07
				// Call updatLayout  to make sure the visual tree matches the control state
				// before calling EnsureRecordIsVisible
				this.UpdateLayout();

				IViewPanel pnlNavigator = this.CurrentPanel as IViewPanel;

				Debug.Assert(pnlNavigator != null);

				if (pnlNavigator != null)
					pnlNavigator.EnsureRecordIsVisible(record);
			}
		}

		#endregion //CommitChangesToRecord	

		#region EnsureItemsWithinMaxSelectedItemsBounds



#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)

		private void EnsureItemsWithinMaxSelectedItemsBounds(ISelectableItem item, SelectedItemHolder newSelection)
		{
			if (item is Record)
			{
				FieldLayout fl = ((Record)item).FieldLayout;

				int maxSelectedRecords = fl.MaxSelectedRecordsResolved;

				if (newSelection.Records.Count > maxSelectedRecords)
				{
					for (int i = newSelection.Records.Count - 1; i >= maxSelectedRecords; i--)
					{
						newSelection.Records.RemoveAt(i);
					}
				}
			}
			else if (item is Cell)
			{
				FieldLayout fl = ((Cell)item).Record.FieldLayout;

				int maxSelectedCells = fl.MaxSelectedCellsResolved;

				if (newSelection.Cells.Count > maxSelectedCells)
				{
					for (int i = newSelection.Cells.Count - 1; i >= maxSelectedCells; i--)
					{
						newSelection.Cells.RemoveAt(i);
					}
				}
			}
		}

		#endregion //EnsureItemsWithinMaxSelectedItemsBounds

		// JJD 02/17/12 - TFS99868 - added
		#region GetActiveCellTextBoxWithFocus

		private TextBox GetActiveCellTextBoxWithFocus()
		{
			Cell activeCell = this.ActiveCell;

			if (activeCell == null)
				return null;

			CellValuePresenter cvp = activeCell.AssociatedCellValuePresenterInternal;

			if (cvp != null && cvp.IsKeyboardFocusWithin)
			{
				DependencyObject elementWithFocus = FocusManager.GetFocusedElement(FocusManager.GetFocusScope(this)) as DependencyObject;

				if (elementWithFocus != null)
				{
					if (elementWithFocus is TextBox)
						return elementWithFocus as TextBox;
					else
						return Utilities.GetAncestorFromType(elementWithFocus, typeof(TextBox), true, cvp) as TextBox;
				}
			}

			return null;
		}

		#endregion //GetActiveCellTextBoxWithFocus	
    
		// AS 6/26/09 NA 2009.2 Field Sizing
		#region GetAllResizableFieldItems
		/// <summary>
		/// Helper method to generate a list of layout items that should be resized when a resize or autosize operation is performed.
		/// </summary>
		/// <param name="panel">The virtualizing panel that contains the layout items</param>
		/// <param name="field">The source field</param>
		/// <param name="isLabel">True if the user was dealing with the label of the field; false if they were dealing with the cell value presenter</param>
		/// <param name="resizeInXAxis">True if the resize is horizontal; false if its vertical</param>
		/// <param name="autoSize">True if this list is being generated for an autosize operation. In that case the list will contain 
		/// the source item and all selected items or the adjacent items if nothing in the field layout is selected or the 
		/// source is not selected. False if this list is for a resize operation. In that case, if the field is not selected 
		/// or there are no selected fields then an empty list will be returned. The list will only contain items if the 
		/// user is resizing a selected fields and there are other selected fields.</param>
		/// <returns></returns>
		internal IList<FieldLayoutItemBase> GetAllResizableFieldItems(VirtualizingDataRecordCellPanel panel, Field field, bool isLabel, bool resizeInXAxis, bool autoSize)
		{
			return GetAllResizableFieldItems(panel.GetResizeLayoutManager(), field, isLabel, resizeInXAxis, autoSize);
		}

		internal IList<FieldLayoutItemBase> GetAllResizableFieldItems(FieldGridBagLayoutManager lm, Field field, bool isLabel, bool resizeInXAxis, bool autoSize)
		{
			bool isResize = !autoSize;
			bool hasSelectedFields = this.SelectedItems.HasFields && this.SelectedItems.Fields[0].Owner == field.Owner;
			bool sourceIsSelected = field.IsSelected;

			// for a resize operation we only need to build a list if there are multiple selected fields and 
			// the source field is selected.
			if (isResize && (!sourceIsSelected || !hasSelectedFields || this.SelectedItems.Fields.Count == 1))
				return null;

			FieldLayoutItemBase referenceItem = lm.GetLayoutItem(field, isLabel);

			Debug.Assert(null != referenceItem);

			if (referenceItem == null)
				return null;

			List<FieldLayoutItemBase> layoutItems = new List<FieldLayoutItemBase>();
			IGridBagConstraint referenceGc = lm.LayoutItems.GetConstraint(referenceItem) as IGridBagConstraint;
			Debug.Assert(referenceGc != null);
			int end = resizeInXAxis ? referenceGc.Column + referenceGc.ColumnSpan : referenceGc.Row + referenceGc.RowSpan;
			LayoutItemSize size = resizeInXAxis ? LayoutItemSize.PreferredWidth : LayoutItemSize.PreferredHeight;

			// in the case where we are autosizing and labels are within the record then we want
			// to base whether we honor both layout items in all the selected cells on where the label
			// is with respect to the cell in the source item
			bool isSourceSynchronized = FieldLayoutItemBase.ShouldSynchronize(size, field);

			// at this point we should be here if we:
			// * resize multiple selected fields in which case we want a list of the layout items that are label or not depending on the source isLabel
			// * autosizing a non-selected field in which case we want a list of the layout items whose right edge is in line with the source item
			// * autosizing a selected field in which case we want a list of the layout items for selected fields
			//
			foreach (Field f in field.Owner.Fields)
			{
				if (f.IsInLayout == false || f.AllowResizeResolved == false)
					continue;

				// skip fields that cannot be autosized
				if (autoSize && f.AutoSizeOptionsResolved == FieldAutoSizeOptions.None)
					continue;

				// when there are selected fields and the end user is acting 
				// on a selected field then we should only consider the selected fields
				if (sourceIsSelected && hasSelectedFields && !f.IsSelected)
					continue;

				for (int i = 0; i < 2; i++)
				{
					bool itemIsLabel = i == 0;
					FieldLayoutItemBase layoutItem = lm.GetLayoutItem(f, itemIsLabel);

					if (null == layoutItem)
						continue;

					if (isResize)
					{
						// for a resize operation we don't want the source in the list
						if (layoutItem == referenceItem)
							continue;

						// for a synchronized resize operation just resize the label or cell of the 
						// other selected fields based on what the user is resizing in the source item
						if (isLabel != itemIsLabel)
							continue;
					}
					else // autosize
					{
						// for an autosize operation we always want the source item in the list
						if (layoutItem != referenceItem)
						{
							// for other elements it depends...
							IGridBagConstraint layoutItemGc = lm.LayoutItems.GetConstraint(layoutItem) as IGridBagConstraint;
							int itemEnd = resizeInXAxis ? layoutItemGc.Column + layoutItemGc.ColumnSpan : layoutItemGc.Row + layoutItemGc.RowSpan;

							// if we're autosizing the selected fields....
							if (sourceIsSelected && f.IsSelected)
							{
								// if the cell and label are synchronized in the source item then we will
								// include the cell and label of all the selected items regardless of whether 
								// they line up. otherwise we will only include the similar item (label or cell)
								// in the other selected items unless it happens to share a trailing edge with 
								// the source item
								if (!isSourceSynchronized && isLabel != itemIsLabel && itemEnd != end)
								{
									continue;
								}
							}
							else if (itemEnd != end)
							{
								// in a non-selected source item situation we only want to consider
								// the items whose edge is in line with the source item
								continue;
							}
						}
					}

					layoutItems.Add(layoutItem);
				}
			}

			return layoutItems;
		}
		#endregion //GetAllResizableFieldItems

		#region GetCompatibleSelectableElement

		private ISelectableElement GetCompatibleSelectableElement(ISelectableItem item, DependencyObject element)
		{
			// if the element implements ISelectableElement then return it
			if (element is ISelectableElement)
			{
				ISelectableItem selectableItem = (element as ISelectableElement).SelectableItem;

				if (!((ISelectionHost)this).IsItemSelectableWithCurrentSelection(selectableItem))
				{
					// since we don't want to walk up thru nested records return false
					if (item is Record)
						return null;
				}
				else
				{
					if (item is Record)
					{
						if (selectableItem is Record)
							return element as ISelectableElement;
					}
					else
						if (item is Field)
						{
							if (selectableItem is Field)
								return element as ISelectableElement;
						}
						else
							if (item is Cell)
							{
								if (selectableItem is Cell)
									return element as ISelectableElement;
							}
				}
			}

			// if the element is the root then stop the parent chain walk and return null
			if (element == this)
				return null;

			// get the visual parent
			// JJD 8/23/07
			// Call the safer GetParent method that will tolerate FrameworkContentElements
			//DependencyObject parent = VisualTreeHelper.GetParent(element);
			DependencyObject parent = Utilities.GetParent(element);

			if (parent == null)
				return null;

			// call this method recursively to walk up the parent chain
			return this.GetCompatibleSelectableElement(item, parent);
		}

		#endregion //GetCompatibleSelectableElement

		#region GetCompatibleRecordPresenter

		private RecordPresenter GetCompatibleRecordPresenter(ISelectableItem item, DependencyObject element)
		{
			if (item is Field)
				return null;

			RecordPresenter rp = element as RecordPresenter;

			if (rp == null)
				rp = Utilities.GetAncestorFromType(element as Visual, typeof(RecordPresenter), true, this) as RecordPresenter;

			if (rp != null && rp.Record != null)
			{
				// return the record presenter only if it is a sibling of the passed in item
				if (item is Record)
				{
					if (rp.Record.IsSiblingOf(item as Record))
						return rp;
				}
				else
					if (item is Cell)
					{
						if (rp.Record.IsSiblingOf((item as Cell).Record))
							return rp;
					}
			}

			return null;
		}

		#endregion //GetCompatibleRecordPresenter

		#region GetDefaultStyle

		private Style GetDefaultStyle(Type type)
		{
			
#region Infragistics Source Cleanup (Region)














#endregion // Infragistics Source Cleanup (Region)

			return null;
		}

		#endregion //GetDefaultStyle

		#region GetFieldsForSelection

		private SelectedFieldCollection GetFieldsForSelection(bool select, RangeSelectionEvaluator evaluator)
		{
			SelectedFieldCollection fields = new SelectedFieldCollection(this);

			// if thi is a range selection of cells then return every field
			// since every cell will have to be tested
			if (evaluator.IsRangeOfCells)
			{
				fields.InternalAddRange(evaluator.PivotField.Owner.Fields);
				return fields;
			}

			bool excludePivot = evaluator.IsRangeOfFields && !select;

			foreach (Field field in evaluator.PivotField.Owner.Fields)
			{
				// bypass fields that are not in range
				if (!evaluator.IsFieldInRange(field, excludePivot, false))
					continue;

				// if we are selecting cells then always include the field,
				// otherwise add it if it is selectable
				if (evaluator.IsRangeOfCells || ((ISelectableItem)field).IsSelectable)
					fields.InternalAdd(field);
			}

			return fields;
		}

		#endregion //GetFieldsForSelection

		#region GetFieldLayoutForSelectableItem

		private static FieldLayout GetFieldLayoutForSelectableItem(ISelectableItem item)
		{
			if (item is Record)
				return (item as Record).FieldLayout;
			if (item is Cell)
				return (item as Cell).Record.FieldLayout;
			if (item is Field)
				return (item as Field).Owner;

			return null;

		}

		#endregion //GetFieldLayoutForSelectableItem

		// JJD 03/08/12 - TFS101199 - Added touch support
		#region GetFirstItemExtentHelper


		private double GetFirstItemExtentHelper(bool isWidth)
		{
			ViewBase view = this.CurrentViewInternal;
			if (false == view.IsPanningModeSupported ||
				false == view.HasLogicalOrientation)
				return DEFAULT_RECORD_HEIGHT;

			if (isWidth)
			{
				if (view.LogicalOrientation == Orientation.Vertical)
					return DEFAULT_RECORD_HEIGHT;
			}
			else
			{
				if (view.LogicalOrientation == Orientation.Horizontal)
					return DEFAULT_RECORD_HEIGHT;
			}

			IViewPanel panel = this.CurrentPanel as IViewPanel;

			if (panel == null)
				return DEFAULT_RECORD_HEIGHT;

			Record rcd = panel.GetFirstDisplayedRecord(typeof(DataRecord));

			if (rcd == null)
			{
				rcd = panel.GetFirstDisplayedRecord(typeof(Record));

				if (rcd == null)
					return DEFAULT_RECORD_HEIGHT;
			}

			RecordPresenter rp = rcd.AssociatedRecordPresenter;

			// JJD 04/03/12 - TFS107578
			// If we don't have an rp then return the cached extent of the record we returned last time
			if (rp == null)
				return isWidth ? _previousFirstItemWidth : _previousFirstItemHeight;

			double extent = isWidth ? rp.ActualWidth : rp.ActualHeight;

			if (extent == 0)
				extent = isWidth ? rp.DesiredSize.Width : rp.DesiredSize.Height;

			if (extent < 10)
				extent = DEFAULT_RECORD_HEIGHT;

			// JJD 04/03/12 - TFS107578
			// Cache the extent in case we don't have an rp on the next call to this method (see above)
			if (isWidth)
				_previousFirstItemWidth = extent;
			else
				_previousFirstItemHeight = extent;

			return extent;
		}


		#endregion //GetFirstItemExtentHelper	
    
		#region GetGroupByAndDataAreaRows

		private void GetGroupByAndDataAreaRows(ref int groupByAreaRow, ref int dataAreaRow)
		{
			if (this.GroupByAreaLocation == GroupByAreaLocation.BelowDataArea)
			{
				groupByAreaRow = 1;
				dataAreaRow = 0;
			}
			else
			{
				groupByAreaRow = 0;
				dataAreaRow = 1;
			}
		}

		#endregion //GetGroupByAndDataAreaRows

		#region GetNavigationTargetCell

		private Cell GetNavigationTargetCell(Cell currentCell, PanelNavigationDirection navigationDirection, ISelectionHost selectionHost, bool shiftKeyDown, bool ctlKeyDown, PanelSiblingNavigationStyle siblingNavigationStyle)
		{
			// Validate parameters.
			if (currentCell == null)
				throw new ArgumentNullException("currentRecord");
			if (selectionHost == null)
				throw new ArgumentNullException("selectionHost");


			// Get the selection strategy
			SelectionStrategyBase selectionStrategy = selectionHost.GetSelectionStrategyForItem(currentCell as ISelectableItem);

			Debug.Assert(selectionStrategy != null);
			if (selectionStrategy == null)
				throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_4"));


			FieldLayoutTemplateGenerator styleGenerator = currentCell.Record.FieldLayout.StyleGenerator;
			Cell targetCell = styleGenerator.GridFieldMap.GetNavigationTargetCell(currentCell,
									  navigationDirection,
									  this.CurrentPanel as IViewPanel,
									  selectionHost,
									  shiftKeyDown,
									  ctlKeyDown,
									  siblingNavigationStyle);


			if (targetCell != null)
			{
				if (selectionStrategy.CanItemBeNavigatedTo(targetCell, shiftKeyDown, ctlKeyDown) == true)
					return targetCell;
			}


			return null;
		}

		#endregion //GetNavigationTargetCell

		#region GetNearestCompatibleCell

		private Cell GetNearestCompatibleCell(ISelectableItem item, Point pt)
		{
			// if we don't have a pivotCell cell then get out
			if (this._pivotCell == null)
				return null;

			Debug.Assert(item is Cell);

			if (!(item is Cell))
				return null;

			// AS 4/12/11 TFS62951
			// Refactored/rewrote this routine to handle looking for fields as well as 
			// cells but mainly to selectively ignore fixed fields.
			//
			#region Refactored
			
#region Infragistics Source Cleanup (Region)













































































































































































































































































































#endregion // Infragistics Source Cleanup (Region)

			#endregion // Refactored
			Record record;
			Field field;
			this.GetNearestCompatibleField(item, pt, _pivotCell.Field, _pivotCell.Record, true, null, out record, out field);

			if (record is DataRecord == false || field == null)
				return null;

			// JJD 10/26/11 - TFS91364 
			// Ignore HeaderReords 
			if (record is HeaderRecord)
				return null;

			return ((DataRecord)record).Cells[field];
		}

		#endregion //GetNearestCompatibleCell

		// AS 4/12/11 TFS62951
		// Added a helper routine so we could find the nearest field the way we do for cells.
		//
		#region GetNearestCompatibleField(ISelectableItem, Point, RecordPresenter)
		private Field GetNearestCompatibleField(ISelectableItem item, Point pt, RecordPresenter rp)
		{
			// if we don't have a pivotCell cell then get out
			if (this._pivotField == null)
				return null;

			Debug.Assert(item is Field);

			if (!(item is Field))
				return null;

			Record nearestRecord;
			Field nearestField;
			Record pivotRecord = null;

			if (!this.GetNearestCompatibleField(item, pt, _pivotField, pivotRecord, false, rp, out nearestRecord, out nearestField))
			{
				if (!this.GetNearestCompatibleField(item, pt, _pivotField, pivotRecord, true, rp, out nearestRecord, out nearestField))
				{
					return null;
				}
			}

			return nearestField;
		}
		#endregion //GetNearestCompatibleField(ISelectableItem, Point, RecordPresenter)

		// AS 4/12/11 TFS62951
		// Added a common helper routine for finding the nearest cell/field.
		//
		#region GetNearestCompatibleField(ISelectableItem, Point, Field, Record, bool, RecordPresenter, out Record, out Field)
		private bool GetNearestCompatibleField(ISelectableItem item, Point pt, Field pivotField, Record pivotRecord, bool cells, RecordPresenter rp, out Record nearestRecord, out Field nearestField)
		{
			nearestField = null;
			nearestRecord = null;

			// if we don't have a pivotCell cell then get out
			if (pivotField == null)
				return false;

			// this is similar to what we used to do in the getnearestcompatiblecell but we'll give predence to a record 
			// presenter if one is provided. this is needed because the LastFieldLabelAccessed that is stored by the 
			// field may be released in which case we wouldn't have a relative record from which to work
			DataRecordPresenter drp = rp as DataRecordPresenter ?? this.GetNearestCompatibleRecordPresenter(item, pt) as DataRecordPresenter;

			VirtualizingDataRecordCellPanel cellPanel = GridUtilities.GetCellPanel(drp, !cells);

			if (cellPanel == null)
				return false;

			Rect bounds = cellPanel.GetInViewRect();

			if (bounds.IsEmpty)
				return false;

			Point relativePoint = this.TransformToDescendant(cellPanel).Transform(pt);

			if (relativePoint.X < bounds.X)
				relativePoint.X = bounds.X;
			else if (relativePoint.X >= bounds.Right)
				relativePoint.X = bounds.Right - 1;

			if (relativePoint.Y < bounds.Y)
				relativePoint.Y = bounds.Y;
			else if (relativePoint.Y >= bounds.Bottom)
				relativePoint.Y = bounds.Bottom - 1;

			nearestField = cellPanel.GetNearestCompatibleField(item, relativePoint, pivotField, pivotRecord);

			if (null != nearestField)
				nearestRecord = drp.Record;

			return nearestField != null;
		}

		#endregion //GetNearestCompatibleField(ISelectableItem, Point, Field, Record, bool, RecordPresenter, out Record, out Field)

		#region GetNearestCompatibleRecordPresenter

		private RecordPresenter GetNearestCompatibleRecordPresenter(ISelectableItem item, Point pt)
		{
			RecordPresenter rp = null;
			Record pivotRcd = this._pivotRecord;

			// get the pivot record
			if (item is Cell)
			{
				if (this._pivotCell != null)
					pivotRcd = this._pivotCell.Record;
			}
			else
				if (item is Field)
				{
					if (this._pivotField != null)
					{
						// AS 4/12/11 TFS62951
						// The LastFieldLabelAccessed would return null if the label was recycled. Moved the property to the field layout.
						//
						//rp = Utilities.GetAncestorFromType(this._pivotField.LastFieldLabelAccessed, typeof(RecordPresenter), true, this) as RecordPresenter;
						if (_pivotField.Owner != null)
							rp = Utilities.GetAncestorFromType(_pivotField.Owner.LastSelectableItemLabel, typeof(RecordPresenter), true, this) as RecordPresenter;

						if (rp != null)
						{
							pivotRcd = rp.Record;

							// AS 4/12/11 TFS62951
							// If this is a header record then the parent collection will be some unused collection.
							//
							if (pivotRcd is HeaderRecord)
								pivotRcd = ((HeaderRecord)pivotRcd).AttachedToRecord;
						}
					}
				}

			// if we are looking for a field label we need to look no further
			if (item is Field)
			{
				if (pivotRcd != null)
					return pivotRcd.AssociatedRecordPresenter;

				return null;
			}

			// if we don't have a pivotRcd record then get out
			if (pivotRcd == null)
				return null;

			// AS 5/6/09 Selection across field layouts
			FieldLayout fl = pivotRcd.FieldLayout;

			IViewPanelInfo info = this;

			// get the current top record
			Record topRecord = info.GetRecordAtOverallScrollPosition(info.OverallScrollPosition);

			if (topRecord == null)
				return null;

			// see if the top record's parent chain contains a sibling 
			// of the of the pivot record 
			Record siblingRecord = topRecord.GetRecordInParentChainContainedInCollection(pivotRcd.ParentCollection);

			if (siblingRecord == null)
			{
				ViewableRecordCollection vrc = this.ViewableRecords;

				int scrollCount = vrc.ScrollCount;
				int scrollIndex = topRecord.OverallScrollPosition + 1;

				while (siblingRecord == null && scrollIndex < scrollCount)
				{
					// get the record at the next scrollindex
					Record rcd = vrc.GetRecordAtScrollPosition(scrollIndex);

					if (rcd != null)
					{
						Debug.Assert(scrollIndex == rcd.OverallScrollPosition);

						// if the record doesn't have asscoiated record presenter
						// then it isn't visible
						if (rcd.AssociatedRecordPresenter == null)
							break;

						// see if there is a record in its parent chain that is a 
						// sibling of the pivot record
						siblingRecord = rcd.GetRecordInParentChainContainedInCollection(pivotRcd.ParentCollection);
					}


					// bump the index and try again
					scrollIndex++;
				}
			}

			if (siblingRecord == null)
				return null;

			rp = siblingRecord.AssociatedRecordPresenter;

			if (rp == null)
				return null;

			double smallestDelta = double.NaN;
			double delta;
			RecordPresenter closestRp = null;

			ViewBase currentView = this.CurrentViewInternal;
			if (currentView.HasLogicalOrientation)
			{
				closestRp = rp;

				ViewableRecordCollection vrc = this.ViewableRecords;

				int scrollCount = vrc.ScrollCount;
				int scrollIndex = siblingRecord.OverallScrollPosition + 1;

				while (rp != null && scrollIndex <= scrollCount)
				{
					Point ptLeftTop = rp.TranslatePoint(new Point(0, 0), this);
					Point ptRightBottom = rp.TranslatePoint(new Point(rp.ActualWidth, rp.ActualHeight), this);

					// AS 5/6/09 Selection across field layouts
					// We should skip/ignore records from a different field layout. Otherwise when 
					// you try to do a range selection and the next mouse move is when you are over 
					// a record of a different field layout but there are other records before that
					// we end up returning an invalid/incompatible rp.
					//
					if (rp.FieldLayout == fl)
					{
						if (currentView.LogicalOrientation == Orientation.Vertical)
						{
							if (pt.Y >= ptLeftTop.Y &&
								pt.Y <= ptRightBottom.Y)
								return rp;

							if (pt.Y < ptLeftTop.Y)
								delta = ptLeftTop.Y - pt.Y;
							else
								delta = pt.Y - ptRightBottom.Y;
						}
						else
						{
							if (pt.X >= ptLeftTop.X &&
								pt.X <= ptRightBottom.X)
								return rp;

							if (pt.X < ptLeftTop.X)
								delta = ptLeftTop.X - pt.X;
							else
								delta = pt.X - ptRightBottom.X;
						}

						Debug.Assert(delta >= 0.0);

						// see if this is the smallest delta, if so keep
						// track of the record presenter
						if (double.IsNaN(smallestDelta) ||
							delta < smallestDelta)
						{
							smallestDelta = delta;
							closestRp = rp;
						}
					}

					if (scrollIndex == scrollCount)
						break;

					// get the record at the next scrollindex
					Record rcd = vrc.GetRecordAtScrollPosition(scrollIndex);

					if (rcd == null)
						break;

					Debug.Assert(scrollIndex == rcd.OverallScrollPosition);

					// if the record doesn't have asscoiated record presenter
					// then it isn't visible
					if (rcd.AssociatedRecordPresenter == null)
						break;

					// see if there is a record in its parent chain that is a 
					// sibling of the pivot record
					siblingRecord = rcd.GetRecordInParentChainContainedInCollection(pivotRcd.ParentCollection);

					if (siblingRecord != null)
						rp = siblingRecord.AssociatedRecordPresenter;
					else
						rp = null;

					// bump the index and try again
					scrollIndex++;
				}
			}

			return closestRp;
		}

		#endregion //GetNearestCompatibleRecordPresenter

		// AS 6/3/09 NA 2009.2 Undo/Redo
		#region GetRecord
		private static Record GetRecord(ExecuteCommandInfo commandInfo)
		{
			Record record = commandInfo.Parameter as Record;

			if (null == record && commandInfo.Parameter == null)
			{
				DependencyObject source = commandInfo.OriginalSource as DependencyObject;

				if (null != source)
				{
					RecordPresenter rp = source as RecordPresenter ?? Utilities.GetAncestorFromType(source, typeof(RecordPresenter), true) as RecordPresenter;

					if (null != rp)
						record = rp.Record;
				}
			}

			return record;
		}
		#endregion //GetRecord

		#region GetRecordsForSelection

		private SelectedRecordCollection GetRecordsForSelection(bool select, RangeSelectionEvaluator evaluator)
		{
			SelectedRecordCollection records = new SelectedRecordCollection(this);

			Record pivotRcd = evaluator.PivotRecord;
			Record record = evaluator.EndOfRangeRecord;

			long position = record.OverallSelectionPosition;
			long positionPivotItem = pivotRcd.OverallSelectionPosition;

			
			
			

			// AS 5/6/09 Selection across field layouts
			// We should skip/ignore records from a different field layout. We don't allow it 
			// when you programatically manipulate the selection.
			//
			FieldLayout fl = pivotRcd.FieldLayout;

			// JJD 1/10/12 - TFS99025 
			// Cache the nestingDepth
			int nestingDepth = pivotRcd.NestingDepth;
			
			Debug.Assert(fl == record.FieldLayout, "Field layouts must match for pivot rcd and target rcd");
			Debug.Assert(nestingDepth == record.NestingDepth, "Nesting depth must match for pivot rcd and target rcd");


			if (position != positionPivotItem && select)
			{
				// JJD 1/10/12 - TFS99025 
				// Refactored logic to allow for range selection of records across parents
				//int startIndex = pivotRcd.Index;
				//int stopIndex = record.Index;
				//int step;

				//// if position of clicked-on item is > than pivotRcd item, we want to
				//// start at the pivotRcd item and get the next item until we reach the
				//// clicked on item, otherwise we get the previous item
				//if (position > positionPivotItem)
				//{
				//    startIndex++;
				//    stopIndex++;
				//    step = 1;
				//}
				//else
				//{
				//    startIndex--;
				//    stopIndex--;
				//    step = -1;
				//}

				//RecordCollectionBase parentColleciton = pivotRcd.ParentCollection;

				//int count = parentColleciton.Count;

				//for (int i = startIndex; i != stopIndex && i >= 0 && i < count; i += step)
				//{
				//    Record sibling = parentColleciton[i];

				//    // AS 5/6/09 Selection across field layouts
				//    if (sibling.FieldLayout == fl)
				//    {
				//        if (((ISelectableItem)sibling).IsSelectable
				//            // SSP 10/23/09 TFS23670
				//            // Only select the record if its visible. If a record is filtered out
				//            // and range selection is taking place then skip the non-visible records.
				//            // 
				//            && Visibility.Visible == sibling.VisibilityResolved
				//           )
				//            records.InternalAdd(sibling);
				//    }

				//    // when we reach the clicked-on item (ourself), break
				//    if (sibling == record)
				//        break;
				//} 

				// JJD 1/10/12 - TFS99025 
				// Create an enumerator which will return sibling rcds between the pivot rcd and the target record
				// (not including the pivot)
				Record candidate;
				RecordSelectionEnumerator enumerator = new RecordSelectionEnumerator(record, pivotRcd, position > positionPivotItem);
				while (enumerator.MoveNext())
				{
					candidate = enumerator.Current as Record;

					// JJD 1/10/12 - TFS99025 
					// Make aure the FieldLayout and NestingDepth match and the record is selectable
					if (candidate != null &&
						 candidate.FieldLayout == fl &&
						 candidate.NestingDepth == nestingDepth)
					{
						if (((ISelectableItem)candidate).IsSelectable
							// SSP 10/23/09 TFS23670
							// Only select the record if its visible. If a record is filtered out
							// and range selection is taking place then skip the non-visible records.
							// 
							&& Visibility.Visible == candidate.VisibilityResolved
						   )
							records.InternalAdd(candidate);
					}
				}
				
			}

			if (select || evaluator.IsRangeOfCells)
			{
				// JJD 1/17/11 - TFS61465
				// Only insert the pivotRcd if it is selectable
				if ( pivotRcd.IsSelectable )
					records.InternalInsert(0, pivotRcd);
			}

			return records;
		}

		#endregion //GetRecordsForSelection
		
		// JJD 03/08/12 - TFS101199 - Added touch support for scrolling
		#region GetScrollValueHelper


		private static double GetScrollValueHelper(double actualValue, ref double? cachedValue)
		{
			if (cachedValue.HasValue)
			{
				
				return cachedValue.Value;

				
			}

			return actualValue;
		}

		#endregion //GetScrollValueHelper	
   
		#region GetMinExtent
        
#region Infragistics Source Cleanup (Region)



















#endregion // Infragistics Source Cleanup (Region)

		#endregion //GetMinExtent

		#region InitializeRecordManagerDataSource

        private void InitializeRecordManagerDataSource()
        {
            // JJD 1/10/08 - BR29572
            // Only bail if we haven't already initialized the 
            // record mananger's data source 
			//if (this._contentSiteGrid == null)
			if (this._contentSiteGrid == null &&
                this._isRecordManagerDataSourceInitialized == false)
				return;

            // JJD 1/10/08 - BR29572
            // MOved logic to VerifyRecordManagerDataSource
            #region Old code

            //// if the DataSource is null then set the DataSourceInternal to any items
            //// that were added explicitly
            //if (this.DataSource == null &&
            //    this._addChildCacheItemsControl != null &&
            //    this._addChildCacheItemsControl.Items.Count > 0)
            //    this.SetValue(DataSourceInternalPropertyKey, this._addChildCacheItemsControl.Items);

            //// set the DataSource property of the RecordManager
            //// JJD 12/14/07
            //// We need to cast the DataSourceInternal to IEnumerable for the record manager's DataSource property
            //// This is actually safwe to do because the coerce of DataAourceInteral will always return either
            //// amn IEnumerable or null.
            ////this.RecordManager.DataSource = this.DataSourceInternal;
            //this.RecordManager.DataSource = this.DataSourceInternal as IEnumerable;

            #endregion //Old code
            this.VerifyRecordManagerDataSource();

			// make sure the ItemsPanel is initialized too
			this.InitializeItemsPanel();
		}

		#endregion //InitializeRecordManagerDataSource

		#region InitializeRecordListControlPanel

		private ItemsPanelTemplate InitializeRecordListControlPanel(RecordListControl rlc, Type panelType)
		{
			ItemsPanelTemplate template = new ItemsPanelTemplate();

			FrameworkElementFactory fefPanel = new FrameworkElementFactory(panelType);

			template.VisualTree = fefPanel;

			fefPanel.SetBinding(DataPresenterBase.DataPresenterProperty, Utilities.CreateBindingObject("", BindingMode.OneTime, this));

			// JM 01-29-09 BR33445 [TFS6021]
			//fefPanel.SetBinding(Panel.BackgroundProperty, Utilities.CreateBindingObject(DataPresenterBase.BackgroundProperty, BindingMode.OneWay, this));

			fefPanel.SetBinding(DataPresenterBase.CurrentViewProperty, Utilities.CreateBindingObject("", BindingMode.OneTime, this.CurrentViewInternal));

			// AS 3/17/11 NA 2011.1 - Async Exporting
			// The RecordListControl is not in the grid with the group by areas so we 
			// don't need to do this. To avoid major churn I'm going to put the status 
			// control into this panel so the row for the RLC will always be 1.
			//
			//// Determine positions of GroupByArea and DataAreas.
			//int groupByAreaRow = 0;
			//int dataAreaRow = 1;
			//this.GetGroupByAndDataAreaRows(ref groupByAreaRow, ref dataAreaRow);
			//
			//Grid.SetRow(rlc, dataAreaRow);
			Grid.SetRow(rlc, 1);

			// JM 01-29-09 BR33445 [TFS6021]
			//rlc.SetBinding(RecordListControl.BackgroundProperty, Utilities.CreateBindingObject(DataPresenterBase.BackgroundProperty, BindingMode.OneWay, this));

			// get and apply the appropriate style for this RecordListControl
			Style style = this.GetRecordListControlStyle(this.DefaultFieldLayout);
			if (style != null)
				rlc.Style = style;

            // JJD 3/6/08 - BR31101
            // Access the count property of the ViewableRecords so that any special records
            // get created, e.g add record, summary rcds etc.
            int count = this.ViewableRecords != null ? this.RecordManager.ViewableRecords.Count : 0;

            // JJD 3/28/08
            // Don't bind the recordlistControl's datasource if this is a report scenario it will be done in the
            // BeginPagination method of IEmbeddedVisualPaginator.
            //
            // MBS 7/29/09 - NA9.2 Excel Exporting
            // Don't set this if it's an exporting control at all.  The ReportControl will set this property as it needs to
            //if (!this.IsReportControl)
            if(!this.IsExportControl)
            {
                // JJD 7/23/09 - NA 2009 vol 2 - Enhanced grid view
                // Bind to the InternalRecords property but first make sure that it is ssetup properly
                //rlc.SetBinding(ItemsControl.ItemsSourceProperty, Utilities.CreateBindingObject(ViewableRecordsProperty, BindingMode.OneWay, this));
                this.VerifyInternalRecords();
                rlc.SetBinding(ItemsControl.ItemsSourceProperty, Utilities.CreateBindingObject(InternalRecordsProperty, BindingMode.OneWay, this));
            }
			//            rlc.SetBinding(ItemsControl.ItemsSourceProperty, Utilities.CreateBindingObject(RecordsProperty, BindingMode.OneWay, this));
			//            rlc.SetBinding(ListBox.ItemContainerStyleSelectorProperty, Utilities.CreateBindingObject(DataPresenterBase.InternalRecordContainerStyleSelectorProperty, BindingMode.OneWay, this));
			//            rlc.SetBinding(ListBox.ItemTemplateSelectorProperty, Utilities.CreateBindingObject(DataPresenterBase.InternalItemTemplateSelectorProperty, BindingMode.OneWay, this));

			this.ReplaceDataAreaContent(rlc);

			return template;
		}

		#endregion //InitializeRecordListControlPanel

		// JJD 4/28/11 - TFS73523 - added 
		#region InitializeSpacingOnResizeController

		private void InitializeSpacingOnResizeController()
		{
			if ( this._resizeController == null ) 
				return;

			ViewBase view = this.CurrentViewInternal;

			if (view == null)
				return;

			this._resizeController.InterItemSpacingX = view.InterRecordSpacingX;
			this._resizeController.InterItemSpacingY = view.InterRecordSpacingY;
		}

		#endregion //InitializeSpacingOnResizeController

		// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
		#region ApplyAsyncCommand

		private void ApplyAsyncCommand(AsyncPageCommand apc)
		{
			if (apc != this._asyncCommand)
				return;

			this._asyncCommand = null;

			if (!this.IsLoaded || !this.IsVisible)
				return;

			RoutedCommand command = apc.Command;

			// Select/Activate the appropriate record. 
			this.SelectFirstOrLastDisplayedRecord(command == DataPresenterCommands.RecordPageAbove ||
												  command == DataPresenterCommands.RecordPageLeft, false, false);

		}

		#endregion //ApplyAsyncCommand	
    
		// MD 5/26/10 - ChildRecordsDisplayOrder feature
		#region OnChildRecordsDisplayOrderChanged

		internal void OnChildRecordsDisplayOrderChanged()
		{
			this.BumpScrollCountRecalcVersion();

			// MD 7/8/10 - TFS35511
			// It looks like this was a copy-paste error. I kept this method call here because I assumed it was needed,
			// but when it looked into it, all it did was clear the group by. But when the child record display order 
			// changes, we don't need to clear the group by.
			//this.OnFormatSettingsInvalidated();

			this.UpdateScrollBarVisibility();
		} 

		#endregion // OnChildRecordsDisplayOrderChanged

		#region OnCollapseAnimationCurrentStateInvalidated // commented out

		//private void OnCollapseAnimationCurrentStateInvalidated(object sender, EventArgs e)
		//{
		//    if (((AnimationClock)sender).CurrentState != ClockState.Active)
		//    {
		//        ((AnimationClock)sender).CurrentStateInvalidated -= new EventHandler(this.OnExpandAnimationCurrentStateInvalidated);

		//        DrillDownStackItem newTopOfStack = null;

		//        if ( this._drillDownStack.Count > 0)
		//             newTopOfStack = this._drillDownStack.Peek();

		//        if (newTopOfStack != null)
		//        {
		//            newTopOfStack.RecordPresenter.InitializeNestedContent(this._currentRecordListControl, Orientation.Vertical);
		//        }
		//        else
		//        {
		//            // If this is the first drilldown then we have to replace the data area
		//            // element in the _contentSiteGrid
		//            this.ReplaceDataAreaContent(this._currentRecordListControl);
		//        }

		//        this.ProcessDrillActionQueue();
		//    }
		//}

		#endregion //OnExpandAnimationCurrentStateInvalidated

		#region OnCurrentViewStateChanged

		private void OnCurrentViewStateChanged(object sender, ViewStateChangedEventArgs e)
		{
			switch (e.Action)
			{
				case ViewStateChangedAction.InvalidateArrange:
					this.InvalidateArrange();
					break;
				case ViewStateChangedAction.InvalidateFieldLayouts:
					// SSP 8/4/09 - NAS9.2 Enhanced grid view
					// If UseNestedPanels changes then we need to dirty the scroll count since
					// expandable field's OccupiesScrollPosition gets affected.
					// 
					this.BumpScrollCountRecalcVersion( );

					this.OnFormatSettingsInvalidated();

					// JJD 4/28/11 - TFS73523 - added 
					this.InitializeSpacingOnResizeController();
					break;
				case ViewStateChangedAction.InvalidateMeasure:
					this.InvalidateMeasure();
					// JJD 4/28/11 - TFS73523 - added 
					this.InitializeSpacingOnResizeController();
					break;
				case ViewStateChangedAction.InvalidateRender:
					this.InvalidateVisual();
					// JJD 4/28/11 - TFS73523 - added 
					this.InitializeSpacingOnResizeController();
					break;
			}

			// JJD 3/26/07
			// Update the horz and vert scrollbar visibility properties
			this.UpdateScrollBarVisibility();
		}

		#endregion //OnCurrentViewStateChanged

		#region OnExpandAnimationCurrentStateInvalidated // commented out

		//private void OnExpandAnimationCurrentStateInvalidated(object sender, EventArgs e)
		//{
		//    if (((AnimationClock)sender).CurrentState != ClockState.Active)
		//    {
		//        ((AnimationClock)sender).CurrentStateInvalidated -= new EventHandler(this.OnExpandAnimationCurrentStateInvalidated);

		//        this.ProcessDrillActionQueue();
		//    }
		//}

		#endregion //OnExpandAnimationCurrentStateInvalidated

        // JJD 7/21/08 - BR34098 - Optimization - added
        #region OnInvalidateGeneratedStyles

        private void OnInvalidateGeneratedStyles()
        {
            if (this._invalidateGeneratedStylesPending)
            {
                this.InvalidateGeneratedStyles(true, false);
                this._invalidateGeneratedStylesPending = false;
            }
        }

        #endregion //OnInvalidateGeneratedStyles	
    
        // JJD 3/16/09 - Optimization
        #region OnLayoutUpdated

        // Process the queue of record presenters that are waiting to
        // have their nested content initailiazed
		// JJD 3/15/11 - TFS65143 - Optimization
		// Instead of having every element wire LayoutUpdated we can maintain a list of pending callbacks
		// and just wire LayoutUpdated on the DP
		//private void OnLayoutUpdated(object sender, EventArgs e)
		private void OnLayoutUpdated()
        {
			// JJD 3/15/11 - TFS65143 - Optimization
			// No need to unhook since the DP is maintaining the callback list and automatically removes the entry
			// unhook the event
			//this.LayoutUpdated -= new EventHandler(OnLayoutUpdated);

            Queue<RecordPresenter> queue = this._recordsPendingNestedContentInitialization;

			// AS 6/26/09 NA 2009.2 Field Sizing
			// Added if block. We can now get in here for other reasons as well - e.g. having 
			// to ensure that the field layouts that are waiting for the initial autosize
			// have processed their request by now to avoid flicker on screen.
			//
			if (queue != null)
			{
				this._recordsPendingNestedContentInitialization = null;

				while (queue.Count > 0)
				{
					RecordPresenter rp = queue.Dequeue();

					if (rp.IsVisible)
						rp.InitializeNestedDataContent();
				}

				Debug.Assert(this._recordsPendingNestedContentInitialization == null);

				RecyclingItemsPanel panel = this.CurrentPanel as RecyclingItemsPanel;

				// on the main panel get rid of any deactivated containers
				if (panel != null)
				{
					// JJD 4/09/12 - TFS108549
					// If RecordContainerRetentionMode is true then call VerifyAllDeactivatedContainers
					// instead of RemoveAllDeactivatedContainers so that alny valid containers
					// will be reatined
					bool discard = false;
					switch (this.RecordContainerRetentionMode)
					{
						case DataPresenter.RecordContainerRetentionMode.RetainDeactivatedContainers:
							break;
						case DataPresenter.RecordContainerRetentionMode.RetainDeactivatedContainersUntilResize:
							{
								ViewBase view = this.CurrentViewInternal;

								if (view.HasLogicalOrientation)
								{
									double scrollDimensionExtent = view.LogicalOrientation == Orientation.Vertical ? this.ActualHeight : this.ActualHeight;

									// if the use has resize smaller then we wabt to discard the deativated containers
									if (scrollDimensionExtent < _lastScrollDimensionExtent)
										discard = true;

									// save the extent for the next time layout updated
									_lastScrollDimensionExtent = scrollDimensionExtent;
								}

								break;
							}

						case DataPresenter.RecordContainerRetentionMode.DiscardDeactivatedContainers:
						default:
							// always discard the deactivated containers
							discard = true;
							break;
					}

					// discard the deactivated containers if necessary
					if ( discard )
						panel.RemoveAllDeactivatedContainers();

				}
			}

			// AS 6/26/09 NA 2009.2 Field Sizing
			this.ProcessPendingAutoSizeOperations();
        }

        #endregion //OnLayoutUpdated	
    
		// JM BR31380 4-30-08
		#region OnUnloaded

        void OnUnloaded(object sender, RoutedEventArgs e)
        {
			// JM 02-03-09 TFS11415 - we only need to do this loaded/unloaded dance if we are on a Page that has also been unloaded.
			Page page = Utilities.GetAncestorFromType(this, typeof(Page), true) as Page;
			if (page != null && page.IsLoaded == false)
			{
				this.Unloaded	-= new RoutedEventHandler(OnUnloaded);
				this.Loaded		+= new RoutedEventHandler(OnLoaded);
			}

			// SSP 4/13/12 TFS108549 - Optimizations
			// If scrolling timer is running, stop it.
			// 
			if ( null != _isScrollingTimer && _isScrollingTimer.IsEnabled )
				this.ProcessIsScrollingTimerTick( );

            // JJD 1/29/09 - TFS11223
            // This Unload logic is no longer needed and has the negative effect
            // of causing delays when the control is on a tab that is being
            // made active after it shown and another tab was shown
            //// JM 09-18-08 [BR34645 TFS6228] 
            //if (this.CurrentRecordListControl != null)
            //{
            //    RecyclingItemsPanel rip = this.CurrentRecordListControl.Panel as RecyclingItemsPanel;
            //    if (rip != null)
            //    {
            //        rip.DeactivateAllContainers();
            //        rip.RemoveAllDeactivatedContainers();
            //    }
            //}
        }

		#endregion //OnUnloaded	
    
		// JM BR31380 4-30-08
		#region OnLoaded

		void OnLoaded(object sender, RoutedEventArgs e)
		{
			this.Loaded		-= new RoutedEventHandler(OnLoaded);
            this.Unloaded += new RoutedEventHandler(OnUnloaded);

			this.RefreshFieldLayout();
		}

		#endregion //OnLoaded	
    
		// AS 8/7/09 NA 2009.2 Field Sizing
		#region OnPerformFieldAutoSize
		/// <summary>
		/// Callback used to process the measurement of autosized fields if we don't get a layoutupdated in time.
		/// </summary>
		/// <param name="parameter">Not used</param>
		/// <returns>Returns null</returns>
		private object OnPerformFieldAutoSize(object parameter)
		{
			this.ProcessPendingAutoSizeOperations();
			return null;
		}
		#endregion //OnPerformFieldAutoSize

		#region OnProcessSortCriteria

		private void OnProcessSortCriteria(FieldLayout fieldLayout)
		{
			// JM 12-22-09 TFS25883
			//// MBS 8/2/09 - NA9.2 Excel Exporting
			//// If we're exporting, we won't actually end up ever creating a RecordListControl, but we shouldn't
			//// bail out here since we need to maintain the correct ViewableRecordsCollection
			////
			////if (this._currentRecordListControl == null ||
			//if ((this._currentRecordListControl == null && !(this.IsExportControl && !this.IsReportControl)) ||
			//    this._recordManager == null ||
			//    this._recordManager.Unsorted.Count < 1)
			//    return;
			if ((this._currentRecordListControl == null && !(this.IsExportControl && !this.IsReportControl)) ||
				this._recordManager == null)
				return;

			int groupbyVersion = 0;

			if (this.DefaultFieldLayout != null && this.DefaultFieldLayout.HasSortedFields)
				groupbyVersion = this.DefaultFieldLayout.SortedFields.GroupbyVersion;
            
            // JJD 2/19/09 - TFS13979
            // Bump the overall sort version
            this.BumpOverallSortVersion();

			if (groupbyVersion != this._groupbyVersion)
			{
				this._groupbyVersion = groupbyVersion;

				////TODO: add more smarts to avoid blowing away the drill down here
				//this.DrillUpToRecord(null, true);

				//this.ClearItemsHost();

				//// if we are in a groupby situation we always want to use a VirtualizingStackPanel
				//if (this.DefaultFieldLayout.SortedFields.CountOfGroupByFields > 0)
				//{
				//    this._currentRecordListControl = new RecordListControl(this);
				//    ItemsPanelTemplate template = this.InitializeRecordListControlPanel(this._currentRecordListControl, typeof(VirtualizingStackPanel));

				//    this._currentRecordListControl.SetValue(ItemsControl.ItemsPanelProperty, template);
				//}
				//else
				//{
				//    this._currentRecordListControl = this._rootRecordListControl;

				//    // Determine positions of GroupByArea and DataAreas.
				//    int groupByAreaRow = 0;
				//    int dataAreaRow = 1;
				//    this.GetGroupByAndDataAreaRows(ref groupByAreaRow, ref dataAreaRow);

				//    Grid.SetRow(this._currentRecordListControl, dataAreaRow);

				//    this.ReplaceDataAreaContent(this._currentRecordListControl);
				//}

				// JJD 3/11/07
				// Reset the scroll position after a group change
				((IViewPanelInfo)this).OverallScrollPosition = 0;

				this._recordManager.VerifySort();
			}
			else
			{
				this._recordManager.VerifySort();
			}
		}

		#endregion //OnProcessSortCriteria

		// AS 3/23/10 TFS23753 - added
		#region OnRequestBringIntoView
		private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs e)
		{
			if (e.OriginalSource == sender && e.TargetRect.IsEmpty)
			{
				DataPresenterBase dp = sender as DataPresenterBase;

				// AS 3/23/10 TFS23753
				// In IGControlBase when the OnPreviewMouseDown is caught we set keyboard focus on the 
				// grid itself if it does not contain the keyboard focus. The FrameworkElement class will 
				// in the base impl of OnGotFocus request that the element be brought into view when it 
				// gets focus passing along an empty rect. So when the grid is within a scrollviewer, this 
				// is causing the grid to request to be brought into view which alters the position that you 
				// clicked upon. The scrollviewer queues that request. When the cell gets the request bring 
				// into view it first calls UpdateLayout at which point the scrollviewer processes the 
				// queued requests which scrolls the grid (all within the previewmousedown). Then when the 
				// mousedown comes through its for a different element as a result of the scrollviewer 
				// trying to scroll the grid into view. So what we will do is if during the preview 
				// mouse down we get a request by the grid to have it entirely brought into view then we
				// will assume its coming from the ongotfocus logic and try to determine which relative 
				// element you are clicking on that should be brought into view.
				//
				// we only do this logic if we get an empty rect request during the 
				// previewmousedown logic as we're just trying to offset the frameworkelement's
				// behavior of scrolling the element into view during the time that 
				// we are processing a mouse down because we don't want the element that you're 
				// clicking upon to shift within the scrollviewer that contains the grid
				if (dp._previewMouseDownArgs != null)
				{
					Point mousePos = dp._previewMouseDownArgs.GetPosition(dp);
					dp._previewMouseDownArgs = null;
					DependencyObject d = dp.InputHitTest(mousePos) as DependencyObject;

					if (null != d)
					{
						#region Find the relevant element being clicked upon
						while (d is ContentElement)
							d = LogicalTreeHelper.GetParent(d);

						DependencyObject firstFocusableElement = null;

						while (d != null)
						{
							if (d is CellValuePresenter)
								break;
							else if (d is LabelPresenter)
								break;
							else if (d is CellPresenterBase)
								break;
							else if (d is RecordCellAreaBase)
								break;
							else if (d is RecordPresenter)
								break;
							else if (d is GroupByAreaBase)
								break;
							else if (d == dp)
								break;

							if (firstFocusableElement == null)
							{
								IInputElement inputElement = d as IInputElement;

								if (inputElement != null && inputElement.Focusable)
									firstFocusableElement = d;
							}

							d = Utilities.GetParent(d, false);
						}

						if (d == null)
							d = firstFocusableElement;
						#endregion //Find the relevant element being clicked upon

						#region Make a new request if needed
						UIElement element = d as UIElement;

						if (element != null && element != dp)
						{
							GeneralTransform gt = element.TransformToAncestor(dp);

							if (null != gt)
							{
								// find out the rect of the element relative to the grid
								Rect childRect = gt.TransformBounds(new Rect(element.RenderSize));

								// only use the portion of the element that is visible within the 
								// grid itself. if the grid needs to scroll that element into view 
								// (e.g. when the cell is activated) then it will deal with that 
								// but otherwise the grid and the scroll viewer could try to scroll 
								// based on the entire rect of the target element including what 
								// is not in view
								childRect.Intersect(new Rect(dp.RenderSize));

								if (!childRect.IsEmpty)
								{
									dp.BringIntoView(childRect);
								}
							}
						}
						#endregion //Make a new request if needed
					}

					// if you click into an empty area or an area that isn't focusable
					// we'll still eat the message because we don't want the whole grid 
					// being scrolled into view
					e.Handled = true;
				}
			}
		}
		#endregion //OnRequestBringIntoView

		#region OnScrollViewerScrollChanged
		private static void OnScrollViewerScrollChanged(object sender, RoutedEventArgs e)
		{
			DataPresenterBase dp = sender as DataPresenterBase;

			if (null != dp)
			{
				dp.ScrollVersion++;
			}
		}
		#endregion //OnScrollViewerScrollChanged

		// JJD 04/13/12 - TFS108986 - Optimization
		#region OnSuspendSummaryCalcsTimerTick

		private void OnIsScrollingTimerTick(object sender, EventArgs e)
		{
			this.ProcessIsScrollingTimerTick( );
		}

		private void ProcessIsScrollingTimerTick( )
		{
			_isScrollingTimer.Stop();
			this.SetValue(IsScrollingPropertyKey, KnownBoxes.FalseBox);
		}

		#endregion //OnSuspendSummaryCalcsTimerTick	
    
		#region ProcessDrillActionQueue // commented out

		//private void ProcessDrillActionQueue()
		//{
		//    this._drillAnimating = false;

		//    this._expansionLensBackgroundClipElement.Visibility = Visibility.Hidden;
		//    this._expansionLensBackgroundClipElement.RenderTransform = null;
		//    this._expansionLensBackgroundClipElement.RenderTransformOrigin = new Point(0,0);
		//    this._expansionLensForegroundClipElement.Visibility = Visibility.Hidden;
		//    this._expansionLensForegroundClipElement.RenderTransform = null;
		//    this._expansionLensBackgroundClipElement.RenderTransformOrigin = new Point(0,0);
		//    this._expansionLensForegroundClipElement.Clip = null;
		//    this._expansionLensBackground.RenderTransform = null;
		//    this._expansionLensForegroundInner.RenderTransform = null;
		//    this._expansionLensForegroundOuter.RenderTransform = null;
		//    this._opaqueBackground.Visibility = Visibility.Hidden;
		//    this._opaqueBackground.RenderTransform = null;
		//    this._opaqueBackground.RenderTransformOrigin = new Point(0, 0);
		//    this._opaqueForeground.Visibility = Visibility.Hidden;
		//    this._opaqueForeground.RenderTransform = null;
		//    this._opaqueForeground.RenderTransformOrigin = new Point(0, 0);
		//    if ( this._drillDownStack.Count > 0 )
		//        this._drillDownStack.Peek().RecordPresenter.RenderTransform = null;

		//    if (this._drillActionQueue.Count > 0)
		//    {
		//        // copy the queued items into an array and clear the queue
		//        DrillActionItem[] queuedItems = new DrillActionItem[this._drillActionQueue.Count];

		//        this._drillActionQueue.CopyTo(queuedItems, 0);
		//        this._drillActionQueue.Clear();

		//        // perform all the actions in the order that they were queued and
		//        // pass true in as the immediate parameter for all but the last item
		//        for (int i = 0; i < queuedItems.Length; i++)
		//        {
		//            if (queuedItems[i].Expand)
		//                this.DrillDownToRecord(queuedItems[i].Record, i < queuedItems.Length - 1);
		//            else
		//                this.DrillDownToRecord(queuedItems[i].Record, i < queuedItems.Length - 1);
		//        }
		//    }
		//}

		#endregion //ProcessDrillActionQueue

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region ProcessPendingAutoSizeOperations
		/// <summary>
		/// Helper method used by the layoutupdate and dispatcher callbacks to trigger an autosize measure operation.
		/// </summary>
		private void ProcessPendingAutoSizeOperations()
		{
			if (!GridUtilities.HasItems(_fieldLayoutsAutoSizePending))
				return;

			if (_processingFieldAutoSize)
				return;

			_processingFieldAutoSize = true;

			try
			{
				// we also need to traverse any cached items where we had where a field layout may have 
				// existed as a lower level
				AutoSizeFieldLayoutInfo.WalkAllRecordItems(_fieldLayoutsAutoSizePending);

				AutoSizeFieldLayoutInfo.TransferViewableRecords(_fieldLayoutsAutoSizePending);

				// first make sure the scroll count is updated so we can log viewable record requests...
				int scrollCount = this.ViewableRecords.ScrollCount;

				// if this is called from layout updated then we should terminate the async callback
				if (_pendingFieldAutoSize != null && _pendingFieldAutoSize.Status == DispatcherOperationStatus.Pending)
					_pendingFieldAutoSize.Abort();

				// now that we have verified the scroll count we can get the pending operations
				List<FieldLayout> fieldLayouts = _fieldLayoutsAutoSizePending;
				_fieldLayoutsAutoSizePending = null;

				// AS 3/2/11 66934 - AutoSize
				// Pass along a helper object that will allow us to only get the records 
				// in view once for a given operation.
				//
				//AutoSizeFieldLayoutInfo.ProcessPendingOperations(fieldLayouts);
				RecordsInViewHelper recordsInViewHelper = new RecordsInViewHelper(this);
				AutoSizeFieldLayoutInfo.ProcessPendingOperations(fieldLayouts, recordsInViewHelper);
			}
			finally
			{
				_processingFieldAutoSize = false;

				// now we can clear the dispatcher operation
				_pendingFieldAutoSize = null;
			}

			// if we have had any pending operations posting during the processing then 
			// we need to start another delayed callback to process those operations
			this.SetupAsyncAutoSize();
		}
		#endregion //ProcessPendingAutoSizeOperations

		#region ProcessResize
        
#region Infragistics Source Cleanup (Region)























#endregion // Infragistics Source Cleanup (Region)

		#endregion //ProcessResize

		#region RaiseCellsInViewChangedAsyncHelper

		// SSP 2/1/10
		// Added CellsInViewChanged event to the DataPresenterBase.
		// 

		internal void RaiseCellsInViewChangedAsyncHelper( )
		{
			if ( _pendingRaiseCellsInViewChangedAsyncHelperHandler || ! this.ShouldRaiseCellsInViewChanged )
				return;

			Dispatcher dispatcher = this.Dispatcher;
			if ( null != dispatcher )
			{
				dispatcher.BeginInvoke( DispatcherPriority.Background,
					new GridUtilities.MethodDelegate( this.RaiseCellsInViewChangedAsyncHelperHandler ) );
				
				_pendingRaiseCellsInViewChangedAsyncHelperHandler = true;
			}
		}

		private void RaiseCellsInViewChangedAsyncHelperHandler( )
		{
			_pendingRaiseCellsInViewChangedAsyncHelperHandler = false;

			if ( this.ShouldRaiseCellsInViewChanged )
				VisibleDataBlock.RaiseCellsInViewChanged( this );
		}

		#endregion // RaiseCellsInViewChangedAsyncHelper

		// JJD 10/18/11 - TFS24665 - added 
		#region RefocusActiveCell

		// JJD 02/17/12 - TFS99868 - added
		private delegate void RefocusActiveCellDelegate(int? selectionStart, int? selectionLength);

		// JJD 02/17/12 - TFS99868
		// Added selectionStart and selectionLength parameters
		//private void RefocusActiveCell()
		private void RefocusActiveCell(int? selectionStart, int? selectionLength)
		{
			Cell activeCell = this.ActiveCell;

			// set focus back to the active cell if the dp still has the focus
			if (activeCell != null && this.IsFocused)
			{
				activeCell.FocusIfActive();

				// JJD 02/17/12 - TFS99868
				// See if there is stil a textbox in the cell's visual tree
				// that now has fcus. If so restore the passed in 
				// selectionStart and selectionLength values
				TextBox tb = GetActiveCellTextBoxWithFocus();

				if (tb != null)
				{
					if (selectionStart.HasValue)
						tb.SelectionStart = selectionStart.Value;
					
					if (selectionLength.HasValue)
						tb.SelectionLength = selectionLength.Value;

				}
			}
		}

		#endregion //RefocusActiveCell	

		// JM BR31380 4-30-08
		#region RefreshFieldLayout

		private void RefreshFieldLayout()
		{
			FieldLayout fl = this.DefaultFieldLayout;

			if (fl != null)
			{
                // JJD 5/5/09 - NA 2009 vol 2 - Cross band grouping 
                // Bump the sort versions for all fieldlayouts
                
                
                
                
                this.FieldLayouts.BumpSortVersions();

				// JM 12-02-08 TFS10879
				this.InvalidateGeneratedStylesAsync();
			}
		}

		#endregion //RefreshFieldLayout	
    
		#region RemoveFromSelectedCollection

		private void RemoveFromSelectedCollection(SelectedItemHolder selected, ISelectableItem item)
		{
			Debug.Assert(selected != null);

			if (item is Record)
			{
				selected.Records.Remove(item as Record);
				return;
			}

			if (item is Cell)
			{
				selected.Cells.Remove(item as Cell);
				return;
			}

			if (item is Field)
			{
				selected.Fields.Remove(item as Field);
				return;
			}

			Debug.Fail("Invalid item type in DataPresenterBase.RemoveFromCollection");
		}

		#endregion //RemoveFromSelectedCollection

		#region ReplaceDataAreaContent

		private void ReplaceDataAreaContent(FrameworkElement newDataAreaContent)
		{
			int index = this._dataAreaGrid.Children.IndexOf(this._contentSiteDataAreaContent);

			// remove the old content
			if (index >= 0)
				this._dataAreaGrid.Children.Remove(this._contentSiteDataAreaContent);

			this._contentSiteDataAreaContent = newDataAreaContent;

			// Insert the replacement content
			if (index >= 0)
				this._dataAreaGrid.Children.Insert(index, this._contentSiteDataAreaContent);
		}

		#endregion //ReplaceDataAreaContent

		#region ResizeField
        
#region Infragistics Source Cleanup (Region)












































































#endregion // Infragistics Source Cleanup (Region)

		#endregion //ResizeField

		#region ResizeFieldAutoFit
        
#region Infragistics Source Cleanup (Region)





























































































































































































































































































#endregion // Infragistics Source Cleanup (Region)

		#endregion //ResizeFieldAutoFit

		// JJD 3/1/11 - TFS66934 - Optimization - re-factored selection logic
		#region SelectFirstOrLastDisplayedRecord

		private void SelectFirstOrLastDisplayedRecord(bool first, bool shiftKeyDown, bool ctlKeyDown)
		{
			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;

			if (panelNavigator == null)
				return;

			Record recordToSelect;
			if (first)
				recordToSelect = panelNavigator.GetFirstDisplayedRecord(typeof(Record));
			else
				recordToSelect = panelNavigator.GetLastDisplayedRecord(typeof(Record));

			if (recordToSelect != null)
			{
				SelectionStrategyBase selectionStrategy = ((ISelectionHost)this).GetSelectionStrategyForItem(recordToSelect);
				if (selectionStrategy != null)
					selectionStrategy.SelectItemViaKeyboard(recordToSelect, shiftKeyDown, ctlKeyDown, false);
			}
		}

		#endregion //SelectFirstOrLastDisplayedRecord	

		// AS 8/7/09 NA 2009.2 Field Sizing
		#region SetupAsyncAutoSize
		private void SetupAsyncAutoSize()
		{
			// if we are in the middle of processing pending operations then do not start 
			// a delayed callback. instead wait until we are done processing those to trigger 
			// the delayed operation
			if (_processingFieldAutoSize)
				return;

			// if there are no pending operations we don't have to start anything
			if (_fieldLayoutsAutoSizePending == null || _fieldLayoutsAutoSizePending.Count == 0)
				return;

			// if we're already waiting then exit
			if (_pendingFieldAutoSize != null)
				return;

			// wait for the callback or layoutupdated - whichever happens first
			_pendingFieldAutoSize = this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new DispatcherOperationCallback(OnPerformFieldAutoSize), null);

			// JJD 3/15/11 - TFS65143 - Optimization
			// Instead of having every element wire LayoutUpdated we can maintain a list of pending callbacks
			// and just wire LayoutUpdated on the DP
			//EventHandler layoutHandler = new EventHandler(OnLayoutUpdated);
			//// unhook just in case we hooked in for a different reason
			//this.LayoutUpdated -= layoutHandler;
			//this.LayoutUpdated += layoutHandler;
			this.WireLayoutUpdated(this.OnLayoutUpdated);
		}
		#endregion //SetupAsyncAutoSize

		#region ShouldResizeSiblingField

		private bool ShouldResizeSiblingField(FrameworkElement resizableItem, DataItemPresenter siblingFieldItem, bool resizeInXAxis, ref Field.FieldGridPosition targetPosition, ref Field.FieldGridPosition siblingPosition)
		{
			bool shouldResize = false;
			bool ensureEnclose = false;

			if (resizeInXAxis)
			{
				// return true if both items end at the same column 
				if (siblingPosition.Column + siblingPosition.ColumnSpan ==
					targetPosition.Column + targetPosition.ColumnSpan)
				{
					shouldResize = true;
				}
				else
				{
					// also return true if the sibling item totally encloses the target item 
					if (siblingPosition.Column <= targetPosition.Column &&
						siblingPosition.Column + siblingPosition.ColumnSpan > targetPosition.Column + targetPosition.ColumnSpan)
					{
						shouldResize = true;
						ensureEnclose = true;
					}
				}
			}
			else
			{
				// return true if both items end at the same row 
				if (siblingPosition.Row + siblingPosition.RowSpan ==
					targetPosition.Row + targetPosition.RowSpan)
				{
					shouldResize = true;
				}
				else
				{
					// also return true if the sibling item totally encloses the target item 
					if (siblingPosition.Row <= targetPosition.Row &&
						siblingPosition.Row + siblingPosition.RowSpan > targetPosition.Row + targetPosition.RowSpan)
					{
						shouldResize = true;
						ensureEnclose = true;
					}
				}
			}


			// make sure the sibling item should be resized based on its actual relative position
			if (shouldResize)
			{
				if (!ensureEnclose)
					return true;

				// Create 2 points to respresent the position of the element being resized
				Point leftTop = new Point();
				Point rightBottom = new Point(resizableItem.ActualWidth, resizableItem.ActualHeight);

				// translate 2 points to respresenting the position of the sibling being tested
				// into corrdinates releative to the element being resized
				Point leftTopSibling = siblingFieldItem.TranslatePoint(new Point(), resizableItem);
				Point rightBottomSibling = siblingFieldItem.TranslatePoint(new Point(siblingFieldItem.ActualWidth, siblingFieldItem.ActualHeight), resizableItem);

				// only return true if the sibling item totally encases the item being resized 
				if (resizeInXAxis)
					return leftTopSibling.X <= leftTop.X && rightBottomSibling.X >= rightBottom.X;
				else
					return leftTopSibling.Y <= leftTop.Y && rightBottomSibling.Y >= rightBottom.Y;
			}

			return false;
		}

		#endregion //ShouldResizeSiblingField
    
        // JJD 12/14/07
        #region UnwireDataSourceRootList

        private void UnwireDataSourceRootList()
        {
            // if the cached list is null then return
            if (this._dataSourceRootList == null || this._dataSourceRootListChangeListener == null)
                return;

           // if the list supports INotifyCollectionChanged remove us as a listener
            if (this._dataSourceRootList is INotifyCollectionChanged)
                CollectionChangedEventManager.RemoveListener(this._dataSourceRootList as INotifyCollectionChanged, this._dataSourceRootListChangeListener);

            // if the list supports IBindingList remove us as a listener
            if (this._dataSourceRootList is IBindingList)
                BindingListChangedEventManager.RemoveListener(this._dataSourceRootList as IBindingList, this._dataSourceRootListChangeListener);

            // clear the member
            this._dataSourceRootList = null;

        }

        #endregion //UnwireDataSourceRootList	

		#region UpdateScrollBarVisibility

		// JJD 3/26/07
		// Added the horz and vert scrollbar visibility properties
		private void UpdateScrollBarVisibility()
		{
			ViewBase currentView = this.CurrentViewInternal;

			if (currentView == null)
				return;

			ScrollBarVisibility svHorizontal = currentView.HorizontalScrollBarVisibility;
			ScrollBarVisibility svVertical = currentView.VerticalScrollBarVisibility;

            
#region Infragistics Source Cleanup (Region)











#endregion // Infragistics Source Cleanup (Region)


            this.SetValue(DataPresenterBase.HorizontalScrollBarVisibilityPropertyKey, KnownBoxes.FromValue(svHorizontal));
			this.SetValue(DataPresenterBase.VerticalScrollBarVisibilityPropertyKey, KnownBoxes.FromValue(svVertical));
		}

		#endregion //UpdateScrollBarVisibility	
    
		#region UpdateSelectedItems



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

		private void UpdateSelectedItems(SelectedItemHolder selected)
		{
			// make a copy of the selection so we can raise a notification
			// to any automation listeners after the selection is completed.
			SelectedItemHolder automationPreviousSelection = null;

			if (AutomationPeer.ListenerExists(AutomationEvents.SelectionPatternOnInvalidated) ||
				AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementAddedToSelection) ||
				AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementRemovedFromSelection) ||
				AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementSelected))
			{
				automationPreviousSelection = new SelectedItemHolder(this);

				if (this.SelectedItems.HasCells)
					automationPreviousSelection.Cells.InternalAddRange(this.SelectedItems.Cells);
				if (this.SelectedItems.HasRecords)
					automationPreviousSelection.Records.InternalAddRange(this.SelectedItems.Records);
				if (this.SelectedItems.HasFields)
					automationPreviousSelection.Fields.InternalAddRange(this.SelectedItems.Fields);
			}


			if (this.SelectedItems.HasCells)
			{
				SelectedCellCollection oldSelectedCells = this.SelectedItems.Cells;
				for (int i = 0; i < oldSelectedCells.Count; i++)
				{
					Cell item = oldSelectedCells[i];

					// Only set it to false if we are not going to be setting it back to true below.
					// InternalSelect in addition to updating the select flag also invalidates the
					// ui element which is inefficient and not necessary since it will be reset to
					// selected state in the below loop.
					//
					// We don't need to check this any more since invalidating rows and cells (more 
					// specifically finding the associated ui elements ) has been optimized so we 
					// don't need to do this any more and not only that this may slow us down since 
					// Contains is an O(n) operation.
					// 
					// Calling InternalSelect below does a notifypropchange and that hinders performance.
					// So go back to checking if the row is in the new selected rows collection and if
					// so don't call InternalSelect again. However, this time do so only if the number
					// fo items in the selected rows collection is less than 1000.
					//
					if (!selected.HasCells || !selected.Cells.Contains(item))
						item.InternalSelect(false);
				}
			}

			if (selected.HasCells)
			{
				foreach (Cell cell in selected.Cells)
					cell.InternalSelect(true);
			}

			if (this.SelectedItems.HasRecords)
			{
				SelectedRecordCollection oldSelectedRecords = this.SelectedItems.Records;
				for (int i = 0; i < oldSelectedRecords.Count; i++)
				{
					Record item = this.SelectedItems.Records[i];

					// Only set it to false if we are not going to be setting it back to true below.
					// InternalSelect in addition to updating the select flag also invalidates the
					// ui element which is inefficient and not necessary since it will be reset to
					// selected state in the below loop.
					// 
					if (!selected.HasRecords || !selected.Records.Contains(item))
						item.InternalSelect(false);
				}
			}

			if (selected.HasRecords)
			{
				foreach (Record record in selected.Records)
					record.InternalSelect(true);
			}

			if (this.SelectedItems.HasFields && !this.SelectedItems.IsSelectionSameForItemType(typeof(Field), selected))
			{
				for (int i = 0; i < this.SelectedItems.Fields.Count; i++)
				{
					Field item = this.SelectedItems.Fields[i];

					item.InternalSelect(false);
				}
			}

			if (selected.HasFields)
			{
				for (int i = 0; i < selected.Fields.Count; i++)
				{
					Field item = selected.Fields[i];
					item.InternalSelect(true);
				}
			}

			this.SelectedItems.Records.InternalSetList(selected.Records);
			this.SelectedItems.Cells.InternalSetList(selected.Cells);
			this.SelectedItems.Fields.InternalSetList(selected.Fields);

			// finally if we created a copy of the old selection then we must have an automation
			// listeneres so raise the notification
			if (null != automationPreviousSelection)
				// JM 08-20-09 NA 9.2 EnhancedGridView
				//RecordListControlAutomationPeer.RaiseAutomationSelectionEvents(automationPreviousSelection, this.SelectedItems);
				ListAutomationPeerHelper.RaiseAutomationSelectionEvents(automationPreviousSelection, this.SelectedItems);
		}

		#endregion //UpdateSelectedItems

		#region VerifyActiveRecordNotDeleted

		private void VerifyActiveRecordNotDeleted()
		{
			DataRecord dr = this._activeRecord as DataRecord;

			if (dr != null)
			{
				//Debug.Assert(!dr.IsDeleted);

				if (dr.IsDeleted)
				{
					if (this._activeCell != null)
					{
						// clear the member variable first so we don't triiger the
						// de-activate cell event
						this._activeCell = null;
						this.ActiveCell = null;
					}

					// clear the member variable first so we don't triiger the
					// de-activate record event
					this._activeRecord = null;

					this.ActiveRecord = null;
				}
			}
		}

		#endregion //VerifyActiveRecordNotDeleted

		#region VerifyContentSiteGrid

		private void VerifyContentSiteGrid()
		{
			// AS 3/17/11 NA 2011.1 - Async Exporting
			// Remove the status control from the old grid.
			//
			this.RemoveStatusControl(this.ExportHelper.InternalStatusControl);

			// remove the old content site if there was one
			if (null != this._contentSiteGrid)
				this._logicalChildren.Remove(this._contentSiteGrid);

			DependencyObject contentSite = base.GetTemplateChild("PART_ContentSiteGrid");

			if (contentSite == null)
				return;

			Grid grid = contentSite as Grid;
			if (grid == null)
				throw new NotSupportedException(DataPresenterBase.GetString("LE_NotSupportedException_4", "Grid", "PART_ContentSiteGrid", "DataPresenterBase", contentSite.GetType().Name));

			// JM 05-19-09 TFS17711 
			Grid oldContentSiteGrid = this._contentSiteGrid;

			this._contentSiteGrid = grid;

            // AS 3/11/09 TFS11010
            // The grid is already a logical child of something else.
            //
			//// store the grid as the logical child so logicaltreehelper can walk into the ctrl.
			//this._logicalChildren.Add(grid);

			grid.RowDefinitions.Clear();

			// Determine positions of GroupByArea and ItemsFormatter.
			int groupByAreaRow = 0;
			int dataAreaRow = 1;
			this.GetGroupByAndDataAreaRows(ref groupByAreaRow, ref dataAreaRow);

			RowDefinition rd = new RowDefinition();
			if (groupByAreaRow == 0)
				rd.Height = GridLength.Auto;
			else
				rd.Height = new GridLength(1.0, GridUnitType.Star);

			grid.RowDefinitions.Add(rd);

			rd = new RowDefinition();
			if (groupByAreaRow == 1)
				rd.Height = GridLength.Auto;
			else
				rd.Height = new GridLength(1.0, GridUnitType.Star);

			grid.RowDefinitions.Add(rd);

			//if (this._dataAreaGrid == null)
			this._dataAreaGrid = new Grid();

			// AS 3/17/11 NA 2011.1 - Async Exporting
			// To avoid major churn in the arrangement logic we're going to 
			// put the status control into the _dataAreaGrid so we'll always
			// have 2 rowdefinitions where the RecordListControl is in the 2nd row.
			//
			rd = new RowDefinition();
			rd.Height = GridLength.Auto;
			_dataAreaGrid.RowDefinitions.Add(rd);
			rd = new RowDefinition();
			rd.Height = new GridLength(1, GridUnitType.Star);
			_dataAreaGrid.RowDefinitions.Add(rd);

			// set their grid row
			Grid.SetRow(this._dataAreaGrid, dataAreaRow);

			// add the data area grid next
			this._contentSiteGrid.Children.Add(this._dataAreaGrid);

			// Insert a RecordListControl in the data area grid
			RecordListControl rlc = this.CurrentRecordListControl;

			if (rlc != null)
				this._dataAreaGrid.Children.Add(rlc);

			//cache the content site data area content
			this._contentSiteDataAreaContent = rlc;

            // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
            // call VerifyGroupByAreaLocation to site the groupbyarea correctly
            
#region Infragistics Source Cleanup (Region)












#endregion // Infragistics Source Cleanup (Region)

			// JM 04-28-09 Added the following lines back from the commented out code immediately above and
			//			   adapted it to support GroupByAreaMulti.
			Grid			parentGrid			= null;
			GroupByAreaBase currentGroupByArea	= this.GetGroupByAreaResolved(false);
			if (currentGroupByArea != null)
				parentGrid = currentGroupByArea.Parent as Grid;
			// JM 05-19-09 TFS17711 - Only remove the GroupByArea from its parent grid if its parent grid is not the 
			//						  current ContentSiteGrid AND its parent grid is equal to the old ContentSiteGrid.
//			if (parentGrid != null && parentGrid == this._contentSiteGrid)
			if (parentGrid != null && parentGrid != this._contentSiteGrid)
			{
				if (parentGrid == oldContentSiteGrid)
					parentGrid.Children.Remove(currentGroupByArea);
			}

			this.VerifyGroupByAreaLocation();

			// AS 3/17/11 NA 2011.1 - Async Exporting
			// In case there was a status control showing while the template changed (e.g. theme change).
			//
			this.AddStatusControl(this.ExportHelper.InternalStatusControl);

			// JJD 9/13/06 
			// initialize the record manager's DataSource if we have data 

            // JJD 11/21/08 - TFS6743/BR35763 
            // We don't need the _addChildCacheItemsControl to wrap our DataItems
            // we are now binding to that colleciton directly when the DataSource 
            // property is not set
            //if (this.DataSource != null ||
            //    (this._addChildCacheItemsControl != null && this._addChildCacheItemsControl.Items.Count > 0))
			if (this.DataSource != null ||
				(this._dataItems != null && this._dataItems.Count > 0))
			{
				this.InitializeRecordManagerDataSource();
			}
		}

		#endregion //VerifyContentSiteGrid

		#region VerifyGroupByAreaLocation

		private void VerifyGroupByAreaLocation()
		{
			ViewBase view = this.CurrentViewInternal;

			if (this._contentSiteGrid != null && view != null)
			{
				bool removeGroupByArea = view.IsGroupBySupported == false ||
											this.GroupByAreaLocation == GroupByAreaLocation.None;

                // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                // get the effective groupbyarea based on the GroupByAreaMode
                GroupByAreaBase groupByAreaResolved = removeGroupByArea == false ? this.GetGroupByAreaResolved(this.IsInitialized) : null;

                // copy yhe children of the content site grid into an array first
                UIElement[] children = new UIElement[this._contentSiteGrid.Children.Count];
                this._contentSiteGrid.Children.CopyTo(children, 0);

                bool wasGroupByAreaResolvedFound = false;

                // loop over the child looping for an existing groupbyarea element
                foreach (UIElement child in children)
                {
                    GroupByAreaBase gba = child as GroupByAreaBase;

                    if (gba != null)
                    {
                        // if the resolved gba is already in the content site grid then
                        // just set a flag.
                        // Otherwise remove the old groupbyarea from the content site grid
                        if (gba == groupByAreaResolved && removeGroupByArea == false)
                            wasGroupByAreaResolvedFound = true;
                        else
                        {
                            this._contentSiteGrid.Children.Remove(gba);

                            // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                            // If the groupyarea doesn't have a logical parent (which it shouldn't)
                            // then add it as a logical child of the dp.
                            if (gba.Parent == null)
                                this.InternalAddLogicalChild(gba);
                        }
                    }
                }

				if (removeGroupByArea || groupByAreaResolved == null)
				{
                    // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                    // the removal of the old groupbyarea was done above
                    // Remove the GroupByArea 
                    //if (this.GroupByArea != null)
                    //    this._contentSiteGrid.Children.Remove(this.GroupByArea);
				}
				else
				{
					int groupByAreaRow = 0;
					int dataAreaRow = 1;
					this.GetGroupByAndDataAreaRows(ref groupByAreaRow, ref dataAreaRow);

					// Add a GroupByArea if necessary.
                    // JJD 4/14/09 - NA 2009 vol 2 - Cross band grouping
                    // use groupByAreaResolved instead of this.GroupByArea
                    //if (this._contentSiteGrid.Children.Contains(this.GroupByArea) == false)
					//	this._contentSiteGrid.Children.Add(this.GroupByArea);
                    if (wasGroupByAreaResolvedFound == false)
                    {
                        // since the resolved gba wasn't already in the content site grd
                        // we need to add it now but only if it doesn't already have a
                        // visual parent
                        if (VisualTreeHelper.GetParent(groupByAreaResolved) == null)
                        {
                            // JJD 5/6/09 - NA 2009 vol 2 - cross band grouping
                            // If the groupyarea is a logical child of us 
                            // remove it before we add it to the content site grid
                            // to prevent an exception
                            if (groupByAreaResolved.Parent == this)
                                this.InternalRemoveLogicalChild(groupByAreaResolved);

                            this._contentSiteGrid.Children.Add(groupByAreaResolved);
                        }
                    }


					// Set the ContentSiteGrid's RowDefinition heights
					if (this.GroupByAreaLocation == GroupByAreaLocation.AboveDataArea)
					{
						this._contentSiteGrid.RowDefinitions[0].Height = GridLength.Auto;
						this._contentSiteGrid.RowDefinitions[1].Height = new GridLength(1, GridUnitType.Star);
					}
					else
					{
						this._contentSiteGrid.RowDefinitions[0].Height = new GridLength(1, GridUnitType.Star);
						this._contentSiteGrid.RowDefinitions[1].Height = GridLength.Auto;
					}

                    // Set the GroupByArea and DataArea rows
                    if (this._contentSiteGrid.Children.Contains(groupByAreaResolved))
                    {
                        if (groupByAreaResolved != null)
                            Grid.SetRow(groupByAreaResolved, groupByAreaRow);
                    }

                    if (this._dataAreaGrid != null)
                        Grid.SetRow(this._dataAreaGrid, dataAreaRow);
				}
			}
		}

		#endregion //VerifyGroupByAreaLocation
    
        // JJD 12/14/07
        #region WireDataSourceRootList

        private void WireDataSourceRootList(IEnumerable rootList)
        {
            // if the value hasn't changed then return
            if (this._dataSourceRootList == rootList)
                return;

            // unwire the last guy
            this.UnwireDataSourceRootList();

            // cache the list so we can unwire later
            this._dataSourceRootList = rootList;

            if (this._dataSourceRootListChangeListener == null)
                this._dataSourceRootListChangeListener = new DataSourceRootListChangeListener(this);

            // if the list supports INotifyCollectionChanged add us as a listener
            if (this._dataSourceRootList is INotifyCollectionChanged)
                CollectionChangedEventManager.AddListener(this._dataSourceRootList as INotifyCollectionChanged, this._dataSourceRootListChangeListener);

            // if the list supports IBindingList add us as a listener
            if (this._dataSourceRootList is IBindingList)
                BindingListChangedEventManager.AddListener(this._dataSourceRootList as IBindingList, this._dataSourceRootListChangeListener);

        }

        #endregion //WireDataSourceRootList	
    
		#endregion //Private Methods

		#endregion //Methods

		// AS 6/16/09 NA 2009.2 Field Sizing
		#region IAutoResizeHost Members

		bool IAutoResizeHost.PerformAutoSize(FrameworkElement resizableItem, bool resizeInXAxis)
		{
			IResizableElement resizableElement = resizableItem as IResizableElement;
			Field field = null != resizableElement ? resizableElement.ResizeContext as Field : null;
			FieldLayout fl = null != field ? field.Owner : null;

			if (null == field || null == fl)
				return false;

			bool resizeRecord;

			// determine if we are trying to resize a record or a field 'column' based on orietation
			if (resizeInXAxis)
				resizeRecord = fl.IsHorizontal;
			else
				resizeRecord = !fl.IsHorizontal;

			if (resizeRecord)
				return false;

			FieldAutoSizeOptions resizeItemOptions = field.AutoSizeOptionsResolved;

			if (resizeItemOptions == FieldAutoSizeOptions.None)
				return false;

			// we need the panel to get to the layout items
			VirtualizingDataRecordCellPanel panel = Utilities.GetAncestorFromType(resizableItem, typeof(VirtualizingDataRecordCellPanel), true) as VirtualizingDataRecordCellPanel;
			Debug.Assert(null != panel);

			if (panel == null)
				return false;

			// we need the associated recordmanager to know how deep to traverse
			RecordManager rm = GridUtilities.GetFieldRecordManager(resizableItem, field, false);

			if (rm == null)
				return false;

			// get a list of all the layout items that should be manipulated
			bool isLabel = resizableItem is LabelPresenter;
			IList<FieldLayoutItemBase> layoutItems = GetAllResizableFieldItems(panel, field, isLabel, resizeInXAxis, true);

			if (layoutItems == null || layoutItems.Count == 0)
				return false;

			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (!this.VerifyOperationIsAllowed(UIOperation.FieldAutoSizing))
				return true;

			// generate a list of fields with their options
			Dictionary<Field, AutoSizeFieldSettings> fields = new Dictionary<Field, AutoSizeFieldSettings>();
			bool useCellPresenters = field.Owner.UseCellPresenters;

			foreach (FieldLayoutItemBase item in layoutItems)
			{
				Field itemField = item.Field;
				FieldAutoSizeOptions layoutItemOptions = itemField.AutoSizeOptionsResolved;

				// if cells are separate then use the specified options for the field since 
				// the label and cell are synchronized. however when the labels and cells are 
				// together then we need to consider the label and cell separately based 
				// on where they are positioned with respect to each other
				if (useCellPresenters)
				{
					if (item.IsLabel)
						layoutItemOptions &= FieldAutoSizeOptions.Label;
					else
						layoutItemOptions &= ~FieldAutoSizeOptions.Label;
				}

				AutoSizeFieldSettings currentInfo;

				if (!fields.TryGetValue(itemField, out currentInfo))
				{
					currentInfo = new AutoSizeFieldSettings(layoutItemOptions, itemField.AutoSizeScopeResolved);
				}
				else
				{
					// this will only happen when using cell presenters but if we 
					// already stored the options for the cell or label of this 
					// field and we hit the other part then combine the options
					currentInfo.Options |= layoutItemOptions;
				}

				fields[item.Field] = currentInfo;
			}

			AutoSizeFieldHelper autoSizeHelper = new AutoSizeFieldHelper(fields, field.Owner);

			int recordManagerDepth = AutoSizeFieldHelper.GetNestingDepth(rm);
			AutoSizeCalculationFlags flags = AutoSizeCalculationFlags.RecalculateRecords
				| AutoSizeCalculationFlags.UseTemplateRecordAsFallback; // AS 1/6/12 TFS83904/TFS25524

			// AS 8/19/09 TFS21036
			// If we couldn't exit edit mode then cancel the operation. Note I'm returning true
			// because I don't think we should start a resize operation either.
			//
			//autoSizeHelper.ExitEditModeIfNeeded();
			if (!autoSizeHelper.ExitEditModeIfNeeded())
				return true;

			if (!autoSizeHelper.Calculate(this.Records, recordManagerDepth, flags, null ))
				return true;

			FieldGridBagLayoutManager lm = panel.GetResizeLayoutManager();

			Dictionary<ILayoutItem, Size> sizes = autoSizeHelper.GetPreferredSizes(lm, layoutItems);

			if (sizes.Count == 0)
				return false;

			object rectContext = new Rect(panel.LayoutManagerSize);
			Dictionary<ILayoutItem, bool> autoSizeWidthStates;
			Dictionary<ILayoutItem, bool> autoSizeHeightStates;
			Dictionary<ILayoutItem, Size> newExtents = lm.PerformAutoSize(CalcSizeLayoutContainer.Instance, rectContext, sizes,
				// AS 6/29/10 TFS32094
				//fl.IsAutoFitWidth, fl.IsAutoFitHeight, 
				fl.IsGridBagAutoFitWidth, fl.IsGridBagAutoFitHeight, 
				out autoSizeWidthStates, out autoSizeHeightStates);

			_initialResizeIsPending = false;

			if (lm.ResizeItems(newExtents, resizeInXAxis, null, true, ItemSizeType.ExplicitAutoSize, resizeInXAxis ? autoSizeWidthStates : autoSizeHeightStates))
			{
				return true;
			}

			return false;
		}

		#endregion //IAutoResizeHost

		#region IResizeHost Members

		#region AddResizerBar

		/// <summary>
		/// Called at the start of a resize operation to add the resizer bar to the visual tree
		/// </summary>
		/// <param name="resizerBar">The resizer bar to add</param>
		void IResizeHost.AddResizerBar(FrameworkElement resizerBar)
		{
			this.AddVisualChild(resizerBar);
		}

		#endregion //AddResizerBar

		#region Controller

		/// <summary>
		/// Returns the <see cref="ResizeController"/> (read-only).
		/// </summary>
		ResizeController IResizeHost.Controller
		{
			get
			{
				if (this._resizeController == null)
				{
					this._resizeController = new ResizeController(this);

					// JJD 4/28/11 - TFS73523 - added 
					this.InitializeSpacingOnResizeController();
				}

				return this._resizeController;
			}
		}

		#endregion //Controller

		#region CanResize

		/// <summary>
		/// Determines if the resizing is allowed.
		/// </summary>
		/// <param name="resizableItem">The item that contains the ResizeContext</param>
		/// <param name="resizeInXAxis">True to resize the width and false to resize the height.</param>
		/// <returns>True if resizing in this dimension is allowed.</returns>
		bool IResizeHost.CanResize(FrameworkElement resizableItem, bool resizeInXAxis)
		{
			if (resizableItem == null)
				return false;

			ViewBase view = this.CurrentViewInternal;

			Debug.Assert(view != null);

			if (view == null)
				return false;

			IResizableElement resizableElement = resizableItem as IResizableElement;

			Debug.Assert(resizableElement != null);

			if (resizableElement == null)
				return false;

			// JM NA 10.1 CardView - Support Card resizing.
			// AS 1/22/10
			// We don't want to skip the logic below that checks if a field is actually 
			// allowed to resize so I removed the check for CellValuePresenter.
			//
			//if (this.CurrentViewInternal is CardView && (resizableElement is CardViewCard ||
			//											 resizableElement is CellValuePresenter))
			if (this.CurrentViewInternal is CardView && resizableElement is CardViewCard)
			{
				if (((CardViewCard)resizableElement).IsCollapsed)
					return false;

				CardViewSettings cardViewSettings = ((CardView)this.CurrentViewInternal).ViewSettings;

				if (resizeInXAxis)
					return cardViewSettings.AllowCardWidthResizing;
				else
					return cardViewSettings.AllowCardHeightResizing;
			}

            // JJD 5/28/09 - TFS17964 and TFS18036
            // We should not allow resizing of LabelPresenters in the GroupByArea
			LabelPresenter lp = resizableItem as LabelPresenter;
			
			
			
            
			if ( lp != null && ( lp.IsInGroupByArea || lp.IsInFieldChooser ) )
				 return false;

			// cast the resizecontext to a field
			Field field = resizableElement.ResizeContext as Field;

			if (field == null || field.Owner == null)
				return false;
			
			// AS 8/10/09
			// Expandable field cells are displayed in a separate ExpandableCellPresenter which should 
			// not allow resizing.
			//
			if (field.IsExpandableResolved)
				return false;

			FieldLayout fl = field.Owner;
			bool resizeRecord;

			// determine if we are trying to resize a record or a field 'column' based on orietation
			if (resizeInXAxis)
				resizeRecord = fl.IsHorizontal;
			else
				resizeRecord = !fl.IsHorizontal;

			if (resizeRecord)
			{
				if (lp != null)
					return false;

				if (!view.IsLogicalFieldHeightResizingAllowed)
					return false;

				switch (fl.DataRecordSizingModeResolved)
				{
					case DataRecordSizingMode.IndividuallySizable:
					case DataRecordSizingMode.SizableSynchronized:
					case DataRecordSizingMode.SizedToContentAndIndividuallySizable:
						return true;
					default:
						return false;
				}
			}

			if (!view.IsLogicalFieldWidthResizingAllowed)
				return false;

			// AS 6/15/09 NA 2009.2 Field Sizing
			//return field.AllowResizeResolved;
			if (!field.AllowResizeResolved)
				return false;

			
#region Infragistics Source Cleanup (Region)


























#endregion // Infragistics Source Cleanup (Region)


			// AS 1/22/10
			// While debugging a card issue I noticed that we still get a resize cursor when 
			// over a field that cannot be resized. To avoid this we will return false if the 
			// min/max are the same height.
			//
			if ((resizeInXAxis && fl.IsAutoFitWidth) || (!resizeInXAxis && fl.IsAutoFitHeight))
			{
				FrameworkElement resizeArea = ((IResizeHost)this).GetResizeAreaForItem(resizableItem);
				ResizeConstraints rc = new ResizeConstraints(null, resizeArea, resizeInXAxis);
				((IResizeHost)this).InitializeResizeConstraints(resizeArea, resizableItem, rc);

				if (rc.MinExtent == rc.MaxExtent)
					return false;
			}

			return true;
		}

		#endregion CanResize

		#region GetResizeAreaForItem

		/// <summary>
		/// Gets an element that defines the resize area for an item.
		/// </summary>
		/// <param name="resizableItem">The item to be resized.</param>
		/// <returns>The resize are.</returns>
		FrameworkElement IResizeHost.GetResizeAreaForItem(FrameworkElement resizableItem)
		{
			return this;
		}

		#endregion //GetResizeAreaForItem

		#region GetResizeCursor

		/// <summary>
		/// Determines if the resizing is allowed.
		/// </summary>
		/// <param name="resizableItem">The item that contains the ResizeContext</param>
		/// <param name="resizeInXAxis">True to resize the width and false to resize the height.</param>
		/// <param name="cursor">The normal default cursor for this type of a resize operation.</param>
		/// <returns>The cursor to display while the mouse is over the resize border.</returns>
		Cursor IResizeHost.GetResizeCursor(FrameworkElement resizableItem, bool resizeInXAxis, Cursor cursor)
		{
			return cursor;
		}

		#endregion GetResizeCursor

		#region InitializeResizeConstraints

		/// <summary>
		/// Called before a resize operation begins. 
		/// </summary>
		/// <param name="resizeArea">The element that defines the resize area.</param>
		/// <param name="resizableItem">The item to be resized</param>
		/// <param name="constraints">The constarints to apply to the resize operation.</param>
		void IResizeHost.InitializeResizeConstraints(FrameworkElement resizeArea, FrameworkElement resizableItem, ResizeConstraints constraints)
		{
			// AS 5/29/09 NA 2009.2 Undo/Redo
			// Keep a flag so we know when the first resize operation is about
			// to be performed. At that point we can take the snapshot of the 
			// related object.
			//
			_initialResizeIsPending = true;

			constraints.ResizeWhileDragging = false;

			// JM NA 10.1 CardView - Support Card resizing.
			if (resizableItem is CardViewCard)
			{
				// Set min/max extent
				CardViewPanel cardViewPanel = this.CurrentPanel as CardViewPanel;
				Debug.Assert(cardViewPanel != null, "CardViewPanel is null!");
				if (cardViewPanel == null)
					return;

				ScrollContentPresenter	scp					= Utilities.GetAncestorFromType(resizableItem, typeof(ScrollContentPresenter), true) as ScrollContentPresenter;
				CardViewSettings		cardViewSettings	= cardViewPanel.ViewSettings;
				Point					point				= resizableItem.TranslatePoint(new Point(0, 0), cardViewPanel);
				double					smallestMinExtent	= 50;
				if (constraints.ResizeInXAxis)
				{
					double minWidth			= double.IsNaN(resizableItem.DesiredSize.Width) ? smallestMinExtent :
																							  Math.Min(smallestMinExtent, resizableItem.DesiredSize.Width);
					constraints.MinExtent	= Math.Max(minWidth, resizableItem.MinWidth);

					double panelAreaWidth	= scp != null ? scp.ActualWidth : cardViewPanel.ActualWidth;
					constraints.MaxExtent	= panelAreaWidth - (cardViewSettings.Padding.Left	+ 
															   cardViewSettings.Padding.Right + 
															   point.X) - 4;
				}
				else
				{
					double minHeight		= double.IsNaN(resizableItem.DesiredSize.Height) ? smallestMinExtent :
																							   Math.Min(smallestMinExtent, resizableItem.DesiredSize.Height);
					constraints.MinExtent	= Math.Max(minHeight, resizableItem.MinHeight);

					double panelAreaHeight	= scp != null ? scp.ActualHeight : cardViewPanel.ActualHeight;
					constraints.MaxExtent	= panelAreaHeight - (cardViewSettings.Padding.Top + 
																cardViewSettings.Padding.Bottom	+
																point.Y) - 4;
				}

				return;
			}

			ResizingMode mode = ResizingMode.Default;

			if (resizableItem is IResizableElement)
			{
				Field field = ((IResizableElement)resizableItem).ResizeContext as Field;
				Debug.Assert(field != null);
				FieldLayout fl = field != null ? field.Owner : null;

                if (field != null && fl != null)
                {
                    mode = fl.ResizingModeResolved;

                    #region Min/MaxExtent
                    // AS 12/15/08 NA 2009 Vol 1 - Fixed Fields
                    // Previously we were not controlling the min/max resize range.
                    //
                    VirtualizingDataRecordCellPanel panel = Utilities.GetAncestorFromType(resizableItem, typeof(VirtualizingDataRecordCellPanel), true) as VirtualizingDataRecordCellPanel;

                    if (null != panel)
                    {
                        FieldGridBagLayoutManager layoutManager = panel.GetResizeLayoutManager();
                        Debug.Assert(null != layoutManager);
                        Debug.Assert(resizableItem is LabelPresenter || resizableItem is CellValuePresenter);

                        bool isLabel = resizableItem is LabelPresenter;

                        FieldLayoutItemBase layoutItem = layoutManager.GetLayoutItem(field, isLabel);
                        Debug.Assert(null != layoutItem);

                        if (null != layoutItem)
                        {
							// AS 6/29/09 NA 2009.2 Field Sizing
							IList<FieldLayoutItemBase> allLayoutItems = GetAllResizableFieldItems(panel, field, isLabel, constraints.ResizeInXAxis, false);

                            double deltaLeft, deltaRight, deltaTop, deltaBottom;
							object rectContext = new Rect(panel.LayoutManagerSize);

							// AS 1/6/12 TFS28646
							// Like the change for TFS28477, the layout manager needs to temporarily 
							// have the context of the panel in case it needs the preferred size 
							// information of some non-virtualized cell elements.
							//
							bool releaseCellPanel = layoutManager.CellPanel == null;

							if (releaseCellPanel)
							{
								layoutManager.InitializePanelReference(panel);
								panel.InitializeCachedDimensions();
								layoutManager.InvalidateLayout();
							}

                            layoutManager.GetResizeRange(CalcSizeLayoutContainer.Instance, rectContext,
                                layoutItem, out deltaLeft, out deltaRight, out deltaTop, out deltaBottom,
								// AS 6/29/10 TFS32094
								//// AS 6/26/09 NA 2009.2 Field Sizing
								//fl.IsAutoFitWidth, fl.IsAutoFitHeight, 
								fl.IsGridBagAutoFitWidth, fl.IsGridBagAutoFitHeight, 
								FieldGridBagLayoutManager.ConvertLayoutItems(allLayoutItems));

							// AS 1/6/12 TFS28646
							if (releaseCellPanel)
							{
								panel.ReleaseCachedDimensions();
								layoutManager.InitializePanelReference(null);
							}

                            if (constraints.ResizeInXAxis)
                            {
                                constraints.MinExtent = Math.Min(resizableItem.ActualWidth - deltaLeft, resizableItem.ActualWidth);
                                constraints.MaxExtent = Math.Max(resizableItem.ActualWidth + deltaRight, resizableItem.ActualWidth);
                            }
                            else
                            {
                                constraints.MinExtent = Math.Min(resizableItem.ActualHeight - deltaTop, resizableItem.ActualHeight);
                                constraints.MaxExtent = Math.Max(resizableItem.ActualHeight + deltaBottom, resizableItem.ActualHeight);
                            }
                        }
                    } 
                    #endregion //Min/MaxExtent
                }
			}

			switch (mode)
			{
				default:
				case ResizingMode.Deferred:
					constraints.ResizeWhileDragging = false;
					break;
				case ResizingMode.Immediate:
					constraints.ResizeWhileDragging = true;
					break;
			}
		}

		#endregion InitializeResizeConstraints

		#region RootElement

		/// <summary>
		/// Returns the <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/> control (read-only).
		/// </summary>
		FrameworkElement IResizeHost.RootElement { get { return this; } }

		#endregion //RootElement

		#region RemoveResizerBar

		/// <summary>
		/// Called at the end of a resize operation to remove the resizer bar from the visual tree
		/// </summary>
		/// <param name="resizerBar">The resizer bar to remove</param>
		void IResizeHost.RemoveResizerBar(FrameworkElement resizerBar)
		{
			this.RemoveVisualChild(resizerBar);
		}

		#endregion //RemoveResizerBar

		#region Resize

		/// <summary>
		/// Resizes the item.
		/// </summary>
		/// <param name="resizableItem">The item that contains the ResizeContext</param>
		/// <param name="resizeInXAxis">True to resize the width and false to resize the height.</param>
		/// <param name="delta">The resize delta in device-independent units (1/96th inch per unit).</param>
		void IResizeHost.Resize(FrameworkElement resizableItem, bool resizeInXAxis, double delta)
		{
			if (resizableItem == null || delta == 0.0d)
				return;

			IResizableElement resizableElement = resizableItem as IResizableElement;

			Debug.Assert(resizableElement != null);

			if (resizableElement == null)
				return;

			// JM NA 10.1 CardView - Support Card resizing.
			if (resizableItem is CardViewCard)
			{
				CardView cardView = this.CurrentViewInternal as CardView;
				if (cardView != null)
				{
					if (resizeInXAxis == true)
						cardView.ViewSettings.CardWidth		= resizableItem.ActualWidth + delta;
					else
						cardView.ViewSettings.CardHeight	= resizableItem.ActualHeight + delta;
				}

				return;
			}

			Field targetField = resizableElement.ResizeContext as Field;

			Debug.Assert(targetField != null);

			if (targetField == null || targetField.Owner == null)
				return;

			FieldLayout fl = targetField.Owner;
			bool resizeLabel = resizableItem is LabelPresenter;

			bool resizeRecord;

			// determine if we are trying to resize a record or a field 'column' based on orietation
			if (resizeInXAxis)
				resizeRecord = fl.IsHorizontal;
			else
				resizeRecord = !fl.IsHorizontal;

            
#region Infragistics Source Cleanup (Region)








#endregion // Infragistics Source Cleanup (Region)

            // AS 12/15/08 NA 2009 Vol 1 - Fixed Fields
            VirtualizingDataRecordCellPanel panel = Utilities.GetAncestorFromType(resizableItem, typeof(VirtualizingDataRecordCellPanel), true) as VirtualizingDataRecordCellPanel;

            Debug.Assert(null != panel);
            if (null == panel)
                return;

			// AS 3/10/11 NA 2011.1 - Async Exporting
			if (resizeLabel && !this.VerifyOperationIsAllowed(UIOperation.FieldResizing))
				return;
			else if (resizeRecord && !this.VerifyOperationIsAllowed(UIOperation.RecordResizing))
				return;

            // get the current layout manager from the panel so we have the current extents on which
            // to apply the delta
            FieldGridBagLayoutManager lm = panel.GetResizeLayoutManager();
            FieldLayoutItemBase layoutItem = lm.GetLayoutItem(targetField, resizeLabel);
            Debug.Assert(null != layoutItem);
			Record targetRecord = null;

            if (null != layoutItem)
            {
				object rectContext = new Rect(panel.LayoutManagerSize);

				// AS 5/29/09 
				// I moved this down because we may end up using the layout manager
				// from the record in which case we want to perform the resize using 
				// that layout manager.
				//
                //Dictionary<ILayoutItem, Size> newExtents = lm.ResizeItem(CalcSizeLayoutContainer.Instance, rectContext, layoutItem,
                //    resizeInXAxis ? delta : 0d, resizeInXAxis ? 0d : delta, this.IsAutoFitWidth, this.IsAutoFitHeight);
				//
                //Debug.Assert(newExtents != null && newExtents.Count > 0, "No resize occurred");

                FieldLayoutItemBase.DebugSizeInfo(string.Format("Horz:{0}, Delta:{1}, IsLabel:{2}, ResizeRecord:{3}, Field:{4}", resizeInXAxis, delta, resizeLabel, resizeRecord, targetField), "Resize Request Info");

                CellValuePresenter cvp = null;

				// AS 2/26/10 TFS28477
				bool releasePanelReference = false;

                if (resizeLabel == false && resizeRecord)
                {
                    cvp = resizableItem as CellValuePresenter ?? Utilities.GetDescendantFromType(resizableItem, typeof(CellValuePresenter), true) as CellValuePresenter;

                    Debug.Assert(null != cvp);

                    if (null == cvp)
                        return;

                    // if we're resizing a record and we're supposed to change the size\
                    // of just this record then make sure we're using the record's
                    // layout manager
					// AS 1/25/10 SizableSynchronized changes
					// Since the filterrecord doesn't honor the sizing mode of the field layout 
					// when using SizableSynchronized, I've added a RecordSizingMode to the layout item.
					//
                    //if (GridUtilities.IsVariableHeightRecordMode(fl.DataRecordSizingModeResolved))
                    if (GridUtilities.IsVariableHeightRecordMode(layoutItem.RecordSizingMode))
                    {
						// AS 5/29/09 NA 2009.2 Undo/Redo
						targetRecord = cvp.Record;

                        lm = cvp.Record.GetLayoutManager(true);

						// AS 2/26/10 TFS28477
						// Don't bother laying out the container unless we can get the layout item.
						//
						//// AS 5/29/09
						//// Since we will use this to perform the resize, make sure that its metrics
						//// have been calculated.
						////
						//lm.LayoutContainer(CalcSizeLayoutContainer.Instance, rectContext);

						// also get the layout item for this layout manager instance
						layoutItem = lm.GetLayoutItem(targetField, resizeLabel);
						Debug.Assert(null != layoutItem);

						// recheck the layout item 
						if (null == layoutItem)
							return;

						// AS 2/26/10 TFS28477
						// The record's layout manager needs to temporarily have the context 
						// of the panel in case it needs the preferred size information of some 
						// non-virtualized cell elements.
						//
						releasePanelReference = true;
						lm.InitializePanelReference(panel);
						panel.InitializeCachedDimensions();
						lm.InvalidateLayout();

						// AS 2/26/10 TFS28477
						// I moved this down from above. If we didn't get the layout item we didn't 
						// need to do this and I wanted to initialize the panel reference before 
						// laying out the container.
						//
						// AS 5/29/09
						// Since we will use this to perform the resize, make sure that its metrics
						// have been calculated.
						//
						lm.LayoutContainer(CalcSizeLayoutContainer.Instance, rectContext);
					}
                }

				// AS 6/29/09 NA 2009.2 Field Sizing
				IList<FieldLayoutItemBase> layoutItems = GetAllResizableFieldItems(panel, targetField, resizeLabel, resizeInXAxis, false);

				// AS 5/29/09
				// Moved this down from above. If we used the record's manager then we need to have
				// it perform the resize so we get the constraint changes for its layout items.
				//
				Dictionary<ILayoutItem, bool> autoSizeWidthStates;
				Dictionary<ILayoutItem, bool> autoSizeHeightStates;
				Dictionary<ILayoutItem, Size> newExtents = lm.ResizeItem(CalcSizeLayoutContainer.Instance, rectContext, layoutItem,
					resizeInXAxis ? delta : 0d, resizeInXAxis ? 0d : delta,
					// AS 6/29/10 TFS32094
					//fl.IsAutoFitWidth, fl.IsAutoFitHeight,
					fl.IsGridBagAutoFitWidth, fl.IsGridBagAutoFitHeight,
					// AS 6/29/09 NA 2009.2 Field Sizing
					FieldGridBagLayoutManager.ConvertLayoutItems(layoutItems), out autoSizeWidthStates, out autoSizeHeightStates);

				// AS 6/29/09 NA 2009.2 Field Sizing
				#region Moved to helper method
//                Debug.Assert(newExtents != null && newExtents.Count > 0, "No resize occurred");

//                if (newExtents == null || newExtents.Count == 0)
//                    return;

//                //  e.g. if View==Vert & resizeInXAxis & (!UseCellPresenters || Above/Below) OR
//                //          View==Horz & !resizeInXAxis & (!UseCellPresenters || Left/Right)
//                FieldLayoutItemBase.DebugSizeInfo("", "Resize Extents Start");

//#if DEBUG
//                // AS 2/26/09 Optimization
//                // moved this out of the loop below since asking for the preferred size
//                // will cause it to update during the loop
//                foreach (KeyValuePair<ILayoutItem, Size> item in newExtents)
//                {
//                    FieldLayoutItemBase srcItem = item.Key as FieldLayoutItemBase;

//                    if (null != srcItem)
//                    {
//                        FieldLayoutItemBase actualItem = lm.GetLayoutItem(srcItem.Field, resizeLabel);
//                        Debug.Assert(null != actualItem);
//                        FieldLayoutItemBase.DebugSizeInfo(string.Format("Old:{0}, New:{1}, Field:{2}", new Size(actualItem.PreferredWidth, actualItem.PreferredHeight), item.Value, srcItem.Field), "Resize Item");
//                    }
//                }
//#endif

//                // AS 5/29/09 NA 2009.2 Undo/Redo
//                if (_initialResizeIsPending)
//                {
//                    _initialResizeIsPending = false;

//                    // if a resize operation has occurred snapshot the layout info
//                    // before the resize is performed.
//                    if (newExtents != null && newExtents.Count > 0)
//                    {
//                        // note we cannot rely on the actual new extents handed
//                        // back to determine what will change since some items 
//                        // may not have been changed in the first move when 
//                        // dragging is immediate but may be changed subsequent
//                        lm.CreateUndoSnapshot(resizeInXAxis, targetRecord);
//                    }
//                }

//                foreach (KeyValuePair<ILayoutItem, Size> item in newExtents)
//                {
//                    /* AS 6/16/09
//                     * I found this while implementing field sizing in 9.2. Essentially
//                     * we don't need to go back to the layout item. What was happening 
//                     * is that we were using the resizeLabel flag but that gave us the 
//                     * wrong layout item when labels were with the cells. Its really up
//                     * to the layout item to delegate to its wrapped item. I saw this when 
//                     * I had the labels with the cells (left of the cell) and I resized a 
//                     * label in the summary area.
//                     * 
//                    FieldLayoutItemBase srcItem = item.Key as FieldLayoutItemBase;

//                    // AS 4/16/09 TFS16467
//                    // The layout item may be a GridDefinitionLayoutItem. Since we want to update
//                    // its preferred width but only the FieldLayoutItemBase had a get/set PreferredWidth|Height,
//                    // I added a virtual one to the base LayoutItem class and then overrode it
//                    // on the FieldLayoutItemBase and also on the GridDefinitionLayoutItem.
//                    //
//                    //FieldLayoutItemBase actualItem = lm.GetLayoutItem(srcItem.Field, resizeLabel);
//                    LayoutItem actualItem = srcItem != null
//                        ? lm.GetLayoutItem(srcItem.Field, resizeLabel)
//                        : item.Key as LayoutItem;
//                    */
//                    LayoutItem actualItem = item.Key as LayoutItem;

//#if DEBUG
//                    FieldLayoutItemBase srcItem = item.Key as FieldLayoutItemBase;
//                    Debug.Assert(srcItem == null || lm.GetLayoutItem(srcItem.Field, srcItem.IsLabel) == srcItem);
//#endif

//                    if (null != actualItem)
//                    {
//                        if (resizeInXAxis)
//                        {
//                            actualItem.PreferredWidth = item.Value.Width;
//                        }
//                        else
//                        {
//                            actualItem.PreferredHeight = item.Value.Height;
//                        }
//                    }
//                }

//                FieldLayoutItemBase.DebugSizeInfo("", "Resize Extents End");
				#endregion //Moved to helper method

				bool addToUndo = _initialResizeIsPending;
				_initialResizeIsPending = false;

				// AS 2/26/10 TFS28477
				// If we associated the record's layout manager with the panel then 
				// we need to clean up the panel and the layout manager.
				//
				if (releasePanelReference)
				{
					panel.ReleaseCachedDimensions();
					lm.InitializePanelReference(null);
				}

				lm.ResizeItems(newExtents, resizeInXAxis, targetRecord, addToUndo, ItemSizeType.Explicit, resizeInXAxis ? autoSizeWidthStates : autoSizeHeightStates);
            }
        }

		#endregion Resize

		#endregion IResizeHost Members

		#region ISelectionHost Members

		#region Properties

		#region RootElement

		FrameworkElement ISelectionHost.RootElement
		{
			get { return this; }
		}

		#endregion //RootElement

		#endregion //Properties

		#region Methods

		#region ActivateItem

        // JJD 7/14/09 - TFS18784
        // Added preventScrollItemIntoView flag
        bool ISelectionHost.ActivateItem(ISelectableItem item, bool preventScrollItemIntoView)
		{
			
			
			
			
			
			
			
			
			

            // JJD 7/14/09 - TFS18784 
            // keep track of whether we need to scroll the item in view now or 
            // when the mouse is released
            this._bypassScrollIntoView = preventScrollItemIntoView;

            if ( item != this._itemPendingScrollItemIntoView )
                this._itemPendingScrollItemIntoView = this._bypassScrollIntoView ? item : null;

            try
            {
                Cell cell = item as Cell;

                if (cell != null)
                {
                    Debug.Assert(cell.DataPresenter == this);

                    // make sure the cell is from this datapresenter
                    if (cell.DataPresenter != this)
                        return false;

                    // set the active rtecord
                    if (cell.Record != this.ActiveRecord)
                        this.ActiveRecord = cell.Record;

                    // set the active cell
                    if (cell.Record == this.ActiveRecord)
                        this.ActiveCell = cell;

                    // return true if not cancelled
                    return this.ActiveCell == cell;
                }

                Record record = item as Record;

                if (record != null)
                {
                    Debug.Assert(record.DataPresenter == this);

                    // make sure the record is from this datapresenter
                    if (record.DataPresenter != this)
                        return false;

                    // set the active record
                    this.ActiveRecord = record;

                    // return true if not cancelled
                    return this.ActiveRecord == record;
                }

                Field field = item as Field;

                if (field != null)
                {
                    // JJD 7/14/09 - TFS18784 
                    // Moved logic to helper routine
                    this.BringFieldIntoView(field);
                    return true;
                }
            }
            finally
            {
                // JJD 7/14/09 - TFS18784 
                // reset the bypass flag 
                this._bypassScrollIntoView = false;
            }

			Debug.Fail("Invalid item type in DataPresenterBase's ISelectionHost.ActivateItem");

			return false;
		}

		#endregion //ActivateItem

		#region ClearSnapshot

		void ISelectionHost.ClearSnapshot()
		{
			this.SelectionSnapshot.SetCells(null);
			this.SelectionSnapshot.SetFields(null);
			this.SelectionSnapshot.SetRecords(null);
		}

		#endregion //ClearSnapshot

		#region DeselectItem

		bool ISelectionHost.DeselectItem(ISelectableItem item)
		{
			return this.InternalSelectItem(item, false, false);
		}

		#endregion //DeselectItem

		#region DeselectRange

		bool ISelectionHost.DeselectRange(ISelectableItem item)
		{
			return this.InternalSelectRange(item, false, false);
		}

		#endregion //DeselectRange

		#region DoAutoScrollHorizontal

		void ISelectionHost.DoAutoScrollHorizontal(ISelectableItem item, ScrollDirection direction, ScrollSpeed speed)
		{
			IScrollInfo scrollInfo = this.CurrentPanel as IScrollInfo;

			if (scrollInfo == null)
				return;

			ViewBase currentView = this.CurrentViewInternal;
			if (currentView.HasLogicalOrientation)
			{
				double delta;
				double factor;

				if (currentView.LogicalOrientation == Orientation.Horizontal)
					factor = this.CalculateScrollOffsetFactorInRecords(speed, scrollInfo.ViewportWidth);
				else
				{
					// AS 5/24/11 TFS75971
					// The FieldDragManager does call into here so we'll use the speed provided as we did before.
					//
					//// AS 4/12/11 TFS62951
					//// We're scrolling by field so we don't need to adjust for the speed - the timer internal is already 
					//// considering that.
					////
					////factor = this.CalculateScrollOffsetFactorInPixels(speed, scrollInfo.ViewportWidth);
					//factor = this.CalculateScrollOffsetFactorInPixels(ScrollSpeed.Slowest, scrollInfo.ViewportWidth);
					factor = this.CalculateScrollOffsetFactorInPixels(speed, scrollInfo.ViewportWidth);
				}

				if (direction == ScrollDirection.Increment)
				{
					delta = +1.0;
				}
				else
				{
					delta = -1.0;
				}

				delta *= factor;

				scrollInfo.SetHorizontalOffset(Math.Max(Math.Min(scrollInfo.HorizontalOffset + delta, scrollInfo.ExtentWidth - scrollInfo.ViewportWidth), 0d));

				// AS 4/12/11 TFS62951
				// Our scrolling of fields considers the scrolled offset so we need to ensure that the cell panels have been updated so 
				// invoke updatelayout so the call to GetNearestCompatibleItem just after this call will consider the fields just 
				// brought into view.
				//
				if (currentView.LogicalOrientation != Orientation.Horizontal)
					this.UpdateLayout();
			}
		}

		#endregion //DoAutoScrollHorizontal

		#region DoAutoScrollVertical

		void ISelectionHost.DoAutoScrollVertical(ISelectableItem item, ScrollDirection direction, ScrollSpeed speed)
		{
			IScrollInfo scrollInfo = this.CurrentPanel as IScrollInfo;

			if (scrollInfo == null)
				return;

			ViewBase currentView = this.CurrentViewInternal;
			if (currentView.HasLogicalOrientation)
			{
				double delta;
				double factor;

				if (currentView.LogicalOrientation == Orientation.Vertical)
					factor = this.CalculateScrollOffsetFactorInRecords(speed, scrollInfo.ViewportHeight);
				else
				{
					// AS 5/24/11 TFS75971
					// The FieldDragManager does call into here so we'll use the speed provided as we did before.
					//
					//// AS 4/12/11 TFS62951
					//// We're scrolling by field so we don't need to adjust for the speed - the timer internal is already 
					//// considering that.
					////
					////factor = this.CalculateScrollOffsetFactorInPixels(speed, scrollInfo.ViewportHeight);
					//factor = this.CalculateScrollOffsetFactorInPixels(ScrollSpeed.Slowest, scrollInfo.ViewportHeight);
					factor = this.CalculateScrollOffsetFactorInPixels(speed, scrollInfo.ViewportHeight);
				}

				if (direction == ScrollDirection.Increment)
				{
					delta = +1.0;
				}
				else
				{
					delta = -1.0;
				}

				delta *= factor;

				scrollInfo.SetVerticalOffset(Math.Max(Math.Min(scrollInfo.VerticalOffset + delta, scrollInfo.ExtentHeight - scrollInfo.ViewportHeight), 0d));

				// AS 4/12/11 TFS62951
				// Our scrolling of fields considers the scrolled offset so we need to ensure that the cell panels have been updated so 
				// invoke updatelayout so the call to GetNearestCompatibleItem just after this call will consider the fields just 
				// brought into view.
				//
				if (currentView.LogicalOrientation != Orientation.Vertical)
					this.UpdateLayout();
			}
		}

		#endregion //DoAutoScrollVertical

		#region EnterSnakingMode

		void ISelectionHost.EnterSnakingMode(ISelectableItem item)
		{
			Cell cell = item as Cell;

			if (cell == null)
				return;

			ISelectableItem pivotItem = ((ISelectionHost)this).GetPivotItem(item);

			Cell pivotCell = pivotItem as Cell;

			if (pivotCell == null)
				return;

			// if the cell is on the same record as the pivotRcd don't
			// go into snaking mode
			//
			// JJD 7/16/07 - BR19511
			// Make sure the CurrentViewInternal is not null
			if ( this.CurrentViewInternal == null )
				return;

			// JJD 7/16/07 - BR19511
			// Call IsOnSameIier method instead of just checking for a record match 
			//if (pivotCell.Record == cell.Record)
			if (pivotCell.IsOnSameTier(cell, this.CurrentViewInternal.LogicalOrientation))
			{
				this._snaking = false;
				return;
			}

			// set out internal flag that tells us we are
			// in snaking mode
			//
			this._snaking = true;
		}

		#endregion //EnterSnakingMode

		#region GetAutoScrollInfo

		AutoScrollInfo ISelectionHost.GetAutoScrollInfo(ISelectableItem item)
		{
			IScrollInfo scrollInfo = this.CurrentPanel as IScrollInfo;
			ViewBase currentView = this.CurrentViewInternal;

			if (scrollInfo == null || !currentView.HasLogicalOrientation)
				return new AutoScrollInfo(this, false, false, false, false);

			bool canScrollDown = scrollInfo.CanVerticallyScroll && scrollInfo.VerticalOffset + scrollInfo.ViewportHeight < scrollInfo.ExtentHeight;
			bool canScrollUp = scrollInfo.CanVerticallyScroll && scrollInfo.VerticalOffset > 0.0;
			bool canScrollRight = scrollInfo.CanHorizontallyScroll && scrollInfo.HorizontalOffset + scrollInfo.ViewportWidth < scrollInfo.ExtentWidth;
			bool canScrollLeft = scrollInfo.CanHorizontallyScroll && scrollInfo.HorizontalOffset > 0.0;

			// if we are selecting records or field labels then only scroll
			// in one dimension based on the orientation
			if (currentView.LogicalOrientation == Orientation.Vertical)
			{
				if (item is Record)
				{
					canScrollLeft = false;
					canScrollRight = false;
				}
				else
					if (item is Field)
					{
						canScrollDown = false;
						canScrollUp = false;
					}
			}
			else
			{
				if (item is Record)
				{
					canScrollDown = false;
					canScrollUp = false;
				}
				else
					if (item is Field)
					{
						canScrollLeft = false;
						canScrollRight = false;
					}
			}

			// AS 4/12/11 TFS62951
			//return new AutoScrollInfo(this, canScrollDown, canScrollLeft, canScrollRight, canScrollUp);
			AutoScrollInfo autoScrollInfo = new AutoScrollInfo(this, canScrollDown, canScrollLeft, canScrollRight, canScrollUp);

			if (canScrollDown || canScrollLeft || canScrollRight || canScrollUp)
				autoScrollInfo.AdjustScrollInfoCallback = _fixedScrollHelper.AdjustScrollInfoCallback;

			return autoScrollInfo;
		}

		#endregion //GetAutoScrollInfo

		#region GetNearestCompatibleItem

		ISelectableItem ISelectionHost.GetNearestCompatibleItem(ISelectableItem item, MouseEventArgs e)
		{
			Debug.Assert(item != null);

			
			
			
			
			
			
			
			
			

			if (item == null)
				return null;

			Point pt = e.MouseDevice.GetPosition(this);

			if (!this._selectionPoint.HasValue)
				this._selectionPoint = new Nullable<Point>(pt);

			// JJD 5/31/07
			// Call the InputHitTest method
			//HitTestResult htr = VisualTreeHelper.HitTest(this, pt);
			DependencyObject objectHit = this.InputHitTest(pt) as DependencyObject;
			RecordPresenter rp = null;

			//if (htr != null)
			if (objectHit != null)
			{
				// first see if the mouse is over a compatibale element
				//ISelectableElement selectableElement = this.GetCompatibleSelectableElement(item, htr.VisualHit);
				ISelectableElement selectableElement = this.GetCompatibleSelectableElement(item, objectHit);

				// AS 4/12/11 TFS62951
				// If the selection started in the scrollable area and is then moved over the 
				// fixed area while the scrollable area can still be scrolled in that direction, 
				// we don't want to return the fixed cell or else we will select from the pivot 
				// to that item including the elements scrolled out of view. Instead we want the 
				// nearest scrollable cell.
				//
				selectableElement = _fixedScrollHelper.VerifyNearestCompatibleItem(selectableElement, item, e);

				if (selectableElement != null)
					return selectableElement.SelectableItem;

				// see if we are over a record 
				//rp = Utilities.GetAncestorFromType(htr.VisualHit as Visual, typeof(RecordPresenter), true, this) as RecordPresenter;
				rp = Utilities.GetAncestorFromType(objectHit as Visual, typeof(RecordPresenter), true, this) as RecordPresenter;

				// AS 4/12/11 TFS62951
				if (rp != null && item is Cell)
				{
					// if the mouse is over a fixed field splitter then don't return the clipped cell underneath or else 
					// you get very rapid scrolling of the cells because when the cell is brought into view it will be 
					// adjacent to the fixed field splitter and the fixed field splitter will be over a different cell.
					// instead the new fixed scroll handling will allow the scrolling
					if (Utilities.GetAncestorFromType(objectHit as Visual, typeof(FixedFieldSplitter), true, rp) != null)
						return null;
				}

				if (rp != null)
				{
					// if we are searching for a record then we are over an incompatible record 
					// so return null
					if (item is Record)
						return null;

					// if we are searching for a cell only allow sibling records 
					if (item is Cell)
					{
						if (!((Cell)item).Record.IsSiblingOf(rp.Record))
							return this.GetNearestCompatibleCell(item, pt);
					}

					// if we are searching for a field only allow records from the same fieldlayout 
					if (item is Field)
					{
						if (((Field)item).Owner != rp.Record.FieldLayout)
							return null;

						// AS 4/12/11 TFS62951
						return this.GetNearestCompatibleField(item, pt, rp);
					}
				}

				// next see if we are over a compatible record presenter
				//rp = this.GetCompatibleRecordPresenter(item, htr.VisualHit);
				rp = this.GetCompatibleRecordPresenter(item, objectHit);
			}

			if (item is Cell)
				return this.GetNearestCompatibleCell(item, pt);

			// AS 4/12/11 TFS62951
			if (item is Field)
				return this.GetNearestCompatibleField(item, pt, null);

			// since we aren't over a compatible record presenter get the nearest record presenter
			if (rp == null)
				rp = this.GetNearestCompatibleRecordPresenter(item, pt);

			if (rp == null)
				return null;

			if (item is Record)
				return rp.Record;

			return null;
		}

		#endregion //GetCompatibleRecordPresenter

		#region GetPivotItem

		ISelectableItem ISelectionHost.GetPivotItem(ISelectableItem item)
		{
			
			
			
			
			
			
			
			
			

			if (item is Cell)
				return this._pivotCell;

			if (item is Record)
				return this._pivotRecord;

			if (item is Field)
				return this._pivotField;

			Debug.Fail("Invalid item type in DataPresenterBase's ISelectionHost.GetPivotItem");

			return null;
		}

		#endregion //GetPivotItem

		#region GetSelectionStrategyForItem

		SelectionStrategyBase ISelectionHost.GetSelectionStrategyForItem(ISelectableItem item)
		{
			SelectionStrategyBase strategy = null;

			if (this._selectionStrategyFilter != null)
			{
				strategy = this._selectionStrategyFilter.GetSelectionStrategyForItem(item);

				if (strategy != null)
					return strategy;
			}

			FieldLayout fl = GetFieldLayoutForSelectableItem(item);

			if (fl != null)
				return fl.GetSelectionStrategyForItem(item);

			return null;
		}

		#endregion //GetSelectionStrategyForItem

		#region IsItemSelectableWithCurrentSelection

		bool ISelectionHost.IsItemSelectableWithCurrentSelection(ISelectableItem item)
		{
			
			
			
			
			
			
			
			
			
			if (item == null)
			{
				// JJD 3/14/11 - TFS67147
				// Remove the assert since it is possible to get called with null in the case of a FilterRecord
				//Debug.Fail("Item is null in DataPresenterBase.IsItemSelectableWithCurrentSelection.");
				return false;
			}

			if (!item.IsSelectable)
				return false;

			return this.IsItemSelectableWithCurrentSelection(item);
		}

		#endregion //IsItemSelectableWithCurrentSelection

		#region IsMaxSelectedItemsReached

		bool ISelectionHost.IsMaxSelectedItemsReached(ISelectableItem item)
		{
			Record record = item as Record;

			if (record != null)
			{
				FieldLayout fl = record.FieldLayout;

				if (fl == null)
					return false;

				int maxRecordsAllowed = fl.MaxSelectedRecordsResolved;

				if (this._selectedItems != null &&
					 this._selectedItems.HasRecords &&
					 this._selectedItems.Records.Count >= maxRecordsAllowed)
					return true;

				return false;
			}

			Cell cell = item as Cell;

			if (cell != null)
			{
				FieldLayout fl = cell.Field.Owner;

				if (fl == null)
					return false;

				int maxCellsAllowed = fl.MaxSelectedCellsResolved;

				if (this._selectedItems != null &&
					 this._selectedItems.HasCells &&
					 this._selectedItems.Cells.Count >= maxCellsAllowed)
					return true;

				return false;
			}

			return false;
		}

		#endregion //IsMaxSelectedItemsReached

		#region OnDragStart 

		bool ISelectionHost.OnDragStart(ISelectableItem item, MouseEventArgs e)
		{
			// SSP 5/20/09 TFS17816
			// When LabelClickAction is SelectField, the label presenter doesn't get mouse
			// messages since the selection strategy handles them. In that case we need
			// to manage the drag operation from ISelectionHost's OnDragStart, OnDragMode
			// and OnDragEnd.
			// 

			if ( item is Field )
			{
				Field field = (Field)item;
				SelectedFieldCollection selectedFields = this.SelectedItems.Fields;
				int selectedFieldCount = selectedFields.Count;

				// Don't allow dragging of a selected field if other fields are selected because
				// that would give the impression that multiple fields can be dragged at the same
				// time but we allow only one field to be dragged at a time.
				// 
				if ( selectedFieldCount <= 1 || ! selectedFields.Contains( field ) )
					return this.StartFieldDragHelper( field, e );
			}



			return false;
		}

		#endregion //OnDragStart

		#region OnDragMove

		void ISelectionHost.OnDragMove(MouseEventArgs e)
		{
			// SSP 5/20/09 TFS17816
			// When LabelClickAction is SelectField, the label presenter doesn't get mouse
			// messages since the selection strategy handles them. In that case we need
			// to manage the drag operation from ISelectionHost's OnDragStart, OnDragMode
			// and OnDragEnd.
			// 

			if ( null != _fieldDragManager )
			{
				// ISelectionHost.OnDragEnd doesn't get a mouse event args passed into it so
				// the event args that was passed into the last ISelectionHost.OnDragMove needs
				// to be stored so we can use that in ISelectionHost.OnDragEnd to pass it along
				// into the call to the drag manager's OnDragEnd.
				// 
				_fieldDragManager._selectionHost_LastDragMoveEventArgs = e;

				_fieldDragManager.OnMouseMove( e );
			}

		}

		#endregion //OnDragMove

		#region OnDragEnd

		void ISelectionHost.OnDragEnd(bool canceled)
		{
			// SSP 5/20/09 TFS17816
			// When LabelClickAction is SelectField, the label presenter doesn't get mouse
			// messages since the selection strategy handles them. In that case we need
			// to manage the drag operation from ISelectionHost's OnDragStart, OnDragMode
			// and OnDragEnd.
			// 

			if ( null != _fieldDragManager )
			{
				MouseEventArgs mouseArgs = _fieldDragManager._selectionHost_LastDragMoveEventArgs;
				Debug.Assert( null != mouseArgs || canceled );

				_fieldDragManager.OnDragEnd( mouseArgs, canceled || null == mouseArgs );

				// SSP 6/24/09 - NAS9.2 Field Chooser
				// Now the OnDragEnd call above manages the _fieldDragManager member var.
				// 
				//_fieldDragManager = null;
			}

		}

		#endregion //OnDragEnd

		#region OnMouseUp

		void ISelectionHost.OnMouseUp(MouseEventArgs e)
		{
            // JJD 7/14/09 - TFS18784 
            // keep track of whether we need to scroll the item in view now or 
            // when the mouse is released
            if (this._itemPendingScrollItemIntoView != null)
            {
                try
                {
                    Cell cell = this._itemPendingScrollItemIntoView as Cell;

                    if (cell != null && cell == this.ActiveCell)
                    {
                        this.BringCellIntoView(cell);
                        return;
                    }

                    Record record = this._itemPendingScrollItemIntoView as Record;

                    if (record != null && record == this.ActiveRecord)
                    {
                        this.BringRecordIntoView(record);
                        return;
                    }

                    Field field = this._itemPendingScrollItemIntoView as Field;

                    if (field != null)
                    {
                        this.BringFieldIntoView(field);
                        return;
                    }
                }
                finally
                {
                    this._itemPendingScrollItemIntoView = null;
                }
            }
        }

		#endregion //OnMouseUp

		#region SelectItem

		bool ISelectionHost.SelectItem(ISelectableItem item, bool clearExistingSelection)
		{
			// JJD 4/25/07 - BR21910
			// Clear the snaking mode flag when selecting a new item not as part of a range selectionb
			this._snaking = false;

			return this.InternalSelectItem(item, clearExistingSelection, true);
		}

		#endregion //SelectItem

		#region SelectRange

		bool ISelectionHost.SelectRange(ISelectableItem item, bool clearExistingSelection)
		{
			bool rtn = this.InternalSelectRange(item, clearExistingSelection, true);

			// JJD 4/25/07 - BR21910
			// Clear the snaking mode flag when doing a range selection of a cell on the
			// same record as the pivot record
			if (this._snaking == true && this._pivotCell != null)
			{
				Cell cell = item as Cell;

				// JJD 7/16/07 - BR19511
				// Call IsOnSameIier method instead of just checking for a record match 
				//if (cell != null &&
				//     cell.Record == this._pivotCell.Record)
				ViewBase view = this.CurrentViewInternal;
				if (cell != null && view != null &&
					this._pivotCell.IsOnSameTier(cell, view.LogicalOrientation))
					this._snaking = false;
			}

			return rtn;
		}

		#endregion //SelectRange

		#region SetPivotItem

		void ISelectionHost.SetPivotItem(ISelectableItem item, bool isRangeSelect)
		{
			
			
			
			
			
			
			
			
			

			// get the old pivotRcd item
			//
			ISelectableItem oldPivotItem = ((ISelectionHost)this).GetPivotItem(item);

			this._selectionPoint = new Nullable<Point>();

			// Set pivotRcd item if shift key is not pressed.
			// Also set if we don't have a pivotRcd item (even if shift is pressed).
			//
			if (isRangeSelect &&
				(oldPivotItem != null))
				return;

			if (item is Cell)
			{
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotCell, item as Cell); //this._pivotCell = item as Cell;
				return;
			}

			if (item is Record)
			{
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotRecord, item as Record); //this._pivotRecord = item as Record;
				return;
			}

			if (item is Field)
			{
				// AS 4/12/11 TFS62951
				this.SetPivotMember(ref _pivotField, item as Field); //this._pivotField = item as Field;
				return;
			}

			Debug.Fail("Invalid item type in DataPresenterBase's ISelectionHost.SetPivotItem");
		}

		#endregion //SetPivotItem

		#region SnapshotSelection

		void ISelectionHost.SnapshotSelection(ISelectableItem item)
		{
			
			
			
			
			
			
			
			
			

			if (item is Record)
			{
				if (this.SelectedItems.Records.Count > 0)
				{
					// Copy the selection into the snapshot
					this.SelectionSnapshot.Records.InternalAddRange(this.SelectedItems.Records);
				}
				return;
			}

			if (item is Cell)
			{
				if (this.SelectedItems.Cells.Count > 0)
				{
					// Copy the selection into the snapshot
					this.SelectionSnapshot.Cells.InternalAddRange(this.SelectedItems.Cells);
				}
				return;
			}

			if (item is Field)
			{
				if (this.SelectedItems.Fields.Count > 0)
				{
					// Copy the selection into the snapshot
					this.SelectionSnapshot.Fields.InternalAddRange(this.SelectedItems.Fields);
				}
				return;
			}
		}

		#endregion //SnapshotSelection

		#region TranslateItem

		ISelectableItem ISelectionHost.TranslateItem(ISelectableItem item)
		{
			Cell cell = item as Cell;

			// SSP 9/9/09 TFS19158
			// Added GetCellClickActionResolved virtual method on the DataRecord.
			// 
			//if (cell != null && cell.Field.CellClickActionResolved == CellClickAction.SelectRecord)
			if ( cell != null && cell.Record.GetCellClickActionResolved( cell.Field ) == CellClickAction.SelectRecord )
				return cell.Record;

			return item;
		}

		#endregion //TranslateItem

		#endregion //Methods

		#endregion

		#region DataItemsCollection class

		/// <summary>
		/// Class used to hold data items for a <see cref="DataPresenterBase"/> 
		/// </summary>
		public class DataItemsCollection : ObservableCollection<object>
		{
			#region Member Variables

			private DataPresenterBase _dp;

            
#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)


			#endregion //Member Variables

			#region Constructor

			internal DataItemsCollection(DataPresenterBase dp)
			{
				this._dp = dp;
			}

			#endregion //Constructor

			#region Base Class Overrides

				// JM BR28152 12-06-07
				#region ClearItems

			/// <summary>
			/// Removes all items from the collection
			/// </summary>
			protected override void ClearItems()
			{
                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set. 
                // Howver we need to maintain the items in the logical tree
                foreach (object item in this)
                    this._dp.InternalRemoveLogicalChild(item);

				base.ClearItems();

                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set
                //this._dp._addChildCacheItemsControl.Items.Clear();
				//this.VerifyChildCacheItemsControl();
			}

				#endregion //ClearItems	
    
				#region InsertItem

			/// <summary>
			/// Inserts an item into the collection
			/// </summary>
			/// <param name="index">The index where the item should be inserted.</param>
			/// <param name="item">The item to insert</param>
			protected override void InsertItem(int index, object item)
			{
				if (this._dp.DataSource != null)
					throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_8"));

                
#region Infragistics Source Cleanup (Region)
















#endregion // Infragistics Source Cleanup (Region)


                // JJD 2/4/09
                // Call the base.InsertItem before calling InitializeRecordManagerDataSource
                // of the dp since it would wire up an empty list
				base.InsertItem(index, item);

				// if the internal DataSource hasn't been hooked up yet do it now
				//if (this._dp.DataSourceInternal != this._dp._addChildCacheItemsControl.Items)
				if (this._dp.DataSourceInternal != this)
					this._dp.InitializeRecordManagerDataSource();

                // JJD 2/4/09
                // Moved up. See note above
				//base.InsertItem(index, item);
 
                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set. 
                // However we need to maintain the items in the logical tree
                this._dp.InternalAddLogicalChild(item);
			}

				#endregion //InsertItem	
    
				// JM BR28152 12-06-07
				#region MoveItem

			/// <summary>
			/// Moves the item at the specified index to a new location in the collection.
			/// </summary>
			/// <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
			/// <param name="newIndex">The zero-based index specifying the new location of the item.</param>
			protected override void MoveItem(int oldIndex, int newIndex)
			{
				base.MoveItem(oldIndex, newIndex);

                
#region Infragistics Source Cleanup (Region)






#endregion // Infragistics Source Cleanup (Region)

			}

				#endregion //MoveItem	
    
				// JM BR28152 12-06-07
				#region RemoveItem

			/// <summary>
			/// Removes the item at the specified index of the collection.
			/// </summary>
			/// <param name="index">The zero-based index of the element to remove.</param>
			protected override void RemoveItem(int index)
			{
                object item = this[index];

				base.RemoveItem(index);

                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set. 
                // However we need to maintain the items in the logical tree
                this._dp.InternalRemoveLogicalChild(item);
                
#region Infragistics Source Cleanup (Region)




#endregion // Infragistics Source Cleanup (Region)

			}

				#endregion //RemoveItem	
    
				// JM BR28152 12-06-07
				#region SetItem

			/// <summary>
			/// Replaces the element at the specified index.
			/// </summary>
			/// <param name="index">The zero-based index of the element to replace.</param>
			/// <param name="item">The new value for the element at the specified index.</param>
			protected override void SetItem(int index, object item)
			{
                object oldItem = this[index];

				base.SetItem(index, item);

                // JJD 11/21/08 - TFS6743/BR35763 
                // We don't need the _addChildCacheItemsControl to wrap our DataItems
                // we are now binding to that colleciton directly when the DataSource 
                // property is not set. 
                // However we need to maintain the items in the logical tree
                this._dp.InternalRemoveLogicalChild(oldItem);
                this._dp.InternalAddLogicalChild(item);

                //this.VerifyChildCacheItemsControl();
                //this._dp._addChildCacheItemsControl.Items[index] = item;
			}

				#endregion //SetItem	
    
			#endregion //Base Class Overrides 

			#region Methods

            
#region Infragistics Source Cleanup (Region)








































#endregion // Infragistics Source Cleanup (Region)

			#endregion //Methods
		}

		#endregion //DataItemsCollection

        // JJD 12/14/07 - added class for listening to changes to the root list
        #region DataSourceRootListChangeListener private class

        private class DataSourceRootListChangeListener : IWeakEventListener
        {
            private DataPresenterBase _dataPresenter;

            internal DataSourceRootListChangeListener(DataPresenterBase dataPresenter)
            {
                this._dataPresenter = dataPresenter;
            }

            #region IWeakEventListener Members

            bool IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e)
            {
                if (managerType == typeof(CollectionChangedEventManager))
                {
                    if (e is NotifyCollectionChangedEventArgs)
                    {
                        // JJD 1/14/08 
                        // Handle receiving change notifications on other threads
                        //this._dataPresenter.CoerceValue(DataSourceInternalProperty);
                        this._dataPresenter.OnRootCollectionChanged();
                        return true;
                    }
                    Debug.Fail("Invalid args in ReceiveWeakEvent for DataPresenterBase, arg type: " + e != null ? e.ToString() : "null");
                }

                if (managerType == typeof(BindingListChangedEventManager))
                {
                    if (e is ListChangedEventArgs)
                    {
                        // JJD 1/14/08 
                        // Handle receiving change notifications on other threads
                        //this._dataPresenter.CoerceValue(DataSourceInternalProperty);
                        this._dataPresenter.OnRootCollectionChanged();
                        return true;
                    }
                    Debug.Fail("Invalid args in ReceiveWeakEvent for DataPresenterBase, arg type: " + e != null ? e.ToString() : "null");
                }

                Debug.Fail("Invalid managerType in ReceiveWeakEvent for DataPresenterBase, type: " + managerType != null ? managerType.ToString() : "null");
                return false;
            }

            #endregion

        }

        #endregion //DataSourceRootListChangeListener private class

		#region RangeSelectionEvaluator private class






		private class RangeSelectionEvaluator
		{
			#region Private Members

			private Record _pivotRecord;
			private Cell _pivotCell;
			private Field _pivotField;
			private Record _endOfRangeRecord;
			private Cell _endOfRangeCell;
			private Field _endOfRangeField;
			private bool _snaking;
			private bool _isPivotLessThanEnd;
			private bool _isGridView;
			private Orientation _gridViewOrientation;
			private long _pivotRecordPosition;
			private long _endOfRangeRecordPosition;
			private Field.FieldGridPosition _pivotFieldPosition;
			private Field.FieldGridPosition _endOfRangeFieldPosition;

			#endregion //Private Members

			#region Constructors

			internal RangeSelectionEvaluator(Record pivotRecord, Record record, bool snaking)
			{
				if (pivotRecord == null)
					throw new ArgumentNullException("pivotRecord", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				if (record == null)
					throw new ArgumentNullException("Record", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				this._pivotRecord = pivotRecord;
				this._endOfRangeRecord = record;
				this._snaking = snaking;
				this.Initialize();
			}

			internal RangeSelectionEvaluator(Cell pivotCell, Cell cell, bool snaking)
			{
				if (pivotCell == null)
					throw new ArgumentNullException("pivotCell", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				if (cell == null)
					throw new ArgumentNullException("Cell", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				this._pivotCell = pivotCell;
				this._pivotRecord = pivotCell.Record;
				this._pivotField = pivotCell.Field;
				this._endOfRangeCell = cell;
				this._endOfRangeRecord = cell.Record;
				this._endOfRangeField = cell.Field;
				this._snaking = snaking;

				this.Initialize();
			}

			internal RangeSelectionEvaluator(Field pivotField, Field field, bool snaking)
			{
				if (pivotField == null)
					throw new ArgumentNullException("pivotField", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				if (field == null)
					throw new ArgumentNullException("Field", DataPresenterBase.GetString("LE_ArgumentNullException_2"));

				this._pivotField = pivotField;
				this._endOfRangeField = field;
				this._snaking = snaking;
				this.Initialize();
			}

			#endregion //Constructors

			#region Properties

			internal Cell EndOfRangeCell { get { return this._endOfRangeCell; } }
			internal Field EndOfRangeField { get { return this._endOfRangeField; } }
			internal Record EndOfRangeRecord { get { return this._endOfRangeRecord; } }
			internal bool IsRangeOfCells { get { return this._pivotCell != null; } }
			internal bool IsRangeOfFields { get { return this._pivotField != null && !this.IsRangeOfCells; } }
			internal bool IsRangeOfRecords { get { return this._pivotRecord != null && !this.IsRangeOfRecords; } }
			internal Cell PivotCell { get { return this._pivotCell; } }
			internal Field PivotField { get { return this._pivotField; } }
			internal Record PivotRecord { get { return this._pivotRecord; } }

			#endregion //Properties

			#region Methods

			#region Internal Methods

			#region CompareFieldPositions (static)

			internal static int CompareFieldPositions(ref Field.FieldGridPosition position1, ref Field.FieldGridPosition position2)
			{
				if (position1.Row == position2.Row)
				{
					if (position1.Column == position2.Column)
						return 0;

					if (position1.Column < position2.Column)
						return 1;

					if (position1.Column > position2.Column)
						return -1;
				}

				if (position1.Row < position2.Row)
					return 1;

				return -1;
			}

			#endregion //CompareFieldPositions (static)

			#region IsPositionInFieldRectangle (static)

			internal static bool IsPositionInFieldRectangle(ref Field.FieldGridPosition fromPosition,
															ref Field.FieldGridPosition thruPosition,
															ref Field.FieldGridPosition testPosition)
			{
				int minRow = Math.Min(fromPosition.Row, thruPosition.Row);
				int maxRow = Math.Max(fromPosition.Row + fromPosition.RowSpan, thruPosition.Row + thruPosition.RowSpan);
				int minColumn = Math.Min(fromPosition.Column, thruPosition.Column);
				int maxColumn = Math.Max(fromPosition.Column + fromPosition.ColumnSpan, thruPosition.Column + thruPosition.ColumnSpan);

				return (testPosition.Row >= minRow &&
						testPosition.Row + testPosition.RowSpan <= maxRow &&
						testPosition.Column >= minColumn &&
						testPosition.Column + testPosition.ColumnSpan <= maxColumn);
			}

			#endregion //IsPositionInFieldRectangle (static)

			#region IsPositionInRectangularCellSlice

			internal bool IsPositionInRectangularCellSlice(Record record, Field field)
			{
				int pivotValue;
				int pivotSpan;
				int endValue;
				int endSpan;
				int testValue;
				int testSpan;
				Field.FieldGridPosition testPosition = field.GridPosition;

				// based on the gridview orientation get the values
				// that define the extent of the slice
				if (this._gridViewOrientation == Orientation.Vertical)
				{
					pivotValue = this._pivotFieldPosition.Column;
					pivotSpan = this._pivotFieldPosition.ColumnSpan;
					endValue = this._endOfRangeFieldPosition.Column;
					endSpan = this._endOfRangeFieldPosition.ColumnSpan;
					testValue = testPosition.Column;
					testSpan = testPosition.ColumnSpan;
				}
				else
				{
					pivotValue = this._pivotFieldPosition.Row;
					pivotSpan = this._pivotFieldPosition.RowSpan;
					endValue = this._endOfRangeFieldPosition.Row;
					endSpan = this._endOfRangeFieldPosition.RowSpan;
					testValue = testPosition.Row;
					testSpan = testPosition.RowSpan;
				}

				int lowestAllowableValue;
				int hightestAllowableValue = Math.Max(pivotValue + pivotSpan, endValue + endSpan);

				if (pivotValue <= endValue)
					lowestAllowableValue = pivotValue;
				else
					lowestAllowableValue = endValue;

				if (!(testValue >= lowestAllowableValue &&
					  testValue + testSpan <= hightestAllowableValue))
					return false;

				// this method should never be called when the pivotRcd and
				// end range records are the same
				Debug.Assert(this._pivotRecord != this._endOfRangeRecord);

				if (record == this._pivotRecord || record == this._endOfRangeRecord)
				{
					// based on the gridview orientation get the values
					// that are perpendicular to the slice bounds
					if (this._gridViewOrientation == Orientation.Vertical)
					{
						pivotValue = this._pivotFieldPosition.Row;
						pivotSpan = this._pivotFieldPosition.RowSpan;
						endValue = this._endOfRangeFieldPosition.Row;
						endSpan = this._endOfRangeFieldPosition.RowSpan;
						testValue = testPosition.Row;
						testSpan = testPosition.RowSpan;
					}
					else
					{
						pivotValue = this._pivotFieldPosition.Column;
						pivotSpan = this._pivotFieldPosition.ColumnSpan;
						endValue = this._endOfRangeFieldPosition.Column;
						endSpan = this._endOfRangeFieldPosition.ColumnSpan;
						testValue = testPosition.Column;
						testSpan = testPosition.ColumnSpan;
					}

					if (record == this._pivotRecord)
					{
						if (this._isPivotLessThanEnd)
							return testValue >= pivotValue;
						else
							return testValue + testSpan <= pivotValue + pivotSpan;
					}

					if (record == this._endOfRangeRecord)
					{
						if (this._isPivotLessThanEnd)
							return testValue + testSpan <= endValue + endSpan;
						else
							return testValue >= endValue;
					}
				}


				return true;
			}

			#endregion //IsPositionInRectangularCellSlice

			#region IsCellInRange

			internal bool IsCellInRange(Record record, Field field, bool excludePivot, bool excludeEndRange)
			{
				Debug.Assert(record != null);
				Debug.Assert(field != null);
				Debug.Assert(this._endOfRangeCell != null);
				Debug.Assert(this._pivotCell != null);

				if (record == null || field == null || this._pivotCell == null || this._endOfRangeCell == null)
					return false;

				// check for equality with pivotRcd
				if (field == this._pivotCell.Field &&
					record == this._pivotCell.Record)
					return !excludePivot;

				// check for equality with end range
				if (field == this._endOfRangeCell.Field &&
					record == this._endOfRangeCell.Record)
					return !excludeEndRange;

				// JJD 01/19/06 - BR17650
				// If the field is not visible or is expandable return false
				if (field.VisibilityResolved != Visibility.Visible ||
					field.CellContentAlignmentResolved == CellContentAlignment.LabelOnly || // AS 8/25/11 TFS84612
					field.IsExpandableResolved)
					return false;

				// find out if the record to test is within the range excluding
				// the pivotRcd and end range records if we are snaking
				bool isRecordInRange = this.IsRecordInRange(record, this._snaking, this._snaking);

				if (this._snaking)
				{
					// in the case of snaking all cells on intermediate records 
					// are included in the range
					if (isRecordInRange)
						return true;

					// if the pivotRcd record is the same as the end range
					// record then comare the field directly
					if (this._pivotRecord == this._endOfRangeRecord)
						return this.IsFieldInRange(field, false, false);

					// if the cell isn't on one of the range boundary records
					// then return false
					if (this._pivotRecord != record &&
						 this._endOfRangeRecord != record)
						return false;

					Field.FieldGridPosition positionToTest = field.GridPosition;
					
					// JJD 4/25/07 - BR21910
					// when snaking the range direction is based on when the pivot cell is less than the end cell
					//int rangeDirection = CompareFieldPositions(ref this._pivotFieldPosition, ref this._endOfRangeFieldPosition);
					int rangeDirection;
					if (this._isPivotLessThanEnd)
						rangeDirection = -1;
					else
						rangeDirection = 1;
					
					int compare;

					if (this._pivotRecord == record)
					{
						// JJD 4/25/07 - BR21910
						// if we are processing a cell on the Pivot record then flip the rfange direction
						rangeDirection *= -1;
						compare = CompareFieldPositions(ref this._pivotFieldPosition, ref positionToTest);
					}
					else
						compare = CompareFieldPositions(ref this._endOfRangeFieldPosition, ref positionToTest);

					if (rangeDirection >= 0)
						return compare >= 0;
					else
						return compare <= 0;
				}
				else
				{
					// since we aren't snaking return false if the record
					// is not in range
					if (!isRecordInRange)
						return false;

					// if the pivotRcd record is the same as the end range
					// record then compare the field directly
					if (this._pivotRecord == this._endOfRangeRecord ||
						!this._isGridView)
						return this.IsFieldInRange(field, false, false);

					// see if the position is in the rectangular slice 
					return this.IsPositionInRectangularCellSlice(record, field);
				}
			}

			#endregion //IsCellInRange

			#region IsFieldInRange

			internal bool IsFieldInRange(Field field, bool excludePivot, bool excludeEndRange)
			{
				Debug.Assert(field != null);
				Debug.Assert(this._pivotField != null);
				Debug.Assert(this._endOfRangeField != null);

				if (field == null)
					return false;

				// JJD 12/04/06 - BR17649
				// If not visible or expandable return false so we don't try to select it
				if (field.VisibilityResolved != Visibility.Visible ||
					field.IsExpandableResolved)
					return false;

				// check for equality with pivotRcd
				if (field == this._pivotField)
					return !excludePivot;

				// check for equality with end range
				if (field == this._endOfRangeField)
					return !excludeEndRange;

				Field.FieldGridPosition positionToTest = field.GridPosition;

				if (this._snaking)
				{
					int rangeDirection = CompareFieldPositions(ref this._pivotFieldPosition, ref this._endOfRangeFieldPosition);
					int compareWithPivot = CompareFieldPositions(ref this._pivotFieldPosition, ref positionToTest);

					// if the pivotRcd and the range end positions are equal 
					// then return true if the field is also equal
					if (rangeDirection == 0)
						return compareWithPivot == 0;

					int compareWithRangeEnd = CompareFieldPositions(ref this._endOfRangeFieldPosition, ref positionToTest);

					if (rangeDirection > 0)
						return compareWithPivot >= 0 && compareWithRangeEnd <= 0;
					else
						return compareWithPivot <= 0 && compareWithRangeEnd >= 0;
				}
				else
				{
					// return true if the position is in the rectangular slice
					return IsPositionInFieldRectangle(ref this._pivotFieldPosition, ref this._endOfRangeFieldPosition, ref positionToTest);
				}
			}

			#endregion //IsInRange (Field)

			#region IsRecordInRange

			internal bool IsRecordInRange(Record record, bool excludePivot, bool excludeEndRange)
			{
				Debug.Assert(record != null);
				Debug.Assert(this._pivotRecord != null);
				Debug.Assert(this._endOfRangeRecord != null);

				if (record == null)
					return false;

				// check for equality with pivotRcd
				if (record == this._pivotRecord)
					return !excludePivot;

				// check for equality with end range
				if (record == this._endOfRangeRecord)
					return !excludeEndRange;

				// get the position of the passed in record
				long positionToTest = record.OverallSelectionPosition;

				// return true if the position of the passed in record 
				// is between the pivotRcd and the end range
				if (this._isPivotLessThanEnd)
				{
					// JJD 7/12/07 - BR19329
					// 'And' the conditions instead of 'Or'ing them
					//return positionToTest > this._pivotRecordPosition ||
					//       positionToTest < this._endOfRangeRecordPosition;
					return positionToTest > this._pivotRecordPosition &&
						   positionToTest < this._endOfRangeRecordPosition;
				}
				else
				{
					// JJD 7/12/07 - BR19329
					// 'And' the conditions instead of 'Or'ing them
					//return positionToTest < this._pivotRecordPosition ||
					//       positionToTest > this._endOfRangeRecordPosition;
					return positionToTest < this._pivotRecordPosition &&
						   positionToTest > this._endOfRangeRecordPosition;
				}
			}

			#endregion //IsRecordInRange

			#endregion //Internal Methods

			#region Private Methods

			#region Initialize

			private void Initialize()
			{
				bool rangeSpansRecords = false;

				FieldLayout fl = null;

				if (this._endOfRangeField != null)
					this._endOfRangeFieldPosition = this._endOfRangeField.GridPosition;

				if (this._pivotField != null)
				{
					this._pivotFieldPosition = this._pivotField.GridPosition;
					fl = this._pivotField.Owner;
				}

				if (this._endOfRangeRecord != null)
					this._endOfRangeRecordPosition = this._endOfRangeRecord.OverallSelectionPosition;

				if (this._pivotRecord != null)
				{
					this._pivotRecordPosition = this._pivotRecord.OverallSelectionPosition;
					rangeSpansRecords = this._pivotRecord != this._endOfRangeRecord;
					fl = this._pivotRecord.FieldLayout;
				}

				// set flags so we know whether the range is going up or down 
				if (rangeSpansRecords)
				{
					// here we are spanning records so set the flags based
					// on the record positions
					if (this._pivotRecordPosition <= this._endOfRangeRecordPosition)
						this._isPivotLessThanEnd = true;
				}
				else
				{
					// here we are not spanning records so set the directional
					// flags based on the fields' row positions within the record

					// JJD 5/8/07 - BR22674
					// Make sure the field positions are not null
					//if (this._pivotFieldPosition.Row <= this._endOfRangeFieldPosition.Row)
					if ( this._pivotFieldPosition != null &&
						 this._endOfRangeFieldPosition != null &&
						this._pivotFieldPosition.Row <= this._endOfRangeFieldPosition.Row)
						this._isPivotLessThanEnd = true;
				}

				Debug.Assert(fl != null);

				if (fl != null)
				{
					FieldLayoutTemplateGenerator generator = fl.StyleGenerator;

					Debug.Assert(generator != null);
					if (generator != null)
					{
						this._gridViewOrientation = generator.LogicalOrientation;

						if (generator.CellPresentation == CellPresentation.GridView)
							this._isGridView = true;
					}
				}
			}

			#endregion //Initialize

			#endregion //Private Methods

			#endregion //Methods
		}

		#endregion //RangeSelectionEvaluator private class

		#region SelectedItemHolder public class

		/// <summary>
		/// Object used to hold a DataPresenterBase's selected Records, Fields and Cells
		/// </summary>
		/// <remarks>
		/// <para class="body">Three types of items can be selected, <see cref="Record"/>s, <see cref="Cell"/>s and <see cref="Field"/>s. This functionality is controlled by the following properties:
		/// <ul>
		/// <li><see cref="Record"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Records"/> collection.</li>
		/// <li><see cref="Cell"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/> property and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Cells"/> collection.</li>
		/// <li><see cref="Field"/> selection is enabled via the <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/> and <see cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/> properties and exposed thru the <see cref="DataPresenterBase.SelectedItems"/>.<see cref="SelectedItemHolder.Fields"/> collection.</li>
		/// </ul>
		/// </para>
		/// <para></para>
		/// <para class="body">The <see cref="SelectedItems"/> object exposes 3 collections (<see cref="SelectedItemHolder.Records"/>, <see cref="SelectedItemHolder.Cells"/> and <see cref="SelectedItemHolder.Fields"/>) that can can be used to select/de-select specific items. In addition, selection can be affected by setting the <see cref="Record"/>'s <see cref="Record.IsSelected"/>, the <see cref="Cell"/>'s <see cref="Cell.IsSelected"/> and the <see cref="Field"/>'s <see cref="Field.IsSelected"/> properties.</para>
		/// <para></para>
		/// <para class="body">The following describes how selection behaves in various scenarios:
		///		<ul>
		///			<li>If a user selects records, cells or fields via mouse or keyboard interactions then the <see cref="DataPresenterBase.SelectedItemsChanging"/> event is raised. If this is not canceled then the appropriate <see cref="DataPresenterBase.SelectedItems"/> collections are updated and the <see cref="DataPresenterBase.SelectedItemsChanging"/> <see cref="DataPresenterBase.SelectedItemsChanged"/> events are raised</li>
		///			<li>If any of the <b>IsSelected</b> properties are changed in code or items are added or removed via the <see cref="SelectedItems"/> collections then the behavior is the same and the <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events are raised.</li>
		///			<li>If the user enters edit mode on a cell then all of the selected collections will be cleared triggering the same <b>SelectedItemsChanging</b> and <b>SelectedItemsChanged</b> events.</li>
		///			<li>When records are deleted (either thru changes to the data source or by the user pressing the 'Delete' key) the <b>SelectedItemsChanging</b> event will not will be raised even though the <see cref="SelectedItems"/> <b>Records</b> and <b>Cells </b>collections are updated appropriately. However, the <b>SelectedItemsChanged</b> event will be raised. Note if the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///			then pressing the 'Delete' key will raise the <see cref="DataPresenterBase.RecordsDeleting"/> event. If this is not canceled then by default the user will be prompted to confirm the deletion of all selected records.</li>
		///			<li>If record filtering is active (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldSettings.AllowRecordFiltering"/> is set to 'True' for one or more fields) then selection behaves as follows:
		///				<ul>
		///					<li>If a filter record is being displayed (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'FilterRecord' or left to its default value) then entering a filter cell will behave the same as entering any other cell. It will clear the existing selection and raise the events.</li>
		///					<li>If filtering is exposed via a drop down inside a field label (i.e. <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.FilterUIType"/> is set to 'LabelIcons') then changing the filter criteria will leave the existing selections unchanged. 
		///						Therefore it is possible to, e.g. select 5 records then filter some of them out and then operate on the original 5 selected records. If the data source supports deleting records and <see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings"/>.<see cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.AllowDelete"/> property is not set to 'False' 
		///						then pressing the 'Delete' key will prompt the user to confirm the deletion of the original 5 selected records. This behavior can be modified by e.g. canceling the <see cref="RecordsDeleting"/> event and deleting only the 'filtered in' records in code.</li>
		///				</ul>
		///			</li>
		///		</ul>
		/// </para>
		/// <para></para>
		/// <para class="note"><b>Note: </b> <see cref="Record"/> and <see cref="Cell"/> selection is mutually exclusive. Selecting one or more <see cref="Record"/>s will automatically clear the <see cref="Cell"/> selection and vice versa.</para>
		/// </remarks>
		/// <seealso cref="FieldLayoutSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeCell"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeField"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldLayoutSettings.SelectionTypeRecord"/>
		/// <seealso cref="FieldSettings"/>
		/// <seealso cref="Infragistics.Windows.DataPresenter.FieldSettings.LabelClickAction"/>
		/// <seealso cref="DataPresenterBase.SelectedItems"/>
		/// <seealso cref="DataPresenterBase.SelectedItemsChanged"/>
		/// <seealso cref="DataPresenterBase.SelectedItemsChanging"/>
		
		// JJD 4/13/07 - BR21909
		// Implemented IEnumerable<ISelectableItem> as was suggested in bug BR21909
		public class SelectedItemHolder : PropertyChangeNotifier, IEnumerable<ISelectableItem>
		{
			#region Private Members

			// JJD 4/13/07 - BR21909
			// Removed duplicate DataPresenterBase reference
			// private DataPresenterBase _owner;
			private DataPresenterBase _dp;
			private SelectedRecordCollection _records;
			private SelectedFieldCollection _fields;
			private SelectedCellCollection _cells;

			#endregion //Private Members

			#region Constructor

			internal SelectedItemHolder(DataPresenterBase dp)
			{
				this._dp = dp;
			}

			#endregion //Constructor

			#region Properties

			#region Public Properties

			#region DataPresenterBase

			/// <summary>
			/// Returns the owning <see cref="Infragistics.Windows.DataPresenter.DataPresenterBase"/> (read-only).
			/// </summary>
			public DataPresenterBase DataPresenter
			{
				get
				{
					// JJD 4/13/07 - BR21909
					//return this._owner;
					return this._dp;
				}
			}

			#endregion //DataPresenterBase

			#region Cells

			/// <summary>
			/// Returns a reference to a collection of the selected <see cref="Cell"/> objects. This property is read-only at run-time. This property is not available at design-time.
			/// </summary>
			/// <remarks>
			/// <p class="body">This property returns a reference to a collection of <see cref="Cell"/> objects that are currently selected. </p>
			/// <p class="body">As cells are selected and deselected, their corresponding <see cref="Cell"/> objects are added to and removed from the <see cref="SelectedCellCollection"/>  returned by this property.</p>
			/// <p class="body">When a <see cref="Cell"/> is selected or de-selected, the <see cref="SelectedItemsChanging"/> and <see cref="SelectedItemsChanged"/> events are raised.</p>
			/// <para></para>
			/// <para class="note"><b>Note: </b>When a <see cref="Cell"/> is selected the <see cref="Records"/> collection is automatically cleared.</para>
			/// </remarks>
			/// <seealso cref="SelectedCellCollection"/>
			/// <seealso cref="Fields"/>
			/// <seealso cref="Records"/>
			/// <seealso cref="Cell"/>
			/// <seealso cref="Cell.IsSelected"/>
			/// <seealso cref="DataPresenterBase.SelectedItems"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanging"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanged"/>
			public SelectedCellCollection Cells
			{
				get
				{
					if (this._cells == null)
					{
						this._cells = new SelectedCellCollection(this._dp);

						this._cells.Initialize(this);
					}

					return this._cells;
				}
			}

			#endregion //Cells

			#region Fields

			/// <summary>
			/// Returns a reference to a collection of the selected <see cref="Field"/> objects. This property is read-only at run-time. This property is not available at design-time.
			/// </summary>
			/// <remarks>
			/// <p class="body">This property returns a reference to a collection of <see cref="Field"/> objects that are currently selected. </p>
			/// <p class="body">As fields are selected and deselected, their corresponding <see cref="Field"/> objects are added to and removed from the <see cref="SelectedFieldCollection"/> returned by this property.</p>
			/// <p class="body">When a <see cref="Field"/> is selected or de-selected, the <see cref="SelectedItemsChanging"/> and <see cref="SelectedItemsChanged"/> events are raised.</p>
			/// </remarks>
			/// <seealso cref="SelectedFieldCollection"/>
			/// <seealso cref="Cells"/>
			/// <seealso cref="Records"/>
			/// <seealso cref="Field"/>
			/// <seealso cref="Field.IsSelected"/>
			/// <seealso cref="DataPresenterBase.SelectedItems"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanging"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanged"/>
			public SelectedFieldCollection Fields
			{
				get
				{
					if (this._fields == null)
					{
						this._fields = new SelectedFieldCollection(this._dp);

						this._fields.Initialize(this);
					}

					return this._fields;
				}
			}

			#endregion //Fields

			#region Records

			/// <summary>
			/// Returns a reference to a collection of the selected <see cref="Record"/> objects. This property is read-only at run-time. This property is not available at design-time.
			/// </summary>
			/// <remarks>
			/// <p class="body">This property returns a reference to a collection of <see cref="Record"/> objects that are currently selected. </p>
			/// <p class="body">As records are selected and deselected, their corresponding <see cref="Record"/> objects are added to and removed from the <see cref="SelectedRecordCollection"/> returned by this property.</p>
			/// <p class="body">When a <see cref="Record"/> is selected or de-selected, the <see cref="SelectedItemsChanging"/> and <see cref="SelectedItemsChanged"/> events are raised.</p>
			/// <para></para>
			/// <para class="note"><b>Note: </b>When a <see cref="Record"/> is selected the <see cref="Cells"/> collection is automatically cleared.</para>
			/// </remarks>
			/// <seealso cref="SelectedRecordCollection"/>
			/// <seealso cref="Cells"/>
			/// <seealso cref="Fields"/>
			/// <seealso cref="Record"/>
			/// <seealso cref="Record.IsSelected"/>
			/// <seealso cref="DataPresenterBase.SelectedItems"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanging"/>
			/// <seealso cref="DataPresenterBase.SelectedItemsChanged"/>
			public SelectedRecordCollection Records
			{
				get
				{
					if (this._records == null)
					{
						this._records = new SelectedRecordCollection(this._dp);
						this._records.Initialize(this);
					}

					return this._records;
				}
			}

			#endregion //Records

			#endregion //Public Properties

			#region Internal Properties

			#region Count

			// JJD 4/13/07 - BR21909
			// Implemented IEnumerable<ISelectableItem> as was suggested in bug BR21909
			internal int Count
			{
				get
				{
					int count = 0;

					if (this._fields != null)
						count += this._fields.Count;

					if (this._records != null)
						count += this._records.Count;

					if (this._cells != null)
						count += this._cells.Count;

					return count;
				}
			}

			#endregion //Count

			#region HasCells

			internal bool HasCells
			{
				get
				{
					return null != this._cells && this._cells.Count > 0;
				}
			}

			#endregion //HasCells

			#region HasFields

			internal bool HasFields
			{
				get
				{
					return null != this._fields && this._fields.Count > 0;
				}
			}

			#endregion //HasFields

            // AS 4/20/09 NA 2009.2 ClipboardSupport
            #region HasMixedSelection
            internal bool HasMixedSelection
            {
                get
                {
                    int count = 0;

                    if (this.HasCells)
                        count++;

                    if (this.HasRecords)
                        count++;

                    if (this.HasFields)
                        count++;

                    return count > 1;
                }
            } 
            #endregion //HasMixedSelection

			#region HasRecords

			internal bool HasRecords
			{
				get
				{
					return null != this._records && this._records.Count > 0;
				}
			}

			#endregion //HasRecords

			#region HasSelection

			internal bool HasSelection
			{
				get
				{
					return this.HasCells || this.HasFields || this.HasRecords;
				}
			}

			#endregion //HasSelection

			#endregion //Internal Properties

			#endregion //Properties

			#region Methods

			#region Internal Methods

			#region ClearAllSelected






			internal void ClearAllSelected()
			{
				if (null != this._records)
					this._records.Clear();

				if (null != this._fields)
					this._fields.Clear();

				if (null != this._cells)
					this._cells.Clear();
			}

			#endregion // ClearAllSelected

			#region ClearItemsOfType







			internal void ClearItemsOfType(ISelectableItem item)
			{
				if (item is Record)
				{
					if (this.HasRecords)
						this.Records.Clear();
				}
				else if (item is Cell)
				{
					if (this.HasCells)
						this.Cells.Clear();
				}
				else if (item is Field)
				{
					if (this.HasFields)
						this.Fields.Clear();
				}
				else
					Debug.Assert(false, "Unknown type of item type !");
			}

			#endregion // ClearItemsOfType

			#region CompareCollections



#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)

			private bool CompareCollections(ICollection coll1, ICollection coll2)
			{
				if (coll1 == coll2)
					return true;

				int count1 = null != coll1 ? coll1.Count : 0;
				int count2 = null != coll2 ? coll2.Count : 0;

				if (count1 <= 0 && count2 <= 0)
					return true;

				if (count1 != count2)
					return false;

				bool allSame = true;

				IEnumerator coll2Enumerator = coll2.GetEnumerator();
				coll2Enumerator.Reset();

				foreach (object item in coll1)
				{
					if (!coll2Enumerator.MoveNext() || item != coll2Enumerator.Current)
					{
						allSame = false;
						break;
					}
				}

				if (allSame)
					return true;

				Hashtable hash1 = new Hashtable(coll1.Count);
				Hashtable hash2 = new Hashtable(coll2.Count);

				object dummy = new object();

				foreach (object item in coll1)
					hash1[item] = dummy;

				foreach (object item in coll2)
					hash2[item] = dummy;

				if (hash1.Count != hash2.Count)
					return false;

				foreach (object key in hash1.Keys)
				{
					if (!hash2.ContainsKey(key))
						return false;
				}

				foreach (object key in hash2.Keys)
				{
					if (!hash1.ContainsKey(key))
						return false;
				}
				// ----------------------------------------------------------------------------------

				return true;
			}

			#endregion // CompareCollections

			// JJD 4/13/07 - BR21909
			// Implemented IEnumerable<ISelectableItem> as was suggested in bug BR21909
			#region GetItem

			internal ISelectableItem GetItem(int index)
			{
				int count;

				if (this._fields != null)
				{
					count = this._fields.Count;

					// if the index is in range of this collection return the
					// item at that index
					if (index < count)
						return this._fields[index];

					// adjust the index for the next collection
					index -= count;
				}

				if (this._records != null)
				{
					count = this._records.Count;

					// if the index is in range of this collection return the
					// item at that index
					if (index < count)
						return this._records[index];

					// adjust the index for the next collection
					index -= count;
				}

				if (this._cells != null)
				{
					count = this._cells.Count;

					// if the index is in range of this collection return the
					// item at that index
					if (index < count)
						return this._cells[index];
				}

				return null;
			}

			#endregion //GetItem	
    
			#region IsItemInCollection



#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)

			internal bool IsItemInCollection(ISelectableItem item)
			{
				if (null == item)
					return false;

				bool selected = false;

				if (null != this._records && this.Records.Contains(item))
					selected = true;
				else if (null != this._fields && this.Fields.Contains(item))
					selected = true;
				else if (null != this._cells && this.Cells.Contains(item))
					selected = true;

				return selected;
			}

			#endregion //IsItemInCollection

			#region IsSelectionSameForItemType



#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)

			internal bool IsSelectionSameForItemType(Type itemType, SelectedItemHolder selectionToCompareTo)
			{
				// JJD 6/14/07
				// Use IsAssignableFrom instead of IsSubclassOf since that is 10x more efficient
				//if (typeof(Record) == itemType || itemType.IsSubclassOf(typeof(Record)))
				//    return this.CompareCollections(this._records, selectionToCompareTo._records);
				//else if (typeof(Cell) == itemType || itemType.IsSubclassOf(typeof(Cell)))
				//    return this.CompareCollections(this._cells, selectionToCompareTo._cells);
				//else if (typeof(Field) == itemType || itemType.IsSubclassOf(typeof(Field)))
				//    return this.CompareCollections(this._fields, selectionToCompareTo._fields);
				if (typeof(Record).IsAssignableFrom(itemType))
					return this.CompareCollections(this._records, selectionToCompareTo._records);
				else if (typeof(Cell).IsAssignableFrom(itemType))
					return this.CompareCollections(this._cells, selectionToCompareTo._cells);
				else if (typeof(Field).IsAssignableFrom(itemType))
					return this.CompareCollections(this._fields, selectionToCompareTo._fields);
				else
					Debug.Assert(false, "Unknown type of item type !");

				return false;
			}

			#endregion // IsSelectionSameForItemType

			// JJD 4/13/07 - BR21909
			// Obsolete method
			#region Initialize - obsolete - removed

			//internal void Initialize(DataPresenterBase owner)
			//{
			//    this._owner = owner;
			//}

			#endregion //Initialize

			// AS 5/19/09 TFS17455
			#region InternalClearSelection
			/// <summary>
			/// Clears the specified selected collections without raising the owner's selection events.
			/// </summary>
			/// <param name="clearCells">True to clear the cells</param>
			/// <param name="clearRecords">True to clear the records</param>
			/// <param name="clearFields">True to clear the fields</param>
			/// <param name="resetItemSelectionStates">Trur to reset the selection state to false on all items in the collection.</param>
			/// <returns>Returns true if anything was cleared; otherwise false is returned</returns>
			// JJD 1/16/12 - TFS63720
			// Added resetItemSelectionState parameter
			//internal bool InternalClearSelection(bool clearCells, bool clearRecords, bool clearFields)
			internal bool InternalClearSelection(bool clearCells, bool clearRecords, bool clearFields, bool resetItemSelectionStates)
			{
				bool hasCleared = false;

				if (clearCells && this.HasCells)
				{
					// JJD 1/16/12 - TFS63720
					// Added resetItemSelectionState parameter
					//this.Cells.InternalClear();
					this.Cells.InternalClear(resetItemSelectionStates);
					hasCleared = true;
				}

				if (clearRecords && this.HasRecords)
				{
					// JJD 1/16/12 - TFS63720
					// Added resetItemSelectionState parameter
					//this.Records.InternalClear();
					this.Records.InternalClear(resetItemSelectionStates);
					hasCleared = true;
				}

				if (clearFields && this.HasFields)
				{
					// JJD 1/16/12 - TFS63720
					// Added resetItemSelectionState parameter
					//this.Fields.InternalClear();
					this.Fields.InternalClear(resetItemSelectionStates);
					hasCleared = true;
				}

				return hasCleared;
			}
			#endregion //InternalClearSelection

			#region RemoveDuplicateObjects



#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)

			internal static void RemoveDuplicateObjects(ArrayList list)
			{
				// Rather than removing individual items, remove all of them at once since
				// removing an item at a time is lot slower since it probably involves shifting the
				// rest of the items left.
				int i = 0;
				int j = 0;
				int listCount = list.Count;
				while (j < listCount)
				{
					while (j + 1 < listCount && object.ReferenceEquals(list[j], list[j + 1]))
					{
						j++;
					}

					if (j >= listCount)
						break;

					list[i] = list[j];
					i++;
					j++;
				}

				if (i < listCount)
					list.RemoveRange(i, listCount - i);
			}

			#endregion // RemoveDuplicateObjects

			#region RemoveItemFromCollection

			internal void RemoveItemFromCollection(ISelectableItem item)
			{
				if (item is Record)
				{
					if (null != this._records)
						this._records.Remove((Record)item);
				}
				else if (item is Cell)
				{
					if (null != this._cells)
						this._cells.Remove((Cell)item);
				}
				else if (item is Field)
				{
					if (null != this._fields)
						this._fields.Remove((Field)item);
				}
				else
					Debug.Assert(false, "Unknown type of item.");
			}

			private static FieldLayout GetFieldLayoutFromItem(ISelectableItem item)
			{
				FieldLayout fieldLayout = null;
				if (item is Record)
				{
					fieldLayout = ((Record)item).FieldLayout;
				}
				else if (item is Cell)
				{
					fieldLayout = ((Cell)item).Record.FieldLayout;
				}
				else if (item is Field)
				{
					fieldLayout = ((Field)item).Owner;
				}
				else
					Debug.Assert(false, "Unknown type of item.");

				return fieldLayout;
			}

			internal static void RemoveItemFromCollectionHelper(ISelectableItem item)
			{
				FieldLayout fieldLayout = SelectedItemHolder.GetFieldLayoutFromItem(item);
				if (null != fieldLayout)
				{
					DataPresenterBase dp = fieldLayout.DataPresenter;
					if (null != dp)
					{
						SelectedItemHolder selection = dp.SelectedItems;

						selection.RemoveItemFromCollection(item);
					}
				}
			}

			#endregion // RemoveItemFromCollection

			#region SetCells

			internal void SetCells(SelectedCellCollection newCells)
			{
				this._cells = newCells;

				// Initilize the cell's owner.
				//
				if (null != this._cells && null == this._cells.Owner)
					this._cells.Initialize(this);

				this.RaisePropertyChangedEvent("Cells");
			}

			#endregion //SetCells

			#region SetFields

			internal void SetFields(SelectedFieldCollection newFields)
			{
				this._fields = newFields;

				// Initilize the field's owner.
				//
				if (null != this._fields && null == this._fields.Owner)
					this._fields.Initialize(this);

				this.RaisePropertyChangedEvent("Fields");
			}

			#endregion //SetFields

			#region SetRecords

			internal void SetRecords(SelectedRecordCollection newRecords)
			{
				this._records = newRecords;

				// Initilize the record's owner.
				//
				if (null != this._records && null == this._records.Owner)
					this._records.Initialize(this);

				this.RaisePropertyChangedEvent("Records");
			}

			#endregion //SetRecords

			#endregion //Internal Methods

			#endregion //Methods

			#region SelectionPositionSortComparer class



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

			internal class SelectionPositionSortComparer : IComparer
			{





				internal SelectionPositionSortComparer()
				{
				}



#region Infragistics Source Cleanup (Region)



#endregion // Infragistics Source Cleanup (Region)

				internal static int CompareRecord(Record recordX, Record recordY)
				{
					Record parentRecordX = recordX.ParentRecord;
					Record parentRecordY = recordY.ParentRecord;

					if (null != parentRecordX)
					{
						Debug.Assert(null != parentRecordY, "Records are not at the same level !");
						int r = CompareRecord(parentRecordX, parentRecordY);

						if (0 != r)
							return r;
					}

					return recordX.Index.CompareTo(recordY.Index);
				}



#region Infragistics Source Cleanup (Region)


#endregion // Infragistics Source Cleanup (Region)

				int IComparer.Compare(object x, object y)
				{
					if (x == y)
						return 0;
					else if (null == x)
						return 1;
					else if (null == y)
						return -1;

					if (x is Record && y is Record)
					{
						Record xRecord = (Record)x;
						Record yRecord = (Record)y;

						if (xRecord.FieldLayout == yRecord.FieldLayout)
						{
							return CompareRecord(xRecord, yRecord);
						}

						return xRecord.OverallSelectionPosition.CompareTo(yRecord.OverallSelectionPosition);
					}
					else if (x is Cell && y is Cell)
					{
						Cell xCell = (Cell)x;
						Cell yCell = (Cell)y;

						int recordCompareVal = ((IComparer)this).Compare(xCell.Record, yCell.Record);

						if (0 == recordCompareVal)
							return xCell.Field.Index.CompareTo(yCell.Field.Index);
						else
							return recordCompareVal;
						// ----------------------------------------------------------------------------------
					}
					else if (x is Field && y is Field)
					{
						Field xField = (Field)x;
						Field yField = (Field)y;

						return xField.Index.CompareTo(yField.Index);
					}
					else
					{
						throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_11"));
					}
				}
			}

			#endregion // SelectionPositionSortComparer

			#region IEnumerable<ISelectableItem> Members

			IEnumerator<ISelectableItem> IEnumerable<ISelectableItem>.GetEnumerator()
			{
				return new SelectableItemEnumerator(this);
			}

			#endregion

			#region IEnumerable Members

			IEnumerator IEnumerable.GetEnumerator()
			{
				return new SelectableItemEnumerator(this);
			}

			#endregion

			// JJD 4/13/07 - BR21909
			// Implemented IEnumerable<ISelectableItem> as was suggested in bug BR21909
			#region SelectableItemEnumerator private class

			private class SelectableItemEnumerator : IEnumerator<ISelectableItem>
			{
				private SelectedItemHolder _selectedItemHolder;
				private int _currentPosition;
				private object _currentItem;

				static object UnsetObjectMarker = new object();

				internal SelectableItemEnumerator(SelectedItemHolder selectedItemHolder)
				{
					this._selectedItemHolder = selectedItemHolder;
					this._currentPosition = -1;
					this._currentItem = UnsetObjectMarker;
				}

				public void Dispose()
				{
					this.Reset();
				}

				public ISelectableItem Current
				{
					get
					{
						if (this._currentItem == UnsetObjectMarker)
						{
							if (this._currentPosition == -1)
								throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_25"));
							else
								throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_26"));
						}

						return this._currentItem as ISelectableItem;
					}
				}

				public bool MoveNext()
				{
					int count = this._selectedItemHolder.Count;

					if (this._currentPosition < count - 1)
					{
						this._currentPosition++;
						this._currentItem = this._selectedItemHolder.GetItem(this._currentPosition);
						return true;
					}

					this._currentPosition = count;
					this._currentItem = UnsetObjectMarker;
					return false;
				}

				public void Reset()
				{
					this._currentPosition = -1;
					this._currentItem = UnsetObjectMarker;
				}

				object IEnumerator.Current
				{
					get
					{
						return this.Current;
					}
				}
			}

			#endregion //SelectableItemEnumerator private class
		}

		#endregion //SelectedItemHolder

		#region DrillDownStackItem private class

		private class DrillDownStackItem
		{
			private RecordListControl _recordListControl;
			private Point _recordListControlOffset;
			private Record _expandedRecord;
			private RecordPresenter _recordPresenter;
			private FrameworkElement _container;

			internal DrillDownStackItem(RecordListControl recordListControl, Point recordListControlOffset, Record expandedRecord, RecordPresenter recordPresenter, FrameworkElement container)
			{
				this._recordListControl = recordListControl;
				this._recordListControlOffset = recordListControlOffset;
				this._expandedRecord = expandedRecord;
				this._recordPresenter = recordPresenter;
				this._container = container;
			}

			internal FrameworkElement Container { get { return this._container; } }
			internal Record ExpandedRecord { get { return this._expandedRecord; } }
			internal RecordPresenter RecordPresenter { get { return this._recordPresenter; } }
			internal RecordListControl RecordListControl { get { return this._recordListControl; } }
			internal Point RecordListControlOffset { get { return this._recordListControlOffset; } }
		}

		#endregion //DrillDownStackItem private class

		#region DrillActionItem private class

		private class DrillActionItem
		{
			private bool _expand;
			private Record _record;

			internal DrillActionItem(bool expand, Record record)
			{
				this._expand = expand; ;
				this._record = record;
			}

			internal bool Expand { get { return this._expand; } }
			internal Record Record { get { return this._record; } }
		}

		#endregion //DrillActionItem private class

		#region ListBoxPanelSettings private class

		private class ListBoxPanelSettings
		{
			internal ListBoxPanelSettings() { }

			internal int LayoutVersion = -1;
			internal Panel Panel;
		}

		#endregion //ListBoxPanelSettings private class

		#region Selector classes (Refactored)
        
        
        
        
        
        
        
        
        
        #region Base classes

        #region FieldSettingsStyleSelector internal class

        /// <summary>
        /// Base class for a selector that provides a style for given field settings property.
        /// </summary>
        internal abstract class FieldSettingsStyleSelector : StyleSelector
        {
            internal readonly DataPresenterBase _presenter;
            private DependencyProperty _styleProperty;
            private DependencyProperty _selectorProperty;
            private Type _elementType;

            protected FieldSettingsStyleSelector(DataPresenterBase presenter, DependencyProperty styleProperty, DependencyProperty selectorProperty, Type elementType)
            {
                Debug.Assert(styleProperty != null && styleProperty.PropertyType == typeof(Style));
                Debug.Assert(selectorProperty != null && selectorProperty.PropertyType == typeof(StyleSelector));
                Debug.Assert(elementType == null || typeof(Visual).IsAssignableFrom(elementType));

                this._presenter = presenter;
                this._styleProperty = styleProperty;
                this._selectorProperty = selectorProperty;
                this._elementType = elementType;
            }


			// JJD 6/30/11 - TFS80466 - Optimization
			// Made method virtual so we can optimize it for certain high volume element types (e.g. Editor and CellValuePresenter)
            //protected Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
            protected virtual Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
            {
                StyleSelector selector = (StyleSelector)settings.GetValue(this._selectorProperty);
                Style style = null;

                if (selector != null)
                    style = selector.SelectStyle(item, container);

                return style ?? (Style)settings.GetValue(this._styleProperty);
            }

            protected Style SelectStyle(Field field, FieldLayout fieldLayout, object item, DependencyObject container)
            {
                Style style;

                if (field != null)
                {
                    if (field.HasSettings)
                    {
                        style = GetSettingsStyle(field.Settings, item, container);

                        if (style != null)
                            return style;
                    }

                    fieldLayout = field.Owner;

                    Debug.Assert(fieldLayout != null && fieldLayout.DataPresenter == this._presenter);
                }

                if (fieldLayout != null && fieldLayout.HasFieldSettings)
                {
                    style = GetSettingsStyle(fieldLayout.FieldSettings, item, container);

                    if (style != null)
                        return style;
                }

                if (this._presenter.HasFieldSettings)
                {
                    style = GetSettingsStyle(this._presenter.FieldSettings, item, container);

                    if (style != null)
                        return style;
                }

                // finally get the default style 
                return null != this._elementType
                    ? this._presenter.GetDefaultStyle(this._elementType)
                    : null;
            }
        }

        #endregion //FieldSettingsStyleSelector internal class

        #region FieldLayoutSettingsStyleSelector internal class

        /// <summary>
        /// Base class for a selector that provides a style for given field settings property.
        /// </summary>
        internal abstract class FieldLayoutSettingsStyleSelector : StyleSelector
        {
            internal readonly DataPresenterBase _presenter;
            private DependencyProperty _styleProperty;
            private DependencyProperty _selectorProperty;
            private Type _elementType;

            protected FieldLayoutSettingsStyleSelector(DataPresenterBase presenter, DependencyProperty styleProperty, DependencyProperty selectorProperty, Type elementType)
            {
                Debug.Assert(styleProperty != null && styleProperty.PropertyType == typeof(Style));
                Debug.Assert(selectorProperty == null || selectorProperty.PropertyType == typeof(StyleSelector));
                Debug.Assert(elementType == null || typeof(Visual).IsAssignableFrom(elementType));

                this._presenter = presenter;
                this._styleProperty = styleProperty;
                this._selectorProperty = selectorProperty;
                this._elementType = elementType;
            }

            protected Style GetSettingsStyle(FieldLayoutSettings settings, object item, DependencyObject container)
            {
                Style style = null;

                if (this._selectorProperty != null)
                {
                    StyleSelector selector = (StyleSelector)settings.GetValue(this._selectorProperty);

                    if (selector != null)
                        style = selector.SelectStyle(item, container);
                }

                return style ?? (Style)settings.GetValue(this._styleProperty);
            }

            protected Style SelectStyle(FieldLayout fieldLayout, object item, DependencyObject container)
            {
                Style style;

                if (fieldLayout != null && fieldLayout.HasSettings)
                {
                    style = GetSettingsStyle(fieldLayout.Settings, item, container);

                    if (style != null)
                        return style;
                }

                if (this._presenter.HasFieldLayoutSettings)
                {
                    style = GetSettingsStyle(this._presenter.FieldLayoutSettings, item, container);

                    if (style != null)
                        return style;
                }

                // finally get the default style 
                return null != this._elementType
                    ? this._presenter.GetDefaultStyle(this._elementType)
                    : null;
            }
        }

        #endregion //FieldLayoutSettingsStyleSelector internal class

        #endregion //Base classes

        #region DPCellPresenterStyleSelector internal class

        /// <summary>
		/// Supplies the style for each cell
		/// </summary>
		internal class DPCellPresenterStyleSelector : FieldSettingsStyleSelector
		{
			internal DPCellPresenterStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldSettings.CellPresenterStyleProperty, FieldSettings.CellPresenterStyleSelectorProperty, typeof(CellPresenter))
			{
			}

			// JJD 6/30/11 - TFS80466 - Optimization
			// Override method so we can optimize it for certain high volume element types (e.g. Editor and CellValuePresenter)
			//protected Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			protected override Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			{
				StyleSelector selector = settings.CellPresenterStyleSelector;
				Style style = null;

				if (selector != null)
					style = selector.SelectStyle(item, container);

				return style ?? settings.CellPresenterStyle;
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Field field = null;
				CellPresenter cell = item as CellPresenter;

				if (cell != null)
					field = cell.Field;

				if (field == null && container != null)
				{
					cell = container as CellPresenter;

					if (cell != null)
						field = cell.Field;

					if (field == null && container is Visual)
						field = Utilities.GetAncestorPropertyValue((Visual)container, CellPresenter.FieldProperty, this._presenter) as Field;
				}

                return this.SelectStyle(field, null, item, container);
			}
		}

		#endregion //DPCellPresenterStyleSelector internal class

		#region DPCellValuePresenterStyleSelector internal class

		/// <summary>
		/// Supplies the style for each cell
		/// </summary>
        internal class DPCellValuePresenterStyleSelector : FieldSettingsStyleSelector
		{
			internal DPCellValuePresenterStyleSelector(DataPresenterBase presenter)
                : base(presenter, FieldSettings.CellValuePresenterStyleProperty, FieldSettings.CellValuePresenterStyleSelectorProperty, typeof(CellValuePresenter))
			{
			}

			// JJD 6/30/11 - TFS80466 - Optimization
			// Override method so we can optimize it for certain high volume element types (e.g. Editor and CellValuePresenter)
			//protected Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			protected override Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			{
				StyleSelector selector = settings.CellValuePresenterStyleSelector;
				Style style = null;

				if (selector != null)
					style = selector.SelectStyle(item, container);

				return style ?? settings.CellValuePresenterStyle;
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Field field = null;
				CellValuePresenter cell = item as CellValuePresenter;

				if (cell != null)
					field = cell.Field;

				if (field == null && container != null)
				{
					cell = container as CellValuePresenter;

					if (cell != null)
						field = cell.Field;

					if (field == null && container is Visual)
						field = Utilities.GetAncestorPropertyValue((Visual)container, CellValuePresenter.FieldProperty, this._presenter) as Field;
				}

                return this.SelectStyle(field, null, item, container);
			}
		}

		#endregion //DPCellValuePresenterStyleSelector internal class

		#region DPEditorStyleSelector internal class

		/// <summary>
		/// Supplies the style for each cell
		/// </summary>
		internal class DPEditorStyleSelector : FieldSettingsStyleSelector
		{
			internal DPEditorStyleSelector(DataPresenterBase presenter) : 
                base(presenter, FieldSettings.EditorStyleProperty, FieldSettings.EditorStyleSelectorProperty, null)
			{
			}

			// JJD 6/30/11 - TFS80466 - Optimization
			// Override method so we can optimize it for certain high volume element types (e.g. Editor and CellValuePresenter)
			//protected Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			protected override Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			{
				StyleSelector selector = settings.EditorStyleSelector;
				Style style = null;

				if (selector != null)
					style = selector.SelectStyle(item, container);

				return style ?? settings.EditorStyle;
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Style style = this.SelectStyleHelper(item, container);

				if (style != null)
				{
                    // JJD 4/23/09 - TFS17037
                    // Call Utilities.VerifyTargetTypeOfStyle method instead
                    //if (style.TargetType == null ||
                    //    !typeof(ValueEditor).IsAssignableFrom(style.TargetType))
                    //    throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_12"), "EditorStyle");
                    Utilities.ValidateTargetTypeOfStyle(style, typeof(ValueEditor), "EditorStyle");
                }

				return style;
			}

			private Style SelectStyleHelper(object item, DependencyObject container)
			{
				Field field = null;

				if (item is CellValuePresenter)
					field = ((CellValuePresenter)item).Field;

				if (field == null && container != null)
				{
					if (container is CellValuePresenter)
						field = ((CellValuePresenter)container).Field;

					if (field == null && container is Visual)
						field = Utilities.GetAncestorPropertyValue((Visual)container, CellValuePresenter.FieldProperty, this._presenter) as Field;
				}

                return this.SelectStyle(field, null, item, container);
			}
		}

		#endregion //DPEditorStyleSelector internal class

		#region DPExpandedCellStyleSelector internal class

		/// <summary>
		/// Supplies the style for each cell
		/// </summary>
		internal class DPExpandedCellStyleSelector : FieldSettingsStyleSelector
		{
			internal DPExpandedCellStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldSettings.ExpandedCellStyleProperty, FieldSettings.ExpandedCellStyleSelectorProperty, typeof(ExpandedCellPresenter))
			{
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Field field = null;

				if (item is CellValuePresenter)
					field = ((CellValuePresenter)item).Field;

				if (field == null && container != null)
				{
					if (container is CellValuePresenter)
						field = ((CellValuePresenter)container).Field;

					if (field == null && container is Visual)
						field = Utilities.GetAncestorPropertyValue((Visual)container, CellValuePresenter.FieldProperty, this._presenter) as Field;
				}

                return this.SelectStyle(field, null, item, container);
			}
		}

		#endregion //DPExpandedCellStyleSelector internal class

		#region DPLabelPresenterStyleSelector internal class

		/// <summary>
		/// Supplies the style for each cell
		/// </summary>
		internal class DPLabelPresenterStyleSelector : FieldSettingsStyleSelector
		{
			internal DPLabelPresenterStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldSettings.LabelPresenterStyleProperty, FieldSettings.LabelPresenterStyleSelectorProperty, typeof(LabelPresenter))
			{
			}

			// JJD 6/30/11 - TFS80466 - Optimization
			// Override method so we can optimize it for certain high volume element types (e.g. Editor and CellValuePresenter)
			//protected Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			protected override Style GetSettingsStyle(FieldSettings settings, object item, DependencyObject container)
			{
				StyleSelector selector = settings.LabelPresenterStyleSelector;
				Style style = null;

				if (selector != null)
					style = selector.SelectStyle(item, container);

				return style ?? settings.LabelPresenterStyle;
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Field field = null;

				if (item is LabelPresenter)
					field = ((LabelPresenter)item).Field;

				if (field == null && container != null)
				{
					if (container is LabelPresenter)
						field = ((LabelPresenter)container).Field;

					if (field == null && container is Visual)
						field = Utilities.GetAncestorPropertyValue((Visual)container, LabelPresenter.FieldProperty, this._presenter) as Field;
				}

                return this.SelectStyle(field, null, item, container);
			}
		}

		#endregion //DPLabelPresenterStyleSelector internal class

		#region DPHeaderPresenterStyleSelector internal class

		/// <summary>
		/// Supplies the style for each cell
		/// </summary>
		internal class DPHeaderPresenterStyleSelector : FieldLayoutSettingsStyleSelector
		{
			internal DPHeaderPresenterStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldLayoutSettings.HeaderPresenterStyleProperty, null, typeof(HeaderPresenter))
			{
			}

			public override Style SelectStyle(object item, DependencyObject container)
			{
				FieldLayout fieldLayout = item as FieldLayout;

				if (fieldLayout == null && container is FrameworkElement)
					fieldLayout = ((FrameworkElement)container).DataContext as FieldLayout;

                return this.SelectStyle(fieldLayout, item, container);
			}
		}

		#endregion //DPHeaderPresenterStyleSelector internal class

		#region DPHeaderLabelAreaStyleSelector internal class

		/// <summary>
		/// Supplies the style for a record selector
		/// </summary>
		internal class DPHeaderLabelAreaStyleSelector : FieldLayoutSettingsStyleSelector
		{
			internal DPHeaderLabelAreaStyleSelector(DataPresenterBase presenter)
                : base (presenter, FieldLayoutSettings.HeaderLabelAreaStyleProperty, null, typeof(HeaderLabelArea))
			{
			}

			#region SelectStyle

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Record record = item as Record;
				FieldLayout fieldLayout = null;

				if (record != null)
					fieldLayout = record.FieldLayout;

				if (fieldLayout == null && container != null)
				{
					if (container is HeaderLabelArea)
						fieldLayout = ((HeaderLabelArea)container).FieldLayout;

					if (fieldLayout == null && container is Visual)
						fieldLayout = Utilities.GetAncestorPropertyValue((Visual)container, HeaderLabelArea.FieldLayoutProperty, this._presenter) as FieldLayout;
				}

                return this.SelectStyle(fieldLayout, item, container);
			}

			#endregion //SelectStyle
		}

		#endregion //DPHeaderLabelAreaStyleSelector internal class

		#region DPHeaderPrefixAreaStyleSelector internal class

		/// <summary>
		/// Supplies the style for a record selector
		/// </summary>
		internal class DPHeaderPrefixAreaStyleSelector : FieldLayoutSettingsStyleSelector
		{
			internal DPHeaderPrefixAreaStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldLayoutSettings.HeaderPrefixAreaStyleProperty, null, typeof(HeaderPrefixArea))
			{
			}

			#region SelectStyle

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Record record = item as Record;
				FieldLayout fieldLayout = null;

				if (record != null)
					fieldLayout = record.FieldLayout;

				if (fieldLayout == null && container != null)
				{
					if (container is HeaderPrefixArea)
						fieldLayout = ((HeaderPrefixArea)container).FieldLayout;

					if (fieldLayout == null && container is Visual)
						fieldLayout = Utilities.GetAncestorPropertyValue((Visual)container, HeaderPrefixArea.FieldLayoutProperty, this._presenter) as FieldLayout;
				}

                return this.SelectStyle(fieldLayout, item, container);
			}

			#endregion //SelectStyle
		}

		#endregion //DPHeaderPrefixAreaStyleSelector internal class

		#region DPRecordPresenterStyleSelector internal class

		/// <summary>
		/// Supplies the style for each record presenter
		/// </summary>
        internal class DPRecordPresenterStyleSelector : FieldLayoutSettingsStyleSelector
        {
            private GroupByRecordStyleSelector groupBySelector;
            private ExpandableFieldRecordStyleSelector expandableSelector;

            internal DPRecordPresenterStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldLayoutSettings.DataRecordPresenterStyleProperty, FieldLayoutSettings.DataRecordPresenterStyleSelectorProperty, typeof(DataRecordPresenter))
            {
                this.groupBySelector = new GroupByRecordStyleSelector(presenter);
                this.expandableSelector = new ExpandableFieldRecordStyleSelector(presenter);
            }

            #region SelectStyle

            public override Style SelectStyle(object item, DependencyObject container)
            {
                this._presenter.VerifyCurrentPanel(item, container);

                Record record = item as Record;

                // Use a separate routine for getting the style GroupBy and ExpandableField records
                if (record != null)
                {
                    if (record is GroupByRecord)
                        return this.groupBySelector.SelectStyle(record, container);
                    else if (record is ExpandableFieldRecord)
                        return this.expandableSelector.SelectStyle(record, container);
                    
                    
                    if (record is SummaryRecord)
                        return this.SelectSummaryPresenterStyle(record, container);

                    // Fall thru and default to selecting a DataRecord style.
                }

                FieldLayout fieldLayout = null;

                if (record != null)
                    fieldLayout = record.FieldLayout;

                if (fieldLayout == null && container != null)
                {
                    if (container is RecordPresenter)
                        fieldLayout = ((RecordPresenter)container).FieldLayout;

                    if (fieldLayout == null && container is Visual)
                        fieldLayout = Utilities.GetAncestorPropertyValue((Visual)container, RecordPresenter.FieldLayoutProperty, this._presenter) as FieldLayout;
                }

                return this.SelectStyle(fieldLayout, item, container);
            }

            #endregion //SelectStyle

            #region SelectSummaryPresenterStyle

            
            

            private Style SelectSummaryPresenterStyle(Record record, DependencyObject container)
            {
                //Style style = null;
                //StyleSelector selector = null;
                FieldLayout fieldLayout = record.FieldLayout;

                if (false && fieldLayout != null)
                {
                    
                    
#region Infragistics Source Cleanup (Region)



















#endregion // Infragistics Source Cleanup (Region)

                }

                // finally get the default style 
                return this._presenter.GetDefaultStyle(typeof(SummaryRecordPresenter));
            }

            #endregion // SelectSummaryPresenterStyle

            #region GroupByRecordStyleSelector
            private class GroupByRecordStyleSelector : FieldSettingsStyleSelector
            {
                internal GroupByRecordStyleSelector(DataPresenterBase presenter) :
                    base(presenter, FieldSettings.GroupByRecordPresenterStyleProperty, FieldSettings.GroupByRecordPresenterStyleSelectorProperty, typeof(GroupByRecordPresenter))
                {
                }

                public override Style SelectStyle(object item, DependencyObject container)
                {
                    GroupByRecord record = item as GroupByRecord;
                    Debug.Assert(null != record);
                    Field field = record.AssociatedField;

                   return this.SelectStyle(field, record.FieldLayout, item, container);
                }
            }
            #endregion //GroupByRecordStyleSelector

            #region ExpandableFieldRecordStyleSelector
            private class ExpandableFieldRecordStyleSelector : FieldSettingsStyleSelector
            {
                internal ExpandableFieldRecordStyleSelector(DataPresenterBase presenter) :
                    base(presenter, FieldSettings.ExpandableFieldRecordPresenterStyleProperty, FieldSettings.ExpandableFieldRecordPresenterStyleSelectorProperty, typeof(ExpandableFieldRecordPresenter))
                {
                }

                public override Style SelectStyle(object item, DependencyObject container)
                {
                    ExpandableFieldRecord record = item as ExpandableFieldRecord;
                    Debug.Assert(null != record);
                    Field field = record.AssociatedField;

                    return this.SelectStyle(field, record.FieldLayout, item, container);
                }
            }
            #endregion //ExpandableFieldRecordStyleSelector		}
        }
		#endregion //DPRecordPresenterStyleSelector internal class

		#region DPRecordSelectorStyleSelector internal class

		/// <summary>
		/// Supplies the style for a record selector
		/// </summary>
		internal class DPRecordSelectorStyleSelector : FieldLayoutSettingsStyleSelector
		{
			internal DPRecordSelectorStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldLayoutSettings.RecordSelectorStyleProperty, FieldLayoutSettings.RecordSelectorStyleSelectorProperty, typeof(RecordSelector))
			{
			}

			#region SelectStyle

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Record record = item as Record;
				FieldLayout fieldLayout = null;

				if (record != null)
					fieldLayout = record.FieldLayout;

				if (fieldLayout == null && container != null)
				{
					if (container is RecordSelector)
						fieldLayout = ((RecordSelector)container).FieldLayout;

					if (fieldLayout == null && container is Visual)
						fieldLayout = Utilities.GetAncestorPropertyValue((Visual)container, RecordSelector.FieldLayoutProperty, this._presenter) as FieldLayout;
				}

                return this.SelectStyle(fieldLayout, item, container);
			}

			#endregion //SelectStyle
		}

		#endregion //DPRecordSelectorStyleSelector internal class

		#region DPRecordCellAreaStyleSelector internal class

		/// <summary>
		/// Supplies the style for a record selector
		/// </summary>
		internal class DPRecordCellAreaStyleSelector : FieldLayoutSettingsStyleSelector
		{
			internal DPRecordCellAreaStyleSelector(DataPresenterBase presenter) :
                base(presenter, FieldLayoutSettings.DataRecordCellAreaStyleProperty, FieldLayoutSettings.DataRecordCellAreaStyleSelectorProperty, typeof(DataRecordCellArea))
			{
			}

			#region SelectStyle

			public override Style SelectStyle(object item, DependencyObject container)
			{
				Record record = item as Record;
				FieldLayout fieldLayout = null;

				if (record != null)
					fieldLayout = record.FieldLayout;

				if (fieldLayout == null && container != null)
				{
					if (container is DataRecordCellArea)
						fieldLayout = ((DataRecordCellArea)container).FieldLayout;

					if (fieldLayout == null && container is Visual)
						fieldLayout = Utilities.GetAncestorPropertyValue((Visual)container, DataRecordCellArea.FieldLayoutProperty, this._presenter) as FieldLayout;
				}

                return this.SelectStyle(fieldLayout, item, container);
			}

			#endregion //SelectStyle
		}

		#endregion //DPRecordCellAreaStyleSelector internal class

		#endregion //Selector classes (Refactored)

		#region ICommandHost Members

		#region ICommandHost.CurrentState

		// SSP 3/18/10 TFS29783 - Optimizations
		// Changed CurrentState property to a method.
		// 
		//Int64 ICommandHost.CurrentState
		Int64 ICommandHost.GetCurrentState( Int64 statesToQueryLong )
		{
			States currentState = 0;

			States statesToQuery = (States)statesToQueryLong;

			// AS 7/27/09 Optimization
			//if (this.SelectedItems.HasCells ||
			//	this.SelectedItems.HasFields ||
			//	this.SelectedItems.HasRecords)
			SelectedItemHolder selection = this.SelectedItems;


			// SSP 3/18/10 TFS29783 - Optimizations
			// Changed CurrentState property to a method that takes in states to query flags. Changed the 
			// following code to use the query flags to only calculate state that's queried for. The original
			// code is commented out below.
			// 
			// ----------------------------------------------------------------------------------------------
			if ( selection.HasSelection )
			{
				currentState |= States.ItemsSelected;

				if ( 0 != ( States.DataRecordsSelected & statesToQuery ) && selection.HasRecords && selection.Records[0] is DataRecord )
					currentState |= States.DataRecordsSelected;

				// AS 4/8/09 NA 2009.2 ClipboardSupport
				if ( 0 != ( States.CellsSelected & statesToQuery ) && selection.HasCells )
					currentState |= States.CellsSelected;
			}

			// SSP 3/18/10 TFS29783 - Optimizations
			// 
			//if ( this.RecordManager.ViewableRecords.Count > 0 )
			if ( 0 != ( States.Records & statesToQuery ) && this.RecordManager.ViewableRecords.Count > 0 )
				currentState |= States.Records;

			IViewPanel panelNavigator = this.CurrentPanel as IViewPanel;

			Record activeRecord = this.ActiveRecord as Record;

			if ( activeRecord != null )
			{
				currentState |= States.Record;

				DataRecord activeDataRecord = activeRecord as DataRecord;

				if ( 0 != ( States.RecordExpandable & statesToQuery ) && activeRecord.ExpansionIndicatorVisibility == Visibility.Visible )
					currentState |= States.RecordExpandable;

				if ( 0 != ( States.RecordHasPendingChanges & statesToQuery ) && activeDataRecord != null && activeDataRecord.IsDataChanged )
					currentState |= States.RecordHasPendingChanges;

				if ( 0 != ( States.RecordExpanded & statesToQuery ) && activeRecord.IsExpanded )
					currentState |= States.RecordExpanded;

				if ( 0 != ( States.GroupByRecord & statesToQuery ) && activeRecord is GroupByRecord )
					currentState |= States.GroupByRecord;

				if ( 0 != ( States.ExpandableFieldRecord & statesToQuery ) && activeRecord is ExpandableFieldRecord )
					currentState |= States.ExpandableFieldRecord;

				// JJD 12/30/08 - NA 2009 Vol 1 filtering
				// Set filterrecord states if appropriate
				FilterRecord fr = activeRecord as FilterRecord;
				if ( fr != null )
				{
					currentState |= States.FilterRecord;

					if ( 0 != ( States.FilterRecordHasActiveFilters & statesToQuery ) && fr.HasActiveFilters )
						currentState |= States.FilterRecordHasActiveFilters;
				}

				if ( panelNavigator != null )
				{
					if ( 0 != ( States.RecordFirstDisplayed & statesToQuery ) && activeRecord == panelNavigator.GetFirstDisplayedRecord( typeof( Record ) ) )
						currentState |= States.RecordFirstDisplayed;

					if ( 0 != ( States.RecordLastDisplayed & statesToQuery ) && activeRecord == panelNavigator.GetLastDisplayedRecord( typeof( Record ) ) )
						currentState |= States.RecordLastDisplayed;

					if ( 0 != ( States.RecordFirstOverall & statesToQuery ) && activeRecord == panelNavigator.GetFirstOverallRecord( typeof( Record ) ) )
						currentState |= States.RecordFirstOverall;

					if ( 0 != ( States.RecordLastOverall & statesToQuery ) && activeRecord == panelNavigator.GetLastOverallRecord( typeof( Record ) ) )
						currentState |= States.RecordLastOverall;
				}

				Cell activeCell = this.ActiveCell;

				if ( activeCell != null )
				{
					currentState |= States.Cell;

					// AS 7/27/09 NA 2009.2 Field Sizing
					//if (this.CellValuePresenterInEdit != null)
					if ( 0 != ( States.IsInEditMode & statesToQuery ) && this.EditHelper.CellValuePresenter != null )
						currentState |= States.IsInEditMode;

					if ( panelNavigator != null )
					{
						if ( 0 != ( States.CellFirstDisplayed & statesToQuery ) )
						{
							DataRecord firstDisplayedRecord = panelNavigator.GetFirstDisplayedRecord( typeof( DataRecord ) ) as DataRecord;
							// AS 2/27/09 TFS14730/Optimization
							// Added helper method to avoid allocating the cell just to see if its last/first.
							//
							//if (firstDisplayedRecord != null && activeCell == firstDisplayedRecord.FirstDisplayedCell)
							if ( firstDisplayedRecord != null && firstDisplayedRecord.IsFirstDisplayedCell( activeCell ) )
								currentState |= States.CellFirstDisplayed;
						}

						if ( 0 != ( States.CellLastDisplayed & statesToQuery ) )
						{
							DataRecord lastDisplayedRecord = panelNavigator.GetLastDisplayedRecord( typeof( DataRecord ) ) as DataRecord;
							// AS 2/27/09 TFS14730/Optimization
							// Added helper method to avoid allocating the cell just to see if its last/first.
							//
							//if (lastDisplayedRecord != null && activeCell == lastDisplayedRecord.LastDisplayedCell)
							if ( lastDisplayedRecord != null && lastDisplayedRecord.IsLastDisplayedCell( activeCell ) )
								currentState |= States.CellLastDisplayed;
						}
					}

					if ( 0 != ( States.CellFirstOverall & statesToQuery ) )
					{
						DataRecord firstOverallRecord = this.FirstOverallDataRecord;
						// AS 2/27/09 TFS14730/Optimization
						// Added helper method to avoid allocating the cell just to see if its last/first.
						//
						//if (firstOverallRecord != null && activeCell == firstOverallRecord.FirstDisplayedCell)
						if ( firstOverallRecord != null && firstOverallRecord.IsFirstDisplayedCell( activeCell ) )
							currentState |= States.CellFirstOverall;
					}

					if ( 0 != ( States.CellLastOverall & statesToQuery ) )
					{
						DataRecord lastOverallRecord = this.LastOverallDataRecord;
						// AS 2/27/09 TFS14730/Optimization
						// Added helper method to avoid allocating the cell just to see if its last/first.
						//
						//if (lastOverallRecord != null && activeCell == lastOverallRecord.LastDisplayedCell)
						if ( lastOverallRecord != null && lastOverallRecord.IsLastDisplayedCell( activeCell ) )
							currentState |= States.CellLastOverall;
					}

					if ( activeDataRecord != null )
					{
						// AS 2/27/09 TFS14730/Optimization
						// Added helper method to avoid allocating the cell just to see if its last/first.
						// Also, just because its the first doesn't mean its not the last so I removed the 
						// else.
						//
						//if (activeCell == activeDataRecord.FirstDisplayedCell)
						//    currentState |= States.CellFirstInRecord;
						//else
						//    if (activeCell == activeDataRecord.LastDisplayedCell)
						//        currentState |= States.CellLastInRecord;
						if ( 0 != ( States.CellFirstInRecord & statesToQuery ) && activeDataRecord.IsFirstDisplayedCell( activeCell ) )
							currentState |= States.CellFirstInRecord;

						if ( 0 != ( States.CellLastInRecord & statesToQuery ) && activeDataRecord.IsLastDisplayedCell( activeCell ) )
							currentState |= States.CellLastInRecord;
					}

					// JJD 12/30/08 - NA 2009 Vol 1 filtering
					// Set filtercell states if appropriate
					FilterCell fc = activeCell as FilterCell;
					if ( fc != null )
					{
						currentState |= States.FilterCell;

						if ( 0 != ( States.FilterCellHasActiveFilters & statesToQuery ) && fc.HasActiveFilters )
							currentState |= States.FilterCellHasActiveFilters;
					}

				}
			}

			if ( panelNavigator != null )
			{
				if ( panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewHorizontal )
					currentState |= States.NavigationLayoutStyleGridViewHorizontal;
				else
					if ( panelNavigator.LayoutStyle == PanelLayoutStyle.GridViewVertical )
						currentState |= States.NavigationLayoutStyleGridViewVertical;
					// JM 02-24-10 TFS28244
					else if ( this.CurrentViewInternal is CardView )
					{
						CardViewSettings viewSettings = ( (CardView)this.CurrentViewInternal ).ViewSettings;
						if ( viewSettings.Orientation == Orientation.Vertical )
							currentState |= States.NavigationLayoutStyleCardViewHorizontal;
						else
							currentState |= States.NavigationLayoutStyleCardViewVertical;
					}
			}

			// AS 3/3/11 NA 2011.1 - Async Exporting
			if (0 != (States.IsExporting & statesToQuery) && this.IsExporting)
				currentState |= States.IsExporting;

			// AS 3/10/11 NA 2011.1 - Async Exporting
			// If we're exporting but haven't finished the initialization then 
			// some functions cannot be allowed.
			//
			if (0 != (States.IsExportingInitializing & statesToQuery) && !this.IsExporting && _cachedExportStatus != RecordExportStatus.Exporting)
				currentState |= States.IsExportingInitializing;

			
#region Infragistics Source Cleanup (Region)


































































































































































#endregion // Infragistics Source Cleanup (Region)

			// ----------------------------------------------------------------------------------------------

			return (Int64)currentState & statesToQueryLong;
		}

		#endregion //ICommandHost.CurrentState

        #region ICommandHost.CanExecute

        // AS 2/5/08 ExecuteCommandInfo
		//bool ICommandHost.CanExecute(RoutedCommand command, object commandParameter)
		bool ICommandHost.CanExecute(ExecuteCommandInfo commandInfo)
		{
			RoutedCommand command = commandInfo.RoutedCommand;

            if (null != command)
            {
                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
                FixedFieldLocation? location = null;

				if (command == DataPresenterCommands.FixFieldNear)
					location = FixedFieldLocation.FixedToNearEdge;
				else if (command == DataPresenterCommands.FixFieldFar)
					location = FixedFieldLocation.FixedToFarEdge;
				else if (command == DataPresenterCommands.UnfixField)
					location = FixedFieldLocation.Scrollable;
				// AS 4/8/09 NA 2009.2 ClipboardSupport
				else if (command == DataPresenterCommands.Undo)
					// AS 1/12/11 TFS59619
					//return null != _history && _history.CanUndo();
					return this.CanExecuteUndoCommand(commandInfo);
				else if (command == DataPresenterCommands.Redo)
					// AS 1/12/11 TFS59619
					//return null != _history && _history.CanRedo();
					return this.CanExecuteUndoCommand(commandInfo);
				else if (command == DataPresenterCommands.Cut)
					return this.ClipboardOperationInfo.CanPerformOperation(ClipboardOperation.Cut);
				else if (command == DataPresenterCommands.Copy)
					return this.ClipboardOperationInfo.CanPerformOperation(ClipboardOperation.Copy);
				else if (command == DataPresenterCommands.Paste)
					return this.ClipboardOperationInfo.CanPerformOperation(ClipboardOperation.Paste);
				else if (command == DataPresenterCommands.ClearCellContents)
					return this.ClipboardOperationInfo.CanPerformOperation(ClipboardOperation.ClearContents);
				// AS 6/3/09 NA 2009.2 Undo/Redo
				else if (command == DataPresenterCommands.ToggleRecordIsExpanded)
					return CanToggleIsExpanded(commandInfo);
				// AS 6/9/09 NA 2009.2 Field Sizing
				else if (command == DataPresenterCommands.AutoSizeField)
					return CanAutoSizeField(commandInfo);
				// JM 11/5/09 NA 2010.1 CardView
				else if (command == DataPresenterCommands.ToggleCardCollapsedState)
					return CanToggleCardCollapsedState(commandInfo);
				// JM 11/5/09 NA 2010.1 CardView
				else if (command == DataPresenterCommands.ToggleEmptyCardCellsCollapsedState)
					return CanToggleEmptyCardCellsCollapsedState(commandInfo);

                if (null != location)
                {
					Field field = commandInfo.Parameter as Field;

                    if (field == null)
                        return false;

                    return field.IsFixedLocationAllowed(location.Value);
                }
            }

			return command != null && command.OwnerType == typeof(DataPresenterCommands);
		}

		#endregion //ICommandHost.CanExecute

		#region ICommandHost.Execute

		// AS 2/5/08 ExecuteCommandInfo
		//void ICommandHost.Execute(ExecutedRoutedEventArgs args)
		bool ICommandHost.Execute(ExecuteCommandInfo commandInfo)
		{
			// AS 2/5/08 ExecuteCommandInfo
			//RoutedCommand command = args.Command as RoutedCommand;
			//if (command != null)
			//    args.Handled = this.ExecuteCommandImpl(command, args.Parameter);
			// AS 6/3/09 NA 2009.2 ClipboardSupport
			//RoutedCommand command = commandInfo.RoutedCommand;
			//return null != command && this.ExecuteCommandImpl(command, commandInfo.Parameter, true);
			return null != commandInfo.RoutedCommand && this.ExecuteCommandImpl(commandInfo, true);
		}

		#endregion //ICommandHost.Execute

		#endregion //ICommandHost Members

		#region IDeferredScrollHost Members

		IDeferredScrollPanel IDeferredScrollHost.ScrollPanel
		{
			get { return this.CurrentPanel as IDeferredScrollPanel; }
		}

		#endregion //IDeferredScrollHost

		#region IViewPanelInfo Members

		#region OverallScrollCount

		int IViewPanelInfo.OverallScrollCount
		{
			get 
			{
				// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
				// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
				// calculating scroll count.
				// 
				// --------------------------------------------------------------------------------
				//return this._overallScrollCount; 
				if ( _cachedOverallScrollCountDirty )
				{
					_cachedOverallScrollCount = null != this.ViewableRecords
						? this.ViewableRecords.ScrollCount : 0;

					_cachedOverallScrollCountDirty = false;
				}

				return _cachedOverallScrollCount;
				// --------------------------------------------------------------------------------
			}
		}

		#endregion //OverallScrollCount

		#region OverallScrollPosition

		int IViewPanelInfo.OverallScrollPosition
		{
			get
			{
				//return Math.Min(this._overallScrollPosition, this._overallScrollCount - 1);
				// SSP 8/12/09 - NAS9.2 Enhanced grid-view - Optimizations
				// Renamed _overallScrollCount to _cachedOverallScrollCount and now we are lazily
				// calculating scroll count.
				// 
				//return Math.Max(0, Math.Min(this._overallScrollPosition, this._overallScrollCount - 1));
				return Math.Max( 0, Math.Min( this._overallScrollPosition, ( (IViewPanelInfo)this ).OverallScrollCount - 1 ) );
			}
			set
			{
				if (value != this._overallScrollPosition)
				{
					// JJD 04/13/12 - TFS108986 - Optimization
					#region Suspend summary calculations for the next 'x' milliseconds

					// After a scroll operation we want to suspend summary calculations for a short period
					// of time (based on how many records have been scrolled) to avoid costly summary
					// calculation overhead in continuous scroll operations.
					int delta = Math.Abs(value - _overallScrollPosition);
					int waitMs = Math.Max( Math.Min( 350, delta * 100 ), 100 );

					// create a timer to notify us when the wait time has expired
					if (_isScrollingTimer == null)
					{
						_isScrollingTimer = new DispatcherTimer(DispatcherPriority.Render, this.Dispatcher);
						_isScrollingTimer.Tick += new EventHandler(OnIsScrollingTimerTick);
						this.SetValue(IsScrollingPropertyKey, KnownBoxes.TrueBox);
					}
					else
					{
						if (_isScrollingTimer.IsEnabled)
							_isScrollingTimer.Stop();
						else
							this.SetValue( IsScrollingPropertyKey, KnownBoxes.TrueBox );
					}

					// set the interval and start the timer
					_isScrollingTimer.Interval = TimeSpan.FromMilliseconds(waitMs);
					_isScrollingTimer.Start();

					#endregion //Suspend summary calculations for the next 'x' milliseconds	
    	
					//Debug.Assert(value >= 0);
					//Debug.Assert(value < ((IViewPanelInfo)this).OverallScrollCount);

					this._overallScrollPosition = Math.Max(0, Math.Min(value, ((IViewPanelInfo)this).OverallScrollCount - 1));

					// JM 01-18-10 TFS25888
					if (this.CurrentPanel is CardViewPanel)
						((CardViewPanel)this.CurrentPanel).SetScrollPosition(this._overallScrollPosition);

					this.BumpRecordsInViewVersion();
				}
			}
		}

		#endregion //OverallScrollPosition

		#region IsOkToScroll

		bool IViewPanelInfo.IsOkToScroll()
		{
			Cell cell = this.ActiveCell;

			// AS 7/24/09 NA 2009.2 Field Sizing
			// When we are in the process of scrolling the edit cell into view, we do not 
			// want to exit edit mode.
			//
			//if (cell != null && cell.IsInEditMode)
			if (cell != null && cell.IsInEditMode && _endEditOnScrollSuspendCount == 0)
			{
				// JJD 10/28/10 - TFS25570 
				// If the record is fixed and it is a root record, i.e. no parent, then
				// there is no ned to come out of edit mode to scroll
				Record rcd = cell.Record;
				if (rcd != null && (rcd.IsFixed == false || rcd.ParentRecord != null))
				{
					// attempt to exit edit mode
					cell.EndEditMode(true, false);

					// if the exit was cancelled then return false to provent
					// the scroll
					if (cell.IsInEditMode)
						return false;
				}
			}

			return true;
		}

		#endregion //IsOkToScroll

		#region GetOverallScrollPositionForRecord

		int IViewPanelInfo.GetOverallScrollPositionForRecord(Record record)
		{
			if (record == null)
				throw new ArgumentNullException("record");

			if (record.DataPresenter != this)
				throw new ArgumentException(DataPresenterBase.GetString("LE_ArgumentException_13"), "record");

			return record.OverallScrollPosition;
		}

		#endregion //GetOverallScrollPositionForRecord

		#region GetRecordAtOverallScrollPosition

		Record IViewPanelInfo.GetRecordAtOverallScrollPosition(int scrollPosition)
		{
			if (scrollPosition < 0)
				return null;

			int scrollCount = ((IViewPanelInfo)this).OverallScrollCount;

			if (scrollPosition >= scrollCount)
				return null;

			return this.ViewableRecords.GetRecordAtScrollPosition(scrollPosition);
		}

		#endregion //GetRecordAtOverallScrollPosition

		#region OnRecordsInViewChanged

		void IViewPanelInfo.OnRecordsInViewChanged()
		{
			// bump the records ion view version
			this.BumpRecordsInViewVersion();

            
#region Infragistics Source Cleanup (Region)







#endregion // Infragistics Source Cleanup (Region)


            // JJD 3/29/08 - added support for printing.
            // We can't do asynchronous operations during a print
            //
            // MBS 7/29/09 - NA9.2 Excel Exporting
            //if (this.IsReportControl)
            if(this.IsSynchronousControl)
            {
				// AS 2/26/10 TFS28159
				this.NotifyAutoSizeInViewRecordsChanged();

                // AS 2/24/09 Optimization
                //this.ProcessPostedRecordsInViewChanged();
                this.ProcessPostedRecordsInViewChanged(null);
            }
            else
			// raise the event
			if (this._postRecordsInViewChangedOperation == null)
            {
				// AS 2/26/10 TFS28159
				this.NotifyAutoSizeInViewRecordsChanged();

				// AS 2/24/09 Optimization
                // Instead of always bumping the ScrollVerion above, we'll pass the current 
                // ScrollVersion along in the BeginInvoke and if it still hasn't changed 
                // by the time we process that then we will bump the version number.
                //
                //this._postRecordsInViewChangedOperation = this.Dispatcher.BeginInvoke(DispatcherPriority.Render, new GridUtilities.MethodDelegate(this.ProcessPostedRecordsInViewChanged));
                object scrollVersion = this.CellContainerGenerationMode != CellContainerGenerationMode.PreLoad ? this.GetValue(ScrollVersionProperty) : null;
                this._postRecordsInViewChangedOperation = this.Dispatcher.BeginInvoke(DispatcherPriority.Render, new DispatcherOperationCallback(this.ProcessPostedRecordsInViewChanged), scrollVersion);
            }
		}

		// AS 2/26/10 TFS28159
		// The panel may have prepared more records than it actually considers in view 
		// and the virtualizing data record cell panel won't be modified during a scroll 
		// but we could have missed processing some elements because they weren't part 
		// of the records in view.
		//
		private void NotifyAutoSizeInViewRecordsChanged()
		{
			if (this.FieldLayoutAutoSizeRecordsInViewCount > 0)
			{
				for (int i = 0, count = _fieldLayouts.Count; i < count; i++)
				{
					FieldLayout fl = _fieldLayouts[i];

					if (fl.IsInitialRecordLoaded)
					{
						fl.AutoSizeInfo.OnRecordsInViewChanged();
					}
				}
			}
		}

		#endregion //OnRecordsInViewChanged

		#endregion // IViewPanelInfo Members

        #region IEmbeddedVisualPaginatorFactory Members

        /// <summary>
        /// This method creates, initializes and return an instance of DataPresenterReportControl.
        /// </summary>
        /// <returns>The instance of DataPresenterReportControl which will be use for printing</returns>
        IEmbeddedVisualPaginator IEmbeddedVisualPaginatorFactory.Create()
        {
            //DataPresenterReportControl	dprc	= new DataPresenterReportControl(this, new DataPresenterReportSettings());
            DataPresenterReportControl	dprc	= new DataPresenterReportControl(this);
            // We don't add this to our logical tree
            //this.AddLogicalChild(dprc);
            return dprc;
        }

        #endregion

		// JJD 8/18/20 - TFS36399 - added IWeakEventListener
		#region IWeakEventListener Members

		bool IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e)
		{
			return this.OnReceiveWeakEvent(managerType, sender, e);
		}

		#endregion

		// JJD 03/08/12 - TFS101199 - Added touch support

		#region ISupportScrollHelper Members

		#region Properties

		#region HorizontalMax

		double ISupportScrollHelper.HorizontalMax
		{
			get
			{
				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null && sinfo.CanHorizontallyScroll)
					return Math.Max(sinfo.ExtentWidth - sinfo.ViewportWidth, 0);

				return 0;
			}
		}

		#endregion //HorizontalMax	
    
		#region HorizontalScrollType

		ScrollType ISupportScrollHelper.HorizontalScrollType
		{
			get
			{
				ViewBase view = this.CurrentViewInternal;
				if (view.HasLogicalOrientation)
					return view.LogicalOrientation == Orientation.Vertical ? ScrollType.Pixel : ScrollType.Item;
				else
					return ScrollType.Item;
			}
		}

		#endregion //HorizontalScrollType

		#region HorizontalValue

		double ISupportScrollHelper.HorizontalValue
		{
			get
			{
				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null)
					return GetScrollValueHelper(sinfo.HorizontalOffset, ref _cachedHorizValue);

				return 0;
			}
			set
			{
				_cachedHorizValue = value;

				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null)
					sinfo.SetHorizontalOffset(value);
			}
		}

		#endregion //HorizontalValue	
    
		#region VerticalMax

		double ISupportScrollHelper.VerticalMax
		{
			get
			{
				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null && sinfo.CanVerticallyScroll)
					return Math.Max(sinfo.ExtentHeight - sinfo.ViewportHeight, 0);

				return 0;
			}
		}


		#endregion //VerticalMax

		#region VerticalScrollType

		ScrollType ISupportScrollHelper.VerticalScrollType
		{
			get
			{
				ViewBase view = this.CurrentViewInternal;
				if (view.HasLogicalOrientation)
					return view.LogicalOrientation == Orientation.Vertical ? ScrollType.Item : ScrollType.Pixel;
				else
					return ScrollType.Item;
			}
		}

		#endregion //VerticalScrollType

		#region VerticalValue

		double ISupportScrollHelper.VerticalValue
		{
			get
			{
				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null)
					return GetScrollValueHelper(sinfo.VerticalOffset, ref _cachedVertValue);

				return 0;
			}
			set
			{
				_cachedVertValue = value;

				IScrollInfo sinfo = this.CurrentPanel as IScrollInfo;

				if (sinfo != null)
					sinfo.SetVerticalOffset(value);
			}
		}

		#endregion //VerticalValue	
    
		#endregion //Properties	
    
		#region Methods

		#region GetFirstItemHeight

		double ISupportScrollHelper.GetFirstItemHeight()
		{
			return this.GetFirstItemExtentHelper(false);
		}

		#endregion //GetFirstItemHeight	
    
		#region GetFirstItemWidth

		double ISupportScrollHelper.GetFirstItemWidth()
		{
			return this.GetFirstItemExtentHelper(true);
		}

		#endregion //GetFirstItemWidth	
    
		#region GetScrollModeFromPoint

		TouchScrollMode ISupportScrollHelper.GetScrollModeFromPoint(Point point, UIElement elementDirectlyOver)
		{
			if (elementDirectlyOver == null || !this.CurrentViewInternal.IsPanningModeSupported)
				return TouchScrollMode.None;

			ViewBase view = this.CurrentViewInternal;

			#region Get the associated Record and/or Field

			Field fld = null;
			Record rcd = null;
			DataItemPresenter dip = Utilities.GetAncestorFromType(elementDirectlyOver, typeof(DataItemPresenter), true, this) as DataItemPresenter;

			if (dip != null)
			{
				CellValuePresenter cvp = dip as CellValuePresenter;

				if (cvp != null)
				{
					// if the point is over a cell in edit mode we don't want to allow 
					// touch scrolling
					if (cvp.IsInEditMode)
						return TouchScrollMode.None;

					rcd = cvp.Record;
					fld = cvp.Field;

				}
				else
				{
					LabelPresenter lp = dip as LabelPresenter;

					// JJD 03/28/12 - TFS106955
					// Ignore LabelPresenters that are in the GroupByArea
					if (lp != null && !lp.IsInGroupByArea)
					{
						fld = lp.Field;

						// JJD 03/28/12 - TFS106955
						// Try to get the associated rcd by looking for an ancestor RecordPresenter
						RecordPresenter rp = Utilities.GetAncestorFromType(lp, typeof(RecordPresenter), true, this) as RecordPresenter;

						if (rp != null)
							rcd = rp.Record;
					}
				}
			}
			else
			{
				RecordPresenter rp = Utilities.GetAncestorFromType(elementDirectlyOver, typeof(RecordPresenter), true, this) as RecordPresenter;

				if (rp != null)
					rcd = rp.Record;
			}
			#endregion //Get the associated Record and/or Field

			bool canScrollRecords = rcd != null && (rcd.NestingDepth >= 0 || false == rcd.IsFixed);
			bool canScrollFields = (fld == null && rcd != null ) || (fld != null && !fld.IsFixed);

			// if we can't scroll either records or fields then return 'None'
			if (false == canScrollRecords &&
				false == canScrollFields)
				return TouchScrollMode.None;

			bool scrollRecordsVertically;

			if (view.HasLogicalOrientation)
				scrollRecordsVertically = view.LogicalOrientation == Orientation.Vertical;
			else
			{
				scrollRecordsVertically = ((ISupportScrollHelper)this).VerticalMax > 0;

				// we only support scrolling of fields for views that has a logical orientation
				canScrollFields = false;
			}

			#region Return the appropriate mode based on the view's logical orientation

			if (canScrollRecords)
			{
				if (canScrollFields)
					return TouchScrollMode.Both;

				if (scrollRecordsVertically)
					return TouchScrollMode.Vertical;
				else
					return TouchScrollMode.Horizontal;
			}
			else
			{
				if (false == canScrollFields)
					return TouchScrollMode.None;

				if (scrollRecordsVertically)
					return TouchScrollMode.Horizontal;
				else
					return TouchScrollMode.Vertical;
			}

			#endregion //Return the appropriate mode based on the view's logical orientation

		}

		#endregion //GetScrollModeFromPoint

		#region InvalidateScrollLayout

		void ISupportScrollHelper.InvalidateScrollLayout()
		{
			
		}

		#endregion //InvalidateScrollLayout	
    
		#region OnPanComplete

		void ISupportScrollHelper.OnPanComplete()
		{
			_cachedHorizValue = null;
			_cachedVertValue = null;
		}

		#endregion //OnPanComplete	
    
		#region OnStateChanged

		void ISupportScrollHelper.OnStateChanged(TouchState newState, TouchState oldState)
		{
		}

		#endregion //OnStateChanged	
    
		#endregion //Methods	

		#endregion

		// JJD 3/1/11 - TFS66934 - Optimization - added async support for page scrolling
		#region AsyncPageCommand

		private class AsyncPageCommand
		{
			#region Private Members

			private DataPresenterBase _dp;
			private RoutedCommand _command;

			#endregion //Private Members	
    
			#region Constructor

			internal AsyncPageCommand(DataPresenterBase dp)
			{
				_dp = dp;
				_dp.LayoutUpdated += new EventHandler(OnLayoutUpdated);
			}

			#endregion //Constructor	

			#region Properties

				#region Command

			internal RoutedCommand Command
			{
				get { return _command; }
				set { _command = value; }
			}

				#endregion //Command

			#endregion //Properties	
        
			#region Methods

				#region Detach

			internal void Detach()
			{
				_dp.LayoutUpdated -= new EventHandler(OnLayoutUpdated);
			}

				#endregion //Detach	
    
				#region OnLayoutUpdated

			private void OnLayoutUpdated(object sender, EventArgs e)
			{
				this.Detach();

				_dp.Dispatcher.BeginInvoke(DispatcherPriority.Background, new GridUtilities.MethodDelegate(this.ProcessCommand));
			}

				#endregion //OnLayoutUpdated

				#region ProcessCommand

			private void ProcessCommand()
			{
				_dp.ApplyAsyncCommand(this);
			}

				#endregion //ProcessCommand	
    
			#endregion //Methods
		}

		#endregion //AsyncPageCommand
		
		// JJD 3/1/11 - TFS66934 - Optimization - added throttling logic to key down processing
		#region KeyDownInfo

		private class KeyDownInfo
		{
			#region Private Members

			private int _tickCount;
			private Key _key;
			private ModifierKeys _modifiers;

			#endregion //Private Members	
    
			#region Constructor

			internal KeyDownInfo(Key key, ModifierKeys modifiers)
			{
				_tickCount = Environment.TickCount;

				_key = key;

				_modifiers = modifiers;
			}

			#endregion //Constructor	

			#region Properties

			internal Key Key 
			{ 
				get { return _key; } 
				set { _key = value; } 
			}
			internal ModifierKeys Modifiers 
			{ 
				get { return _modifiers; } 
				set { _modifiers = value; }  
			}
			internal int TickCount 
			{ 
				get { return _tickCount; }
				set { _tickCount = value; }
			}

			#endregion //Properties	
		}

		#endregion //KeyDownInfo

		// JJD 1/10/12 - TFS99025 - added
		#region RecordSelectionEnumerator private class

		private class RecordSelectionEnumerator : IEnumerator
		{
			#region Private Members

			private Record _record;
			private Record _pivotRcd;
			private Record _currentRecord;
			private RecordCollectionBase _currentCollection;
			private bool _forward;
			private bool _eofReached;
			private int _step;
			private int _currentIndex;

			#endregion //Private Members

			#region Constructor

			internal RecordSelectionEnumerator(Record record, Record pivotRcd, bool forward)
			{
				_record = record;
				_pivotRcd = pivotRcd;
				_forward = forward;
				_step = forward ? 1 : -1;
				this.Reset();
			}

			#endregion //Constructor	
    
			#region IEnumerator Members

			public object Current
			{
				get
				{
					if (_currentRecord == null)
					{
						if (this._eofReached)
							throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_26"));
						else
							throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_25"));
					}
					return _currentRecord;
				}
			}

			public bool MoveNext()
			{
				if (this._eofReached)
					throw new InvalidOperationException(DataPresenterBase.GetString("LE_InvalidOperationException_26"));

				// if we have already returned to target record the
				// set the eof flag and return false
				if (_currentRecord == _record)
				{
					_currentRecord = null;
					_eofReached = true;
					return false;
				}

				// increment/decrement the current index
				_currentIndex += _step;

				// check if the new index is in range
				if (_currentIndex >= 0 && _currentIndex < _currentCollection.Count)
					_currentRecord = _currentCollection[_currentIndex];
				else
				{
					if (_currentRecord == null)
						_currentRecord = _pivotRcd;

					// since it wasn't in range get the current records cross
					// parent sibling
					_currentRecord = _currentRecord.GetCrossParentSibling(_forward);

					Debug.Assert(_currentRecord != null, "There should have been a cross parent sibling");

					// if a sibling wasn't found then set the eof flag and return false
					if (_currentRecord == null)
					{
						_eofReached = true;
						return false;
					}

					// cache the sibling's index and parent collection
					_currentIndex = _currentRecord.Index;
					_currentCollection = _currentRecord.ParentCollection;
				}

				return true;
			}

			public void Reset()
			{
				_currentRecord = null;
				_currentIndex = _pivotRcd.Index;
				_currentCollection = _pivotRcd.ParentCollection;
				_eofReached = false;
			}

			#endregion
		}

		#endregion //RecordSelectionEnumerator private class	

		// AS 4/12/11 TFS62951
		#region FixedAreaScrollHelper class
		private class FixedAreaScrollHelper
		{
			#region Member Variables

			private FixedRecordLocation? _pivotFixedRecordLocation;
			private FixedFieldLocation? _pivotFixedFieldLocation;
			private FixedRecordLocation? _pivotFixedRecordLocationCell;
			private FixedFieldLocation? _pivotFixedFieldLocationCell;
			private DataPresenterBase _owner;

			private bool _isInitialCellFieldScrollPending;
			private bool _isInitialCellRecordScrollPending;
			private bool _isInitialRecordScrollPending;
			private bool _isInitialFieldScrollPending;

			#endregion //Member Variables

			#region Constructor
			internal FixedAreaScrollHelper(DataPresenterBase owner)
			{
				_owner = owner;
			}
			#endregion //Constructor

			#region Methods

			#region Internal Methods

			#region AdjustScrollInfoCallback
			internal void AdjustScrollInfoCallback(
				bool isHorizontal,
				System.Windows.Input.MouseEventArgs mouseArgs,
				ISelectableItem item,
				ref ScrollDirection? scrollDirection,
				ref double timerInterval)
			{
				if (scrollDirection != null)
					return;

				FieldLayout fl = GridUtilities.GetFieldLayout(item);

				if (null == fl)
					return;

				if (item is Field || item is Cell)
				{
					// we're only concerned with scrolling relative to the arrangement 
					// of the fixed fields which is opposite to the record arrangement
					if (fl.IsHorizontal != isHorizontal)
					{
						AdjustFieldScrollInfo(mouseArgs, item, ref scrollDirection, fl);
					}

					// for field's we're only doing fixed field scrolling so if it's a field
					// and we got here then we can bail out
					if (item is Field)
						return;
				}
			}

			#endregion //AdjustScrollInfoCallback

			#region OnPivotItemChanged
			internal void OnPivotItemChanged(ISelectableItem oldValue, ISelectableItem newValue)
			{
				if (oldValue is Cell && newValue == null)
				{
					_pivotFixedFieldLocationCell = null;
					_pivotFixedRecordLocationCell = null;
					_isInitialCellRecordScrollPending = false;
					_isInitialCellFieldScrollPending = false;
				}
				else if (newValue is Cell)
				{
					Debug.Assert(oldValue == null || oldValue is Cell, "Invalid combination - pivot cell");
					Cell cell = newValue as Cell;
					_pivotFixedRecordLocationCell = cell.Record.FixedLocation;
					_pivotFixedFieldLocationCell = cell.Field.FixedLocation;
					_isInitialCellRecordScrollPending = _pivotFixedRecordLocationCell != FixedRecordLocation.Scrollable;
					_isInitialCellFieldScrollPending = _pivotFixedFieldLocationCell != FixedFieldLocation.Scrollable;
				}
				else if (oldValue is Record && newValue == null)
				{
					_pivotFixedRecordLocation = null;
					_isInitialRecordScrollPending = false;
				}
				else if (newValue is Record)
				{
					Debug.Assert(oldValue == null || oldValue is Record, "Invalid combination - pivot record");
					Record record = newValue as Record;
					_pivotFixedRecordLocation = record.FixedLocation;
					_isInitialRecordScrollPending = _pivotFixedRecordLocation != FixedRecordLocation.Scrollable;
				}
				else if (oldValue is Field && newValue == null)
				{
					_pivotFixedFieldLocation = null;
					_isInitialFieldScrollPending = false;
				}
				else if (newValue is Field)
				{
					Debug.Assert(oldValue == null || oldValue is Field, "Invalid combination - pivot field");
					Field field = newValue as Field;
					_pivotFixedFieldLocation = field.FixedLocation;
					_isInitialFieldScrollPending = _pivotFixedFieldLocation != FixedFieldLocation.Scrollable;
				}

				if (newValue != null)
				{
					if (!_owner.IsFixedFieldsSupportedResolved)
					{
						_pivotFixedFieldLocation = null;
						_pivotFixedFieldLocationCell = null;
						_isInitialFieldScrollPending = false;
						_isInitialCellFieldScrollPending = false;
					}

					if (!_owner.IsFixedRecordsSupportedResolved)
					{
						_pivotFixedRecordLocation = null;
						_pivotFixedRecordLocationCell = null;
						_isInitialCellRecordScrollPending = false;
						_isInitialRecordScrollPending = false;
					}
				}
			}
			#endregion //OnPivotItemChanged

			#region VerifyNearestCompatibleItem
			internal ISelectableElement VerifyNearestCompatibleItem(ISelectableElement selectableElement, ISelectableItem relatedItem, MouseEventArgs e)
			{
				DataItemPresenter dip = selectableElement as DataItemPresenter;

				if (dip != null)
				{
					FixedFieldLocation? fieldLocation = null;
					bool isInitialScrollPending = false;

					if (relatedItem is Field)
					{
						fieldLocation = _pivotFixedFieldLocation;
						isInitialScrollPending = _isInitialFieldScrollPending;
					}
					else if (relatedItem is Cell)
					{
						fieldLocation = _pivotFixedFieldLocationCell;
						isInitialScrollPending = _isInitialCellFieldScrollPending;
					}

					// if the item we are over is a different location then the pivot item...
					if (fieldLocation != null)
					{
						VerifyCompatibleItemForField(ref selectableElement, relatedItem, dip, fieldLocation.Value, isInitialScrollPending);
					}
				}

				return selectableElement;
			}
			#endregion //VerifyNearestCompatibleItem

			#endregion //Internal Methods

			#region Private Methods

			#region AdjustFieldScrollInfo
			private void AdjustFieldScrollInfo(MouseEventArgs mouseArgs, ISelectableItem item, ref ScrollDirection? scrollDirection, FieldLayout fieldLayout)
			{
				if (!_owner.IsFixedFieldsSupportedResolved)
					return;

				FixedFieldLayoutInfo fixedFieldInfo = fieldLayout.GetFixedFieldInfo(false);

				// if we have fixed fields then we may need to do some extra processing
				if (fixedFieldInfo == null || !fixedFieldInfo.HasFixedFields)
					return;

				FixedFieldLocation? pivotFieldLocation = item is Cell ? _pivotFixedFieldLocationCell : _pivotFixedFieldLocation;

				if (null != pivotFieldLocation)
				{
					IInputElement hitTestElement = _owner.InputHitTest(mouseArgs.GetPosition(_owner));
					DataItemPresenter dip = null;

					if (hitTestElement is DependencyObject)
						dip = Utilities.GetAncestorFromType(hitTestElement as DependencyObject, typeof(DataItemPresenter), true, _owner) as DataItemPresenter;

					bool checkNearestItem = true;

					if (dip != null)
					{
						Field field = dip.Field;
						FixedFieldLocation itemFieldLocation = field.FixedLocation;

						// over the fixed far or near edge. we may need to scroll
						VirtualizingDataRecordCellPanel cellPanel = Utilities.GetAncestorFromType(dip, typeof(VirtualizingDataRecordCellPanel), true, null, typeof(RecordPresenter)) as VirtualizingDataRecordCellPanel;

						if (cellPanel == null)
							return;

						bool isScrolledToNearEdge, isScrolledToFarEdge;
						cellPanel.GetFixedEdgeScrollState(out isScrolledToNearEdge, out isScrolledToFarEdge);

						// if we started over the fixed and are over the fixed then don't scroll
						if (pivotFieldLocation == itemFieldLocation && itemFieldLocation == FixedFieldLocation.Scrollable)
							return;

						checkNearestItem = false;

						if (itemFieldLocation == FixedFieldLocation.FixedToNearEdge && !isScrolledToNearEdge)
							scrollDirection = ScrollDirection.Decrement;
						else if (itemFieldLocation == FixedFieldLocation.FixedToFarEdge && !isScrolledToFarEdge)
							scrollDirection = ScrollDirection.Increment;
						else
						{
							checkNearestItem = itemFieldLocation != FixedFieldLocation.Scrollable;
						}
					}

					if (checkNearestItem)
					{
						// we don't actually need to scroll but what has probably happened is that 
						// we were over the fixed area and needed to scroll to bring a scrollable 
						// element into view. activating that item (which the selectionstrategy 
						// would do after the getnearestselectableitem) would cause that to scroll 
						// into view which might make it so that we are scrolled all the way over 
						// to the near/far edge at which point that fixed element would then be 
						// eligible for selection. however since we don't need to scroll, if the 
						// mouse is not moved that item won't be selected. we can force another 
						// mouse over check by trying to scroll. note i'm using the GetNearestCompatibleItem 
						// and not the element we were over just in case there is a situation where the 
						// fixed element we are over is not selectable but there are other near fixed 
						// elements that would be selectable
						ISelectableItem nearestItem = ((ISelectionHost)_owner).GetNearestCompatibleItem(item, mouseArgs);

						if (nearestItem != null && nearestItem.IsSelectable && !nearestItem.IsSelected)
						{
							Field field = null;

							if (nearestItem is Field)
								field = nearestItem as Field;
							else if (nearestItem is Cell)
								field = ((Cell)nearestItem).Field;

							if (null != field && field.FixedLocation != FixedFieldLocation.Scrollable)
							{
								if (field.FixedLocation == FixedFieldLocation.FixedToFarEdge)
									scrollDirection = ScrollDirection.Increment;
								else
									scrollDirection = ScrollDirection.Decrement;
							}
						}
					}
				}
			}

			#endregion //AdjustFieldScrollInfo

			#region VerifyCompatibleItemForField
			private void VerifyCompatibleItemForField(ref ISelectableElement selectableElement, ISelectableItem relatedItem, DataItemPresenter dip, FixedFieldLocation fieldLocation, bool isInitialScrollPending)
			{
				Debug.Assert(selectableElement != null);

				if (dip.Field == null)
					return;

				VirtualizingDataRecordCellPanel cellPanel = Utilities.GetAncestorFromType(dip, typeof(VirtualizingDataRecordCellPanel), true, null, typeof(RecordPresenter)) as VirtualizingDataRecordCellPanel;

				if (null == cellPanel)
					return;

				// if the item we're over is from the same fixed location as the pivot item...
				FixedFieldLocation targetLocation = dip.Field.FixedLocation;
				if (targetLocation == fieldLocation)
				{
					// if the item is scrollable (and so was the source) or we haven't left 
					// that fixed area yet then let the item we found be used
					if (isInitialScrollPending || fieldLocation == FixedFieldLocation.Scrollable)
						return;

					bool isScrolledToNearEdge, isScrolledToFarEdge;
					cellPanel.GetFixedEdgeScrollState(out isScrolledToNearEdge, out isScrolledToFarEdge);

					// if we started a drag from the fixed near area and we're scrolled all the 
					// way to the near edge then we can let whatever hit test happen
					if (fieldLocation == FixedFieldLocation.FixedToNearEdge && isScrolledToNearEdge)
						return;

					// same goes for if we started from the far edge
					if (fieldLocation == FixedFieldLocation.FixedToFarEdge && isScrolledToFarEdge)
						return;

					// if we get here the mouse is over a fixed near/far edge and we've done some scrolling 
					// so don't use the fixed item under the mouse - do a scroll instead
				}
				else if (isInitialScrollPending)
				{
					Debug.Assert(fieldLocation != FixedFieldLocation.Scrollable);

					Point? pt = null;

					// scroll the near/far edge into view
					if (fieldLocation == FixedFieldLocation.FixedToNearEdge)
					{
						Vector v = cellPanel.GetFixedAreaOffset(FixedFieldLocation.FixedToNearEdge, false);
						pt = new Point(-v.X, -v.Y);
					}
					else
					{
						pt = new Point(cellPanel.ActualWidth, cellPanel.ActualHeight);
					}

					if (null != pt)
						cellPanel.BringIntoView(new Rect(pt.Value, new Size()));

					if (relatedItem is Field)
						_isInitialFieldScrollPending = false;
					else if (relatedItem is Cell)
						_isInitialCellFieldScrollPending = false;

					cellPanel.UpdateLayout();
				}
				else
				{
					// we've done an initial scroll. if we've brought the required target edge into view 
					// then we can use the item under the mouse.
					bool isScrolledToNearEdge, isScrolledToFarEdge;
					cellPanel.GetFixedEdgeScrollState(out isScrolledToNearEdge, out isScrolledToFarEdge);

					if (targetLocation == FixedFieldLocation.FixedToNearEdge && isScrolledToNearEdge)
						return;

					if (targetLocation == FixedFieldLocation.FixedToFarEdge && isScrolledToFarEdge)
						return;

					// if the field was partially out of view and we're waiting to scroll 
					// it into view then do that now
					if (relatedItem is Field && _owner._itemPendingScrollItemIntoView is Field)
					{
						Field pendingField = _owner._itemPendingScrollItemIntoView as Field;
						_owner._itemPendingScrollItemIntoView = null;
						_owner.BringFieldIntoView(pendingField);
					}
				}

				selectableElement = null;
			}
			#endregion //VerifyCompatibleItemForField

			#endregion //Private Methods

			#endregion //Methods
		}
		#endregion //FixedAreaScrollHelper class
	}

	#region Class DataPresenterCommands

	/// <summary>
	/// Provides the list of RoutedCommands supported by the DataPresenterBase. 
	/// </summary>
	public class DataPresenterCommands : Commands<DataPresenterBase>
	{
		// AS 3/15/07 BR21148
		private const ModifierKeys AllCtrlShiftModifiers = ModifierKeys.None | ModifierKeys.Shift | ModifierKeys.Control;

		// ====================================================================================================================================
		// ADD NEW COMMANDS HERE with the minimum required control state (also add a CommandWrapper for each command to the CommandWrappers array
		// below which will let you specify the triggering KeyGestures and required/disallowed states)
		//
		// Note that while individual commands in this static list are defined as type RoutedCommand or RoutedUICommand,
		// we actually create IGRoutedCommands or IGRoutedUICommands (both derived from RoutedCommand) so we can specify
		// and store the minimum control state needed to execute the command.
		// ------------------------------------------------------------------------------------------------------------------------------------
		//

		#region Command Definitions

		/// <summary>
		/// Clears all currently selected items.
		/// </summary>
		public static readonly RoutedCommand ClearAllSelected = new IGRoutedCommand("ClearAllSelected",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.ItemsSelected);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Expands the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand ExpandRecord = new IGRoutedCommand("ExpandRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.RecordExpanded,
																					  (Int64)States.RecordExpandable);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Collapses the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand CollapseRecord = new IGRoutedCommand("CollapseRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.RecordExpanded | (Int64)States.RecordExpandable);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Starts edit mode on the ActiveCell.
		/// </summary>
		public static readonly RoutedCommand StartEditMode = new IGRoutedCommand("StartEditMode",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.IsInEditMode,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Ends edit mode on the ActiveCell and cancels any changes that were made while in edit mode, reverting to the original value.
		/// </summary>
		public static readonly RoutedCommand EndEditModeAndDiscardChanges = new IGRoutedCommand("EndEditModeAndDiscardChanges",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell | (Int64)States.IsInEditMode);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Ends edit mode on the ActiveCell and accepts any changes that were made while in edit mode.
		/// </summary>
		public static readonly RoutedCommand EndEditModeAndAcceptChanges = new IGRoutedCommand("EndEditModeAndAcceptChanges",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell | (Int64)States.IsInEditMode);
		// JJD 7/19/07 - BR22682
		// Added new command
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Ends edit mode and commits pending changes on the Active Record.
		/// </summary>
		public static readonly RoutedCommand EndEditModeAndCommitRecord = new IGRoutedCommand("EndEditModeAndCommitRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell | (Int64)States.IsInEditMode);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Commits pending changes on the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand CommitChangesToActiveRecord = new IGRoutedCommand("CommitChangesToActiveRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record | (Int64)States.RecordHasPendingChanges);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Cancels pending changes on the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand DiscardChangesToActiveRecord = new IGRoutedCommand("DiscardChangesToActiveRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record | (Int64)States.RecordHasPendingChanges);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Commits pending changes on the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand CommitChangesToAllRecords = new IGRoutedCommand("CommitChangesToAllRecords",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Cancels pending changes on the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand DiscardChangesToAllRecords = new IGRoutedCommand("DiscardChangesToAllRecords",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell above the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellAbove = new IGRoutedCommand("CellAbove",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell below the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellBelow = new IGRoutedCommand("CellBelow",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell which is to the left of the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellLeft = new IGRoutedCommand("CellLeft",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell which is to the right of the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellRight = new IGRoutedCommand("CellRight",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell which logically follows the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellNext = new IGRoutedCommand("CellNext",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Cell which logically precedes the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellPrevious = new IGRoutedCommand("CellPrevious",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// SSP 7/19/07 BR21366
		// Added CellNextByTab and CellPreviousByTab commands.
		// 
		/// <summary>
		/// Navigates to the next Cell in the tab order and puts the cell in edit mode if editing is allowed.
		/// </summary>
		public static readonly RoutedCommand CellNextByTab = new IGRoutedCommand( "CellNextByTab",
																					  typeof( DataPresenterCommands ),
																					  (Int64)0,
																					  (Int64)States.Cell );
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// SSP 7/19/07 BR21366
		// Added CellNextByTab and CellPreviousByTab commands.
		// 
		/// <summary>
		/// Navigates to the previous Cell in the tab order and puts the cell in edit mode if editing is allowed.
		/// </summary>
		public static readonly RoutedCommand CellPreviousByTab = new IGRoutedCommand( "CellPreviousByTab",
																					  typeof( DataPresenterCommands ),
																					  (Int64)0,
																					  (Int64)States.Cell );
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the first Cell in the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand CellFirstInRecord = new IGRoutedCommand("CellFirstInRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellFirstInRecord,
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // This command should only require a record
																					  //(Int64)States.Cell);
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the last Cell in the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand CellLastInRecord = new IGRoutedCommand("CellLastInRecord",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellLastInRecord,
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // This command should only require a record
																					  //(Int64)States.Cell);
																					  (Int64)States.Record);
	//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the first displayed Cell.
		/// </summary>
		public static readonly RoutedCommand CellFirstDisplayed = new IGRoutedCommand("CellFirstDisplayed",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellFirstDisplayed,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the last displayed Cell.
		/// </summary>
		public static readonly RoutedCommand CellLastDisplayed = new IGRoutedCommand("CellLastDisplayed",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellLastDisplayed,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the first overall Cell.
		/// </summary>
		public static readonly RoutedCommand CellFirstOverall = new IGRoutedCommand("CellFirstOverall",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellFirstOverall,
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // This command should not require a cell
																					  //(Int64)States.Cell);
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the last overall Cell.
		/// </summary>
		public static readonly RoutedCommand CellLastOverall = new IGRoutedCommand("CellLastOverall",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.CellLastOverall,
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // This command should not require a cell
																					  //(Int64)States.Cell);
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page which is above the page containing the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellPageAbove = new IGRoutedCommand("CellPageAbove",
																					  typeof(DataPresenterCommands),
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
																					  (Int64)States.NavigationLayoutStyleGridViewHorizontal | (Int64)States.NavigationLayoutStyleCardViewHorizontal | (Int64)States.CellFirstOverall,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page which is below the page containing the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellPageBelow = new IGRoutedCommand("CellPageBelow",
																					  typeof(DataPresenterCommands),
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
																					  (Int64)States.NavigationLayoutStyleGridViewHorizontal | (Int64)States.NavigationLayoutStyleCardViewHorizontal | (Int64)States.CellLastOverall,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page which is to the left of the page containing the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellPageLeft = new IGRoutedCommand("CellPageLeft",
																					  typeof(DataPresenterCommands),
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
																					  (Int64)States.NavigationLayoutStyleGridViewVertical | (Int64)States.NavigationLayoutStyleCardViewVertical | (Int64)States.CellFirstOverall,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page which is to the right of the page containing the current ActiveCell.
		/// </summary>
		public static readonly RoutedCommand CellPageRight = new IGRoutedCommand("CellPageRight",
																					  typeof(DataPresenterCommands),
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
																					  (Int64)States.NavigationLayoutStyleGridViewVertical | (Int64)States.NavigationLayoutStyleCardViewVertical | (Int64)States.CellLastOverall,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record above the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordAbove = new IGRoutedCommand("RecordAbove",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record below the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordBelow = new IGRoutedCommand("RecordBelow",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record which is to the left of the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordLeft = new IGRoutedCommand("RecordLeft",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record which is to the right of the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordRight		= new IGRoutedCommand("RecordRight",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record which logically follows the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordNext = new IGRoutedCommand("RecordNext",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the Record which logically precedes the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordPrevious		= new IGRoutedCommand("RecordPrevious",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the first displayed Record.
		/// </summary>
		public static readonly RoutedCommand RecordFirstDisplayed = new IGRoutedCommand("RecordFirstDisplayed",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.RecordFirstDisplayed,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the last displayed Record.
		/// </summary>
		public static readonly RoutedCommand RecordLastDisplayed = new IGRoutedCommand("RecordLastDisplayed",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.RecordLastDisplayed,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the first overall Record.
		/// </summary>
		public static readonly RoutedCommand RecordFirstOverall = new IGRoutedCommand("RecordFirstOverall",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.RecordFirstOverall,
																					  (Int64)0); // [JM BR23504 07-19-07] (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the last overall Record.
		/// </summary>
		public static readonly RoutedCommand RecordLastOverall = new IGRoutedCommand("RecordLastOverall",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.RecordLastOverall,
																					  (Int64)0); // [JM BR23504 07-19-07] (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page of records which is above the page containing the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordPageAbove = new IGRoutedCommand("RecordPageAbove",
																					  typeof(DataPresenterCommands),
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // Enable paging until we are on the first overall record
																					  //(Int64)States.NavigationLayoutStyleGridViewHorizontal,
																					  //(Int64)States.Record | (Int64)States.RecordFirstDisplayed);
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
																					  (Int64)States.NavigationLayoutStyleGridViewHorizontal | (Int64)States.NavigationLayoutStyleCardViewHorizontal | (Int64)States.RecordFirstOverall,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page of records which is below the page containing the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordPageBelow = new IGRoutedCommand("RecordPageBelow",
																					  typeof(DataPresenterCommands),
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // Enable paging until we are on the last overall record
																					  //(Int64)States.NavigationLayoutStyleGridViewHorizontal,
																					  //(Int64)States.Record | (Int64)States.RecordLastDisplayed);
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
																					  (Int64)States.NavigationLayoutStyleGridViewHorizontal | (Int64)States.NavigationLayoutStyleCardViewHorizontal | (Int64)States.RecordLastOverall,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page of records which is to the left of the page containing the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordPageLeft = new IGRoutedCommand("RecordPageLeft",
																					  typeof(DataPresenterCommands),
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // Enable paging until we are on the first overall record
																					  //(Int64)States.NavigationLayoutStyleGridViewVertical,
																					  //(Int64)States.Record | (Int64)States.RecordFirstDisplayed);
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
																					  (Int64)States.NavigationLayoutStyleGridViewVertical | (Int64)States.NavigationLayoutStyleCardViewVertical | (Int64)States.RecordFirstOverall,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Navigates to the page of records which is to the right of the page containing the current ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand RecordPageRight = new IGRoutedCommand("RecordPageRight",
																					  typeof(DataPresenterCommands),
                                                                                      // JJD 2/26/09 - TFS14664
                                                                                      // Enable paging until we are on the last overall record
																					  //(Int64)States.NavigationLayoutStyleGridViewVertical,
																					  //(Int64)States.Record | (Int64)States.RecordLastDisplayed);
																					  // JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
																					  (Int64)States.NavigationLayoutStyleGridViewVertical | (Int64)States.NavigationLayoutStyleCardViewVertical | (Int64)States.RecordLastOverall,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// SSP 6/3/09 - NAS9.2 Field Chooser
		// 
		/// <summary>
		/// Displays a FieldChooser that lets the user select which fields to show or hide. You can 
		/// specify a <see cref="FieldLayout"/> as the parameter in which case the fields of that 
		/// field layout will be displayed in the FieldChooser.
		/// </summary>
		/// <seealso cref="DataPresenterBase.ShowFieldChooser(FieldLayout,bool,bool,string)"/>
		/// <seealso cref="FieldChooser"/>
		[InfragisticsFeature( FeatureName = FeatureInfo.FeatureName_FieldChooser, Version = FeatureInfo.Version_9_2 )]
		public static readonly RoutedCommand ShowFieldChooser = new IGRoutedCommand( "ShowFieldChooser",
																					  typeof( DataPresenterCommands ),			
																					  (Int64)0,
																					  (Int64)0 );
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Toggles the selection state of the ActiveCell.
		/// </summary>
		public static readonly RoutedCommand ToggleActiveCellSelectionState = new IGRoutedCommand("ToggleActiveCellSelectionState",
																					  typeof(DataPresenterCommands),
																					  (Int64)States.IsInEditMode,
																					  (Int64)States.Cell);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Toggles the selection state of the ActiveRecord.
		/// </summary>
		public static readonly RoutedCommand ToggleActiveRecordSelectionState = new IGRoutedCommand("ToggleActiveRecordSelectionState",
																					  typeof(DataPresenterCommands),
                                                                                      // JJD 3/2/09
                                                                                      // Shouldn't disallow an active cell for this command 
																					  //(Int64)States.Cell,
																					  (Int64)0,
																					  (Int64)States.Record);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
		/// Deletes the selected data records.
		/// </summary>
		public static readonly RoutedCommand DeleteSelectedDataRecords = new IGRoutedCommand("DeleteSelectedDataRecords",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.DataRecordsSelected);
        // JJD 12/30/08 NA 2009 Vol 1 - Record Filtering
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		/// <summary>
        /// Drops down or closes up the filter operator drop-down of a filter cell.
		/// </summary>
        public static readonly RoutedCommand ToggleFilterOperatorDropDown = new IGRoutedCommand("ToggleFilterOperatorDropDown",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.FilterCell);
		/// <summary>
        /// Clears the filter specified for the active filter cell.
		/// </summary>
        public static readonly RoutedCommand ClearActiveCellFilters = new IGRoutedCommand("ClearActiveCellFilters",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)(States.FilterCell | States.FilterCellHasActiveFilters));
		/// <summary>
        /// Clears all cell filters for the active FilterRecord.
		/// </summary>
        public static readonly RoutedCommand ClearActiveRecordCellFilters = new IGRoutedCommand("ClearActiveRecordCellFilters",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)(States.FilterRecord | States.FilterRecordHasActiveFilters));
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Field"/> specified in the parameter to FixedToNearEdge.
        /// </summary>
        public static readonly RoutedCommand FixFieldNear = new IGRoutedCommand("FixFieldNear",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Field"/> specified in the parameter to FixedToFarEdge.
        /// </summary>
        public static readonly RoutedCommand FixFieldFar = new IGRoutedCommand("FixFieldNear",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Field"/> specified in the parameter to Scrollable.
        /// </summary>
        public static readonly RoutedCommand UnfixField = new IGRoutedCommand("UnfixField",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        // JJD 6/9/09 NA 2009 Vol 2 - Fixed Records
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Record"/> specified in the parameter to FixedToNearEdge.
        /// </summary>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_RecordFixing)]
        public static readonly RoutedCommand FixRecordTop = new IGRoutedCommand("FixRecordTop",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Field"/> specified in the parameter to FixedToFarEdge.
        /// </summary>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_RecordFixing)]
        public static readonly RoutedCommand FixRecordBottom = new IGRoutedCommand("FixRecordBottom",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        /// <summary>
        /// Changes the <see cref="Field.FixedLocation"/> of the <see cref="Field"/> specified in the parameter to Scrollable.
        /// </summary>
        [InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_RecordFixing)]
        public static readonly RoutedCommand UnfixRecord = new IGRoutedCommand("UnfixRecord",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);
        //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        // AS 4/8/09 NA 2009.2 ClipboardSupport
        /// <summary>
        /// Clears the values of the selected cells and copies their values to the clipboard.
        /// </summary>
		/// <seealso cref="Copy"/>
		/// <seealso cref="Paste"/>
		/// <seealso cref="ClearCellContents"/>
		/// <seealso cref="FieldLayoutSettings.AllowClipboardOperations"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand Cut = ApplicationCommands.Cut;

        /// <summary>
        /// Copies the values of the selected cells to the clipboard.
        /// </summary>
		/// <seealso cref="Cut"/>
		/// <seealso cref="Paste"/>
		/// <seealso cref="ClearCellContents"/>
		/// <seealso cref="FieldLayoutSettings.AllowClipboardOperations"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand Copy = ApplicationCommands.Copy;

        /// <summary>
        /// Changes the values of the selected cells using the information in the clipboard.
        /// </summary>
		/// <seealso cref="Cut"/>
		/// <seealso cref="Copy"/>
		/// <seealso cref="ClearCellContents"/>
		/// <seealso cref="FieldLayoutSettings.AllowClipboardOperations"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand Paste = ApplicationCommands.Paste;

        /// <summary>
        /// Reverts the previous changes made by the user.
        /// </summary>
		/// <seealso cref="Redo"/>
		/// <seealso cref="DataPresenterBase.IsUndoEnabled"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand Undo = ApplicationCommands.Undo;

        /// <summary>
        /// Reapplies the change that was previously undone.
        /// </summary>
		/// <seealso cref="Undo"/>
		/// <seealso cref="DataPresenterBase.IsUndoEnabled"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand Redo = ApplicationCommands.Redo;

        /// <summary>
        /// Clears the values of the selected cells.
        /// </summary>
		/// <seealso cref="Cut"/>
		/// <seealso cref="Copy"/>
		/// <seealso cref="Paste"/>
		/// <seealso cref="FieldLayoutSettings.AllowClipboardOperations"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
        public static readonly RoutedCommand ClearCellContents = new IGRoutedCommand("ClearCellContents",
                                                                                      typeof(DataPresenterCommands),
                                                                                      (Int64)0,
                                                                                      (Int64)0);

		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// AS 6/3/09 NA 2009.2 Undo/Redo
		/// <summary>
		/// Toggles the <see cref="Record.IsExpanded"/> state of a record.
		/// </summary>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="DataPresenterBase.RecordExpanding"/>
		/// <seealso cref="DataPresenterBase.RecordExpanded"/>
		/// <seealso cref="DataPresenterBase.RecordCollapsing"/>
		/// <seealso cref="DataPresenterBase.RecordCollapsed"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_ClipboardSupport)]
		public static readonly RoutedCommand ToggleRecordIsExpanded = new IGRoutedCommand("ToggleRecordIsExpanded",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// AS 6/9/09 NA 2009.2 Field Sizing
		/// <summary>
		/// Invokes the <see cref="Field.PerformAutoSize()"/> method for the field specified by the parameter for the command as if the user had double clicked on the LabelPresenter edge.
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b>The parameter for the command must be the <see cref="Field"/> instance whose <see cref="Field.PerformAutoSize()"/> is to be invoked.</p>
		/// </remarks>
		/// <seealso cref="Field"/>
		/// <seealso cref="FieldSettings.AutoSizeScope"/>
		/// <seealso cref="FieldSettings.AutoSizeOptions"/>
		/// <seealso cref="Field.Width"/>
		/// <seealso cref="Field.Height"/>
		/// <seealso cref="Field.PerformAutoSize()"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_9_2, FeatureName = FeatureInfo.FeatureName_FieldSizing)]
		public static readonly RoutedCommand AutoSizeField = new IGRoutedCommand("AutoSizeField",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// JM 11/5/09 NA 2010.1 CardView
		/// <summary>
		/// Toggles the <see cref="Record.IsContainingCardCollapsed"/> state of a record.
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b>The parameter for the command must be the <see cref="Record"/> or <see cref="RecordPresenter"/> instance whose containing Card is to be collapsed/uncollapsed.</p>
		/// </remarks>
		/// <seealso cref="Record.IsContainingCardCollapsed"/>
		/// <seealso cref="CardViewSettings.CollapseCardButtonVisibility"/>
		/// <seealso cref="CardViewSettings.ShouldCollapseCards"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_10_1, FeatureName = FeatureInfo.FeatureName_CardView)]
		public static readonly RoutedCommand ToggleCardCollapsedState = new IGRoutedCommand("ToggleCardCollapsedState",
																							typeof(DataPresenterCommands),
																							(Int64)0,
																							(Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// JM 11/5/09 NA 2010.1 CardView
		/// <summary>
		/// Toggles the <see cref="Record.ShouldCollapseEmptyCells"/> state of a record.
		/// </summary>
		/// <remarks>
		/// <p class="note"><b>Note:</b>The parameter for the command must be the <see cref="Record"/> or <see cref="RecordPresenter"/> instance whose containing Card cells are to be collapsed/uncollapsed.</p>
		/// </remarks>
		/// <seealso cref="Record.ShouldCollapseEmptyCells"/>
		/// <seealso cref="Record.ShouldCollapseEmptyCellsResolved"/>
		/// <seealso cref="CardViewSettings.CollapseEmptyCellsButtonVisibility"/>
		/// <seealso cref="CardViewSettings.ShouldCollapseEmptyCells"/>
		[InfragisticsFeature(Version = FeatureInfo.Version_10_1, FeatureName = FeatureInfo.FeatureName_CardView)]
		public static readonly RoutedCommand ToggleEmptyCardCellsCollapsedState = new IGRoutedCommand("ToggleEmptyCardCellsCollapsedState",
																										typeof(DataPresenterCommands),
																										(Int64)0,
																										(Int64)0);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		// AS 3/3/11 NA 2011.1 - Async Exporting
		/// <summary>
		/// Cancels an asynchronous export operation when 
		/// </summary>
		[InfragisticsFeature(Version = FeatureInfo.Version_11_1, FeatureName = FeatureInfo.FeatureName_WordWriter)]
		public static readonly RoutedCommand CancelExport = new IGRoutedCommand("CancelExport",
																					  typeof(DataPresenterCommands),
																					  (Int64)0,
																					  (Int64)States.IsExporting);
		//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
		#endregion //Command Definitions

		// ====================================================================================================================================


		// ====================================================================================================================================
		// ADD COMMANDWRAPPERS HERE FOR EACH COMMAND DEFINED ABOVE.
		// ------------------------------------------------------------------------------------------------------------------------------------
		//
		/// <summary>
		/// The list of CommandWrappers for each supported command.
		/// </summary>
		/// <seealso cref="Infragistics.Windows.Commands.CommandWrapper"/>

		#region CommandWrapper Definitions

		private static CommandWrapper[] GetCommandWrappers()
		{
			return new CommandWrapper[] {
				//					RoutedCommand					StateDisallowed					StateRequired					InputGestures
				//					=============					===============					=============					=============
				new CommandWrapper(	ClearAllSelected,				(Int64)0,						(Int64)States.ItemsSelected,	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.S, ModifierKeys.Control) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	ExpandRecord,					(Int64)States.RecordExpanded |
																	(Int64)States.Cell,				(Int64)States.RecordExpandable |
																									(Int64)States.NavigationLayoutStyleGridViewVertical,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Right) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	ExpandRecord,					(Int64)States.RecordExpanded |
																	(Int64)States.Cell,				(Int64)States.RecordExpandable |
																									(Int64)States.NavigationLayoutStyleGridViewHorizontal,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Down) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CollapseRecord,					(Int64)States.Cell,				(Int64)States.RecordExpanded |
																									(Int64)States.RecordExpandable |
																									(Int64)States.NavigationLayoutStyleGridViewVertical,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Left) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CollapseRecord,					(Int64)States.Cell,				(Int64)States.RecordExpanded |
																									(Int64)States.RecordExpandable |
																									(Int64)States.NavigationLayoutStyleGridViewHorizontal,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Up) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	StartEditMode,					(Int64)States.IsInEditMode,		(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.F2) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	EndEditModeAndAcceptChanges,	(Int64)0,						(Int64)States.Cell |
				                                                                                    (Int64)States.IsInEditMode,		new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.F2) })),
				// JJD 7/19/07 - BR22682
				// Added new command EndEditModeAndCommitRecord to use with the enter key
				//new CommandWrapper(	EndEditModeAndAcceptChanges,		(Int64)0,						(Int64)States.Cell |
				new CommandWrapper(	EndEditModeAndCommitRecord,		(Int64)0,						(Int64)States.Cell |
																									(Int64)States.IsInEditMode,		new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Enter) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	EndEditModeAndDiscardChanges,	(Int64)0,						(Int64)States.Cell |
																									(Int64)States.IsInEditMode,		new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Escape) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	DiscardChangesToActiveRecord,		(Int64)States.IsInEditMode,		(Int64)States.Record | (Int64)States.RecordHasPendingChanges,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Escape) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CommitChangesToActiveRecord,		(Int64)States.IsInEditMode,		(Int64)States.Record | (Int64)States.RecordHasPendingChanges,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Enter) })),
				// Cell Navigation
				#region Old
				
#region Infragistics Source Cleanup (Region)






#endregion // Infragistics Source Cleanup (Region)

				#endregion //Old				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellAbove,						(Int64)States.IsInEditMode,		(Int64)States.Cell,				CreateGestureCombinations(Key.Up, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellBelow,						(Int64)States.IsInEditMode,		(Int64)States.Cell,				CreateGestureCombinations(Key.Down, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellLeft,						(Int64)States.IsInEditMode,		(Int64)States.Cell,				CreateGestureCombinations(Key.Left, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellRight,						(Int64)States.IsInEditMode,		(Int64)States.Cell,				CreateGestureCombinations(Key.Right, AllCtrlShiftModifiers)),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				// SSP 7/19/07 BR21366
				// Added CellNextByTab and CellPreviousByTab commands. Commented out the CellNext and CellPrevious commands
				// since no keys are bound to it by default.
				// 
				//new CommandWrapper(	CellNext,						(Int64)0,						(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab) })),
				new CommandWrapper(	CellNextByTab,						(Int64)0,						(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				// SSP 7/19/07 BR21366
				// Added CellNextByTab and CellPreviousByTab commands. Commented out the CellNext and CellPrevious commands
				// since no keys are bound to it by default.
				// 
				//new CommandWrapper(	CellPrevious,					(Int64)0,						(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab, ModifierKeys.Shift) })),
				new CommandWrapper(	CellPreviousByTab,					(Int64)0,						(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab, ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

				// SSP 8/7/07 BR25477
				// We'll need the CellNext and CellPrevious as command wrappers for our commands infrastructure in Windows 
				// assembly to create a command binding. Otherwise the CanExecute will not work for the CellNext and 
				// CellPrevious.
				// 
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellNext,						(Int64)0,						(Int64)States.Cell ),
				new CommandWrapper(	CellPrevious,					(Int64)0,						(Int64)States.Cell ),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 

				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellFirstInRecord,				(Int64)States.IsInEditMode |
																	(Int64)States.CellFirstInRecord,
																									(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellLastInRecord,				(Int64)States.IsInEditMode |
																	(Int64)States.CellLastInRecord,
																									(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift) })),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellFirstDisplayed,				(Int64)States.IsInEditMode,
																									(Int64)States.CellFirstInRecord,	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellLastDisplayed,				(Int64)States.IsInEditMode,
																									(Int64)States.CellLastInRecord,	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift) })),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellFirstOverall,				(Int64)States.IsInEditMode,
																									(Int64)States.CellFirstDisplayed,	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellLastOverall,				(Int64)States.IsInEditMode,
																									(Int64)States.CellLastDisplayed,	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift) })),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellFirstOverall,				(Int64)States.IsInEditMode |
																	(Int64)States.CellFirstOverall,
																									(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home, ModifierKeys.Control), new KeyGesture(Key.Home, ModifierKeys.Control | ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	CellLastOverall,				(Int64)States.IsInEditMode |
																	(Int64)States.CellLastOverall,	(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End, ModifierKeys.Control), new KeyGesture(Key.End, ModifierKeys.Control | ModifierKeys.Shift) })),
				

				// Cell Page Navigation
				#region Old
				
#region Infragistics Source Cleanup (Region)


















#endregion // Infragistics Source Cleanup (Region)

				#endregion //Old				
																	// JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
				new CommandWrapper(	CellPageAbove,					(Int64)States.IsInEditMode |
																	(Int64)States.NavigationLayoutStyleGridViewHorizontal | 
																	(Int64)States.NavigationLayoutStyleCardViewHorizontal |
																	(Int64)States.CellFirstOverall,
																									(Int64)States.Cell,				CreateGestureCombinations(Key.PageUp, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
																	// JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewHorizontal
				new CommandWrapper(	CellPageBelow,					(Int64)States.IsInEditMode |
																	(Int64)States.NavigationLayoutStyleGridViewHorizontal |
																	(Int64)States.NavigationLayoutStyleCardViewHorizontal |
																	(Int64)States.CellLastOverall,				
																									(Int64)States.Cell,				CreateGestureCombinations(Key.PageDown, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
																	// JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
				new CommandWrapper(	CellPageLeft,					(Int64)States.IsInEditMode |
																	(Int64)States.NavigationLayoutStyleGridViewVertical |
																	(Int64)States.NavigationLayoutStyleCardViewVertical |
																	(Int64)States.CellFirstOverall,
																									(Int64)States.Cell,				CreateGestureCombinations(Key.PageUp, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
																	// JM 02-24-10 TFS28244 - Include NavigationLayoutStyleCardViewVertical
				new CommandWrapper(	CellPageRight,					(Int64)States.IsInEditMode |
																	(Int64)States.NavigationLayoutStyleGridViewVertical |
																	(Int64)States.NavigationLayoutStyleCardViewVertical |
																	(Int64)States.CellLastOverall,
																									(Int64)States.Cell,				CreateGestureCombinations(Key.PageDown, AllCtrlShiftModifiers)),

				// Record Navigation
				#region Old
				
#region Infragistics Source Cleanup (Region)






#endregion // Infragistics Source Cleanup (Region)

				#endregion //Old				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordAbove,					(Int64)States.Cell,				(Int64)States.Record,			CreateGestureCombinations(Key.Up, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordBelow,					(Int64)States.Cell,				(Int64)States.Record,			CreateGestureCombinations(Key.Down, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordLeft,						(Int64)States.Cell,				(Int64)States.Record,			CreateGestureCombinations(Key.Left, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordRight,					(Int64)States.Cell,				(Int64)States.Record,			CreateGestureCombinations(Key.Right, AllCtrlShiftModifiers)),
				

				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordNext,						(Int64)States.Cell,				(Int64)States.Record,			new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordPrevious,					(Int64)States.Cell,				(Int64)States.Record,			new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Tab, ModifierKeys.Shift) })),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordFirstDisplayed,			(Int64)States.Cell |
				                                                    (Int64)States.RecordFirstDisplayed,
																									// JJD 8/22/11 - TFS83342
																									// added gestures to cover when the Control modifier key is down
																									//(Int64)0,						new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift), 
																									//                                                                              new KeyGesture(Key.PageUp), new KeyGesture(Key.PageUp, ModifierKeys.Shift) })),
																									(Int64)0,						new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift), new KeyGesture(Key.Home, ModifierKeys.Shift | ModifierKeys.Control), 
																																												  new KeyGesture(Key.PageUp), new KeyGesture(Key.PageUp, ModifierKeys.Shift), new KeyGesture(Key.PageUp, ModifierKeys.Control)})),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordLastDisplayed,			(Int64)States.Cell |
																	(Int64)States.RecordLastDisplayed,
																									// JJD 8/22/11 - TFS83342
																									// added gestures to cover when the Control modifier key is down
																									//(Int64)0,						new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift),
																									//                                                                              new KeyGesture(Key.PageDown), new KeyGesture(Key.PageDown, ModifierKeys.Shift) })),
																									(Int64)0,						new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift), new KeyGesture(Key.End , ModifierKeys.Shift | ModifierKeys.Control),
																																												  new KeyGesture(Key.PageDown), new KeyGesture(Key.PageDown, ModifierKeys.Shift), new KeyGesture(Key.PageDown, ModifierKeys.Control)})),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordFirstOverall,				(Int64)States.Record,			(Int64)0,						new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Right), new KeyGesture(Key.Down) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordFirstOverall,				(Int64)States.Cell |
				                                                    (Int64)States.RecordFirstOverall,
																									(Int64)States.Record,			new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home, ModifierKeys.Control), new KeyGesture(Key.Home, ModifierKeys.Control | ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordLastOverall,				(Int64)States.Cell |
																	(Int64)States.RecordLastOverall,(Int64)States.Record,			new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End, ModifierKeys.Control), new KeyGesture(Key.End, ModifierKeys.Control | ModifierKeys.Shift) })),
				
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordFirstOverall,				(Int64)States.Cell |
				                                                    (Int64)States.RecordFirstOverall,
																									(Int64)States.RecordFirstDisplayed,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Home), new KeyGesture(Key.Home, ModifierKeys.Shift) })),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordLastOverall,				(Int64)States.Cell |
																	(Int64)States.RecordLastOverall,(Int64)States.RecordLastDisplayed,			
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.End), new KeyGesture(Key.End, ModifierKeys.Shift) })),
				
				// Record Page Navigation
				#region Old
				
#region Infragistics Source Cleanup (Region)






















#endregion // Infragistics Source Cleanup (Region)

				#endregion //Old				
				new CommandWrapper(	RecordPageAbove,				(Int64)States.Cell |
                                                                     // JJD 2/26/09 - TFS14664
                                                                     // Enable paging until we are on the first overall record
                                                                    (Int64)States.RecordFirstOverall |
																	(Int64)States.NavigationLayoutStyleGridViewHorizontal,
																									(Int64)States.Record |
																									(Int64)States.RecordFirstDisplayed,
																																	CreateGestureCombinations(Key.PageUp, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordPageBelow,				(Int64)States.Cell |
                                                                     // JJD 2/26/09 - TFS14664
                                                                     // Enable paging until we are on the last overall record
                                                                    (Int64)States.RecordLastOverall |
																	(Int64)States.NavigationLayoutStyleGridViewHorizontal,				
																									(Int64)States.Record |
																									(Int64)States.RecordLastDisplayed,
																																	CreateGestureCombinations(Key.PageDown, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordPageLeft,					(Int64)States.Cell |
                                                                     // JJD 2/26/09 - TFS14664
                                                                     // Enable paging until we are on the first overall record
                                                                    (Int64)States.RecordFirstOverall |
																	(Int64)States.NavigationLayoutStyleGridViewVertical,
																									(Int64)States.Record |
																									(Int64)States.RecordFirstDisplayed,
																																	CreateGestureCombinations(Key.PageUp, AllCtrlShiftModifiers)),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	RecordPageRight,				(Int64)States.Cell | 
                                                                     // JJD 2/26/09 - TFS14664
                                                                     // Enable paging until we are on the last overall record
                                                                    (Int64)States.RecordLastOverall |
																	(Int64)States.NavigationLayoutStyleGridViewVertical,
																									(Int64)States.Record |
																									(Int64)States.RecordLastDisplayed,
																																	CreateGestureCombinations(Key.PageDown, AllCtrlShiftModifiers)),

				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				
				
				
				
				
				
				new CommandWrapper(	ToggleActiveCellSelectionState,	(Int64)States.IsInEditMode,		(Int64)States.Cell,				new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Space), new KeyGesture( Key.Space, ModifierKeys.Control ) }), ModifierKeys.Alt | ModifierKeys.Shift ),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				
				
				
				
				
				
				new CommandWrapper(	ToggleActiveRecordSelectionState,(Int64)States.Cell,			(Int64)States.Record,			new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Space), new KeyGesture( Key.Space, ModifierKeys.Control ) }), ModifierKeys.Alt | ModifierKeys.Shift ),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	DeleteSelectedDataRecords,		(Int64)States.IsInEditMode,
																									(Int64)States.DataRecordsSelected,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Delete) })),


                // AS 12/30/08 NA 2009 Vol 1 - Record filtering
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	ClearActiveCellFilters,		    (Int64)0,                       (Int64)States.FilterCellHasActiveFilters),
				new CommandWrapper(	ClearActiveRecordCellFilters,	(Int64)0,                       (Int64)States.FilterRecordHasActiveFilters),
				new CommandWrapper(	ToggleFilterOperatorDropDown, 	(Int64)0,                       (Int64)States.FilterCell),

                // AS 12/5/08 NA 2009 Vol 1 - Fixed Fields
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	FixFieldNear,		            (Int64)0,                       (Int64)0),
				new CommandWrapper(	FixFieldFar,		            (Int64)0,                       (Int64)0),
				new CommandWrapper(	UnfixField, 		            (Int64)0,                       (Int64)0),

                // JJD 6/9/09 NA 2009 Vol 2 - Fixed Records
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				new CommandWrapper(	FixRecordTop,		            (Int64)0,                       (Int64)0),
				new CommandWrapper(	FixRecordBottom,		        (Int64)0,                       (Int64)0),
				new CommandWrapper(	UnfixRecord, 		            (Int64)0,                       (Int64)0),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
                // AS 4/8/09 NA 2009.2 ClipboardSupport
				new CommandWrapper(	Copy,		                    (Int64)States.IsInEditMode,     (Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.C, ModifierKeys.Control), new KeyGesture(Key.Insert, ModifierKeys.Control) }), ModifierKeys.Alt),
				new CommandWrapper(	Cut,		                    (Int64)States.IsInEditMode,     (Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.X, ModifierKeys.Control), new KeyGesture(Key.Delete, ModifierKeys.Shift) }), ModifierKeys.Alt),
				new CommandWrapper(	Paste,		                    (Int64)States.IsInEditMode,     (Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.V, ModifierKeys.Control), new KeyGesture(Key.Insert, ModifierKeys.Shift) }), ModifierKeys.Alt),
				new CommandWrapper(	Undo,		                    (Int64)States.IsInEditMode,     (Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Z, ModifierKeys.Control) }), ModifierKeys.Alt | ModifierKeys.Shift),
				new CommandWrapper(	Redo,		                    (Int64)States.IsInEditMode,     (Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Y, ModifierKeys.Control) }), ModifierKeys.Alt | ModifierKeys.Shift),
				new CommandWrapper(	ClearCellContents,		        (Int64)(States.IsInEditMode | States.DataRecordsSelected),     
																									(Int64)0,
																																	new InputGestureCollection(new KeyGesture[] { new KeyGesture(Key.Delete) }), AllCtrlShiftModifiers),
                // AS 6/3/09 NA 2009.2 Undo/Redo
				new CommandWrapper(	ToggleRecordIsExpanded,			(Int64)0,                       (Int64)0),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				// SSP 6/18/09 - NAS9.2 Field Chooser
				// 
				new CommandWrapper(	ShowFieldChooser,		        (Int64)0,                       (Int64)0 ),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				// SSP 6/18/09 - NAS9.2 Field Chooser
				// 
				new CommandWrapper(	AutoSizeField,					(Int64)0,                       (Int64)0 ),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
                // JM 11/5/09 NA 2010.1 CardView
				new CommandWrapper(	ToggleCardCollapsedState,		(Int64)0,                       (Int64)0),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
                // JM 11/5/09 NA 2010.1 CardView
				new CommandWrapper(	ToggleEmptyCardCellsCollapsedState,	(Int64)0,                   (Int64)0),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
				// AS 3/3/11 NA 2011.1 - Async Exporting
				new CommandWrapper(	CancelExport,					(Int64)0,                   (Int64)0),
				//  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
			};
		}
		#endregion //CommandWrapper Definitions

		// ====================================================================================================================================


		static DataPresenterCommands()
		{
			// Call the Initialize method of our base class Commands<T> to register bindings for the commands represented
			// by our CommandWrappers.
			Commands<DataPresenterBase>.Initialize(DataPresenterCommands.GetCommandWrappers());
		}


		/// <summary>
		/// This method is provided as a convenience for initializing the statics in this class which kicks off
		/// the process of setting up and registering the commands.
		/// </summary>
		public static void LoadCommands()
		{
		}

		private static DataPresenterCommands g_instance;
		internal static DataPresenterCommands Instance
		{
			get
			{
				if (g_instance == null)
					g_instance = new DataPresenterCommands();

				return g_instance;
			}
		}

		#region CreateGestureCombinations





		private static InputGestureCollection CreateGestureCombinations(Key key, ModifierKeys modifiers)
		{
			InputGestureCollection gestures = new InputGestureCollection();

			AddGesture(gestures, key, modifiers, ModifierKeys.Shift | ModifierKeys.Control);
			AddGesture(gestures, key, modifiers, ModifierKeys.Shift | ModifierKeys.Control | ModifierKeys.Alt);
			AddGesture(gestures, key, modifiers, ModifierKeys.Shift | ModifierKeys.Alt);
			AddGesture(gestures, key, modifiers, ModifierKeys.Alt | ModifierKeys.Control);
			AddGesture(gestures, key, modifiers, ModifierKeys.Shift);
			AddGesture(gestures, key, modifiers, ModifierKeys.Control);
			AddGesture(gestures, key, modifiers, ModifierKeys.Alt);
			AddGesture(gestures, key, modifiers, ModifierKeys.None);

			return gestures;
		} 
		#endregion //CreateGestureCombinations

		#region AddGesture
		private static void AddGesture(InputGestureCollection gestures, Key key, ModifierKeys gestureModifiers, ModifierKeys modifierToCheck)
		{
			if ((gestureModifiers & modifierToCheck) == modifierToCheck)
				gestures.Add(new KeyGesture(key, modifierToCheck));
		} 
		#endregion //AddGesture

        // JJD 3/4/09 - TFS5971/BR32606 - added
        #region ProcessKeyboardInput

        /// <summary>
        /// Called when a key is pressed
        /// </summary>
        /// <param name="e">The key event arguments</param>
        /// <param name="commandHost">The command host</param>
        /// <returns></returns>
        public override bool ProcessKeyboardInput(KeyEventArgs e, ICommandHost commandHost)
        {
            DataPresenterBase dp = commandHost as DataPresenterBase;

            if (null != dp)
            {
                // if the element with focus is not in our focus scope then don't process the key and return false               
                if (Keyboard.FocusedElement is DependencyObject &&
                    FocusManager.GetFocusScope((DependencyObject)Keyboard.FocusedElement) != FocusManager.GetFocusScope(dp))
                {
                    return false;
                }
            }

            return base.ProcessKeyboardInput(e, commandHost);
        }

        #endregion //ProcessKeyboardInput
	}

	#endregion //Class DataPresenterCommands

	// MD 7/16/10 - TFS26592
	#region RoutedEventWrapper class

	/// <summary>
	/// Holds a reference to a routed events.
	/// </summary>
	public class RoutedEventWrapper
	{
		private RoutedEvent _routedEvent;

		/// <summary>
		/// Returns the associated routed event.
		/// </summary>
		public RoutedEvent RoutedEvent
		{
			get { return _routedEvent; }
			set { _routedEvent = value; }
		}
	}

	#endregion // RoutedEventWrapper class

	// MD 7/16/10 - TFS26592
	#region SuppressedEventsCollection class

	internal class SuppressedEventsCollection
	{
		private ObservableCollection<RoutedEventWrapper> _collection;
		private bool _isCollectionDirty;
		private HashSet _hashSet;

		// SSP 12/22/11 TFS67264 - Optimizations
		// 
		private DataPresenterBase _dp;

		// SSP 12/22/11 TFS67264 - Optimizations
		// Added dp parameter.
		// 
		//public SuppressedEventsCollection()
		public SuppressedEventsCollection( DataPresenterBase dp )
		{
			_dp = dp;

			_collection = new ObservableCollection<RoutedEventWrapper>();
			_collection.CollectionChanged += new NotifyCollectionChangedEventHandler(this.OnCollectionCollectionChanged);

			_hashSet = new HashSet();
		}

		public ObservableCollection<RoutedEventWrapper> Collection
		{
			get { return _collection; }
		}

		private void OnCollectionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
		{
			_isCollectionDirty = true;

			// SSP 12/22/11 TFS67264 - Optimizations
			// 
			_dp._cachedInitializeRecordEventSuppressed = null;
		}

		public bool IsEventSuppressed(RoutedEvent routedEvent)
		{
			if (_isCollectionDirty)
			{
				_isCollectionDirty = false;

				_hashSet.Clear();

				foreach (RoutedEventWrapper wrapper in _collection)
				{
					if (wrapper.RoutedEvent == null)
						continue;

					_hashSet.Add(wrapper.RoutedEvent);
				}
			}

			return _hashSet.Exists(routedEvent);
		}
	}

	#endregion // SuppressedEventsCollection class

	#region IRecordPresenterContainer interface

	/// <summary>
	/// Interface implemented by RecordPresenter containers.  
	/// </summary>
	/// <remarks>
	/// RecordPresenter containers that are returned by a custom view's GetContainerForRecordPresenter
	/// virtual method should implement this interface if they want to get called when the container 
	/// is being prepared or cleared.  Containers should also implement this interface if they are not
	/// ultimately derived from ContentControl.
	/// </remarks>
	public interface IRecordPresenterContainer
	{
		// ======================================================================================
		// Properties

		/// <summary>
		/// Returns the contained RecordPresenter.
		/// </summary>
		RecordPresenter RecordPresenter { get; }
	}

	#endregion //IRecordPresenterContainer interface

	#region IViewPanel interface

	/// <summary>
	/// Interface implemented by DataPresenterBase panels to support navigation related properties and methods.
	/// </summary>
	public interface IViewPanel
	{
		// ======================================================================================
		// Methods

		/// <summary>
		/// Returns the target of a record navigation from the specified currentRecord in the specified navigationDirection 
		/// </summary>
		/// <param name="currentRecord">The starting record for the navigation</param>
		/// <param name="navigationDirection">The direction in which to navigate</param>
		/// <param name="selectionHost">A reference to the current selection host.</param>
		/// <param name="shiftKeyDown">True if the shift key is down</param>
		/// <param name="ctlKeyDown">True if the ctl key is down</param>
		/// <param name="siblingNavigationStyle">Enumeration that specified how to deal with navigation among sibling records</param>
		/// <param name="restrictToRecordType">The Record or Record-derived type used to restrict the return record to a particular type</param>
		/// <returns>The record that is the target of the navigation</returns>
		Record GetNavigationTargetRecord(Record currentRecord, PanelNavigationDirection navigationDirection, ISelectionHost selectionHost, bool shiftKeyDown, bool ctlKeyDown, PanelSiblingNavigationStyle siblingNavigationStyle, Type restrictToRecordType);

		/// <summary>
		/// Ensures that the specified record is visible. If it is not, the panel should scroll in the appropriate
		/// direction to make it visible.
		/// </summary>
		/// <param name="record">The record to be made visible.</param>
		/// <returns>True if the record was made visible, false if the operation could not be completed.</returns>
		bool EnsureRecordIsVisible(Record record);

		/// <summary>
		/// Ensures that the specified cell is visible.  If it is not, the panel should scroll in the appropriate
		/// direction to make it visible.  NOTE: This routine assumes that the record is already visible.  Call 
		/// EnsureRecordIsVisible to make the record containing the cell visible.  
		/// </summary>
		/// <param name="cell">The cell to be made visible.</param>
		/// <returns>True if cell has been made visible, false if the operation could not be completed.</returns>
		bool EnsureCellIsVisible(Cell cell);

		/// <summary>
		/// Scrolls the panel in the direction specified by scrollType.
		/// </summary>
		/// <param name="scrollType">The direction in which to scroll.</param>
		void Scroll(PanelNavigationScrollType scrollType);

		/// <summary>
		/// Notifies the panel that the active record has changed.
		/// </summary>
		/// <param name="record">The new active record.</param>
		void OnActiveRecordChanged(Record record);

		/// <summary>
		/// Notifies the panel that the <see cref="DataPresenterBase.SelectedItems"/> collection has changed.
		/// </summary>
		void OnSelectedItemsChanged();

		/// <summary>
		/// Returns the first record in the list of currently displayed records that is of the specified type.
		/// </summary>
		/// <param name="recordType">The type of record to look for and return.</param>
		/// <returns>A record of the specified type or null if no record of the specified type could be found.</returns>
		Record GetFirstDisplayedRecord(Type recordType);

		/// <summary>
		/// Returns the last record in the list of currently displayed records that is of the specified type.
		/// </summary>
		/// <param name="recordType">The type of record to look for and return.</param>
		/// <returns>A record of the specified type or null if no record of the specified type could be found.</returns>
		Record GetLastDisplayedRecord(Type recordType);

		/// <summary>
		/// Returns the first record in the overall list of records that is of the specified type.
		/// </summary>
		/// <param name="recordType">The type of record to look for and return.</param>
		/// <returns>A record of the specified type or null if no record of the specified type could be found.</returns>
		Record GetFirstOverallRecord(Type recordType);

		/// <summary>
		/// Returns the last record in the overall list of records that is of the specified type.
		/// </summary>
		/// <param name="recordType">The type of record to look for and return.</param>
		/// <returns>A record of the specified type or null if no record of the specified type could be found.</returns>
		Record GetLastOverallRecord(Type recordType);

		// ======================================================================================
		// Properties

		/// <summary>
		/// Returns the <see cref="PanelLayoutStyle"/> of the panel.
		/// </summary>
		PanelLayoutStyle LayoutStyle { get; }
	}

	#endregion //IViewPanel interface

	#region IViewPanelInfo interface

	/// <summary>
	/// Interface implemented by DataPresenterBase to provide properties and methods of interest to custom view panels.  
	/// </summary>
	public interface IViewPanelInfo
	{
		// ======================================================================================
		// Properties

		#region OverallScrollCount

		/// <summary>
		/// The total number of viewable records including any viewable descendant records.
		/// </summary>
		/// <value>A count of the total number of viewable <see cref="Record"/>s including all descendant records whose parent records are expanded.</value>
		/// <remarks>
		/// <para>
		/// This count does not include <see cref="Record"/>s whose <see cref="Record.Visibility"/> is set to 'Collapsed' or descendants of records that are not expanded.
		/// </para>
		/// </remarks>
		/// <seealso cref="Record"/>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="Record.Visibility"/>
		/// <seealso cref="GetOverallScrollPositionForRecord"/>
		/// <seealso cref="GetRecordAtOverallScrollPosition"/>
		/// <seealso cref="OverallScrollPosition"/>
		int OverallScrollCount { get; }

		#endregion //OverallScrollCount

		#region OverallScrollPosition

		/// <summary>
		/// Gets/sets the current scroll position.
		/// </summary>
		/// <value>A number from 0 to <see cref="OverallScrollCount"/> - 1.</value>
		/// <seealso cref="Record"/>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="Record.Visibility"/>
		/// <seealso cref="GetRecordAtOverallScrollPosition"/>
		/// <seealso cref="GetOverallScrollPositionForRecord"/>
		/// <seealso cref="OverallScrollCount"/>
		int OverallScrollPosition { get; set; }

		#endregion //OverallScrollPosition

		// ======================================================================================
		// Methods

		#region GetOverallScrollPositionForRecord

		/// <summary>
		/// Gets the overall scroll position for a specific record.
		/// </summary>
		/// <param name="record">The record in question.</param>
		/// <returns>A number from 0 to <see cref="OverallScrollCount"/> -1 if the record has a scroll position or -1 if its Visibility is set to 'Collapsed' or one of its ancestor records is not expanded..</returns>
		/// <seealso cref="Record"/>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="Record.Visibility"/>
		/// <seealso cref="OverallScrollCount"/>
		/// <seealso cref="OverallScrollPosition"/>
		/// <seealso cref="GetRecordAtOverallScrollPosition"/>
		int GetOverallScrollPositionForRecord(Record record);

		#endregion //GetOverallScrollPositionForRecord

		#region GetRecordAtOverallScrollPosition

		/// <summary>
		/// Gets a record at a specific overall scroll position.
		/// </summary>
		/// <param name="scrollPosition">A zero-based position for the record in question.</param>
		/// <returns>A <see cref="Record"/> corresponding to the specific scroll position.</returns>
		/// <seealso cref="Record"/>
		/// <seealso cref="Record.IsExpanded"/>
		/// <seealso cref="Record.Visibility"/>
		/// <seealso cref="OverallScrollCount"/>
		/// <seealso cref="OverallScrollPosition"/>
		/// <seealso cref="GetOverallScrollPositionForRecord"/>
		Record GetRecordAtOverallScrollPosition(int scrollPosition);

		#endregion //GetRecordAtOverallScrollPosition

		#region IsOkToScroll

		/// <summary>
		/// Returns whether the DataPresenter is in a state where it is ok to scroll.
		/// </summary>
		/// <remarks>
		/// Note: If the ActiveCell is in edit mode at the time this method is called, an attempt
		/// is made to exit edit mode.  If the attempt is not successful, the method will return
		/// false.  Otherwise the method will return true.
		/// </remarks>
		bool IsOkToScroll();

		#endregion //IsOkToScroll

		#region OnRecordsInViewChanged

		/// <summary>
		/// Notifies the class the implementor when the set of in view records has changed.
		/// </summary>
		void OnRecordsInViewChanged();

		#endregion //OnRecordsInViewChanged
	}

	#endregion //IViewPanelInfo interface
}

#region Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved
/* ---------------------------------------------------------------------*
*                           Infragistics, Inc.                          *
*              Copyright (c) 2001-2012 All Rights reserved               *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* THE SOURCE CODE CONTAINED HEREIN AND IN RELATED FILES IS PROVIDED     *
* TO THE REGISTERED DEVELOPER FOR THE PURPOSES OF EDUCATION AND         *
* TROUBLESHOOTING. UNDER NO CIRCUMSTANCES MAY ANY PORTION OF THE SOURCE *
* CODE BE DISTRIBUTED, DISCLOSED OR OTHERWISE MADE AVAILABLE TO ANY     *
* THIRD PARTY WITHOUT THE EXPRESS WRITTEN CONSENT OF INFRAGISTICS, INC. *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY INFRAGISTICS PRODUCT.    *
*                                                                       *
* THE REGISTERED DEVELOPER ACKNOWLEDGES THAT THIS SOURCE CODE           *
* CONTAINS VALUABLE AND PROPRIETARY TRADE SECRETS OF INFRAGISTICS,      *
* INC.  THE REGISTERED DEVELOPER AGREES TO EXPEND EVERY EFFORT TO       *
* INSURE ITS CONFIDENTIALITY.                                           *
*                                                                       *
* THE END USER LICENSE AGREEMENT (EULA) ACCOMPANYING THE PRODUCT        *
* PERMITS THE REGISTERED DEVELOPER TO REDISTRIBUTE THE PRODUCT IN       *
* EXECUTABLE FORM ONLY IN SUPPORT OF APPLICATIONS WRITTEN USING         *
* THE PRODUCT.  IT DOES NOT PROVIDE ANY RIGHTS REGARDING THE            *
* SOURCE CODE CONTAINED HEREIN.                                         *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* --------------------------------------------------------------------- *
*/
#endregion Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved