using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Windows;
using System.Windows.Data;
using System.Windows.Controls;
using System.Collections;
using Infragistics.Windows.Helpers;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.Specialized;
using Infragistics.Windows.Controls;
using Infragistics.Windows.DockManager.Dragging;
using System.Runtime.CompilerServices;
using System.Security;
using System.Security.Permissions;
using System.Windows.Interop;

namespace Infragistics.Windows.DockManager
{
	/// <summary>
	/// Static class with helper methods for <see cref="XamDockManager"/>
	/// </summary>
	internal static class DockManagerUtilities
	{
		#region Constants

		// AS 5/17/08 Reuse Group/Split
		private const char AutoGeneratedPrefix = 'Z';

		#endregion // Constants

        #region Member Variables

        // AS 3/30/09 TFS16355 - WinForms Interop
        [ThreadStatic]
        private static bool? _popupAllowsTransparency;

        [ThreadStatic]
        private static bool? _hasUnmanagedCode;

        [ThreadStatic]
        private static bool? _hasFullWebBrowserPerm;

        #endregion //Member Variables

		#region Properties

		// AS 5/17/08 Reuse Group/Split
		#region AutoGenerated

		private static readonly DependencyPropertyKey AutoGeneratedPropertyKey =
			DependencyProperty.RegisterAttachedReadOnly("AutoGenerated",
			typeof(bool), typeof(DockManagerUtilities), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		public static readonly DependencyProperty AutoGeneratedProperty =
			AutoGeneratedPropertyKey.DependencyProperty;

		public static bool GetAutoGenerated(DependencyObject d)
		{
			return (bool)d.GetValue(AutoGeneratedProperty);
		}

		#endregion //AutoGenerated

		// AS 3/30/09 TFS16355 - WinForms Interop
        #region HasUnmanagedCodeRights
        internal static bool HasUnmanagedCodeRights
        {
            get
            {
                if (_hasUnmanagedCode == null)
                    _hasUnmanagedCode = CheckUnmanagedCodePermission();

                return _hasUnmanagedCode.Value;
            }
        } 
        #endregion //HasUnmanagedCodeRights

        // AS 3/30/09 TFS16355 - WinForms Interop
        #region CanHostBrowserInPopup
        internal static bool CanHostBrowserInPopup
        {
            get
            {
                if (_hasFullWebBrowserPerm == null)
                    _hasFullWebBrowserPerm = CheckWebBrowerPermission();

                return _hasFullWebBrowserPerm.Value;
            }
        } 
        #endregion //CanHostBrowserInPopup

        // AS 3/30/09 TFS16355 - WinForms Interop
        #region IsPopupInChildWindow
        internal static bool IsPopupInChildWindow
        {
            get
            {
                if (_popupAllowsTransparency == null)
                {
                    System.Windows.Controls.Primitives.Popup p = new System.Windows.Controls.Primitives.Popup();
                    p.AllowsTransparency = true;
                    p.CoerceValue(System.Windows.Controls.Primitives.Popup.AllowsTransparencyProperty);
                    _popupAllowsTransparency = p.AllowsTransparency;
                }

                return !_popupAllowsTransparency.Value;
            }
        } 
        #endregion //IsPopupInChildWindow

		// AS 8/24/09 TFS19861
		#region PreventAllowsTransparency

		// AS 9/11/09 TFS21330
		//private static readonly DependencyPropertyKey PreventAllowsTransparencyPropertyKey =
		internal static readonly DependencyPropertyKey PreventAllowsTransparencyPropertyKey =
			DependencyProperty.RegisterAttachedReadOnly("PreventAllowsTransparency",
			typeof(bool), typeof(DockManagerUtilities), new FrameworkPropertyMetadata(KnownBoxes.FalseBox));

		public static readonly DependencyProperty PreventAllowsTransparencyProperty =
			PreventAllowsTransparencyPropertyKey.DependencyProperty;

		public static bool GetPreventAllowsTransparency(DependencyObject d)
		{
			return (bool)d.GetValue(PreventAllowsTransparencyProperty);
		}

		internal static bool CalculatePreventAllowsTransparency(ToolWindow toolWindow)
		{
			// if its an unpinned pane that has hwnd hosts then we need to prevent 
			// transparency since hwnd hosts don't handle this well
			UnpinnedTabFlyout flyout = toolWindow.Content as UnpinnedTabFlyout;

			if (null != flyout)
			{
				ContentPane pane = flyout.Pane;
				return null != pane && pane.HasHwndHost;
			}

			// AS 9/11/09 TFS21330
			// Added additional criteria to handle the case where a PaneToolWindow 
			// could contain a ContentPane that contains an HwndHost.
			//
			IPaneContainer container = toolWindow.Content as IPaneContainer;

			if (null == container)
				return false;

			foreach (ContentPane cp in GetAllPanes(toolWindow, PaneFilterFlags.All))
			{
				if (cp.HasHwndHost)
					return true;
			}

			return false;
		}

		internal static void InitializePreventAllowsTransparency(ToolWindow toolWindow)
		{
			bool preventTransparency = CalculatePreventAllowsTransparency(toolWindow);
			toolWindow.SetValue(PreventAllowsTransparencyPropertyKey, preventTransparency ? KnownBoxes.TrueBox : DependencyProperty.UnsetValue);
		}
		#endregion //PreventAllowsTransparency

		#endregion // Properties

		#region Methods

		// AS 6/28/10 TFS32978
		#region Activate
		// AS 10/14/10 TFS36740
		// Changed to return a boolean indicating whether the window is active.
		//
		internal static bool Activate(Window window)
		{
			if (window == null || !window.IsVisible || !window.IsLoaded)
				return false;

			if (window.IsActive)
				return true;

			WindowInteropHelper wih = new WindowInteropHelper(window);

			if (wih.Handle == IntPtr.Zero)
				return false;

			// if a modal window was shown then the window is disabled
			if (!NativeWindowMethods.IsWindowEnabled(wih.Handle))
				return false;

			return window.Activate();
		} 
		#endregion //Activate

		// AS 9/11/09 TFS21330
		// I was going to set an additional property on the element being moved but it turns 
		// out that I didn't need to. I'm leaving these infrastructure changes though in case 
		// I need to set additional properties on the elements being moved later.
		//
		#region AddMoveReplacement
		internal static void AddMoveReplacement(GroupTempValueReplacement group, FrameworkElement element)
		{
			AddMoveReplacement(group, element, element);
		}

		internal static void AddMoveReplacement(GroupTempValueReplacement group, FrameworkElement element, FrameworkElement srcElement)
		{
			group.Add(element, FrameworkElement.DataContextProperty, srcElement.DataContext);
		}
		#endregion //AddMoveReplacement

		// AS 7/16/09 TFS18992
		#region AdjustFloatingLocation
		internal static void AdjustFloatingLocation(Point screenPoint, ref Point windowLocation, Size windowSize)
		{
			Debug.Assert(!windowSize.IsEmpty);

			if (windowSize.IsEmpty)
				return;

			Rect windowRect = new Rect(windowLocation, windowSize);

			if (!windowRect.Contains(screenPoint))
			{
				if (screenPoint.X < windowRect.Left || screenPoint.X >= windowRect.Right)
					windowLocation.X = screenPoint.X - Math.Max(windowRect.Width, 2) / 2;

				if (screenPoint.Y < windowRect.Top || screenPoint.Y >= windowRect.Bottom)
					windowLocation.Y = screenPoint.Y - Math.Max(windowRect.Height, 2) / 2;
			}
		} 
		#endregion //AdjustFloatingLocation

		#region AdjustIndexForMove
		// AS 5/21/08
		// Helper method to decrement an index if the panes already exist within the collection
		// at an earlier index.
		//
		internal static void AdjustIndexForMove(IList items, IList<ContentPane> panes, ref int index)
		{
			foreach (ContentPane cp in panes)
			{
				int existingIndex = DockManagerUtilities.IndexOf(items, cp, true);

                // AS 10/16/08 TFS6255
				//if (existingIndex >= 0 && existingIndex <= index)
				if (existingIndex >= 0 && existingIndex < index)
					index--;
			}
		} 
		#endregion //AdjustIndexForMove

		// AS 11/12/09 TFS24789 - TabItemDragBehavior
		#region ApplyTemplateRecursively
		internal static void ApplyTemplateRecursively(DependencyObject dependencyObject)
		{
			FrameworkElement fe = dependencyObject as FrameworkElement;

			if (null != fe)
				fe.ApplyTemplate();

			for (int i = 0, count = VisualTreeHelper.GetChildrenCount(dependencyObject); i < count; i++)
			{
				DependencyObject child = VisualTreeHelper.GetChild(dependencyObject, i);

				if (null != child)
					ApplyTemplateRecursively(child);
			}
		}
		#endregion //ApplyTemplateRecursively

        #region AreClose
        internal static bool AreClose(double value1, double value2)
        {
            if (value1 == value2)
                return true;

            return Math.Abs(value1 - value2) < .0000000001;
        }
        #endregion //AreClose

        // AS 5/17/08 Reuse Group/Split
		#region AutoGeneratedName
		internal static string AutoGeneratedName()
		{
			return AutoGeneratedPrefix + Guid.NewGuid().ToString("N");
		}
		#endregion // AutoGeneratedName

		// AS 4/28/11 TFS73532
		// Refactored from the ShowToolWindow method.
		//
		#region BeforeShowToolWindow
		internal static void BeforeShowToolWindow(ToolWindow window, FrameworkElement owner, out DependencyObject focusedElement, out XamDockManager dm)
		{
			Debug.Assert(null != owner);
			focusedElement = Keyboard.FocusedElement as DependencyObject;
			dm = XamDockManager.GetDockManager(window);
			Debug.Assert(null != dm);

			// When a window receives a deactivate notification, it caches the keyboard focused element
			// as the element to which focus should be restored when it is activated again. Since the 
			// focused element could be within the floating pane, they could end up storing an element
			// that isn't going to be within the window. So if the window contains the focused element 
			// then we will shift focus back to the dockmanager while we are showing the window. If 
			// the window is being activated then we can restore the focused element as the element 
			// with focus. I used a helper method to shift the focus since we don't want the XDM 
			// moving focus to another pane.
			//
			bool shiftFocus = null != focusedElement &&
				null != dm &&
				dm.IsKeyboardFocusWithin &&
				Utilities.IsDescendantOf(window, focusedElement);

			if (shiftFocus)
				dm.ForceFocus();

			Debug.Assert(window.Owner == null || window.IsDeferredShowPending);

			// AS 9/11/09 TFS21330
			// Set the property we use in a PaneToolWindow to determine what is returned from 
			// the SupportsAllowsTransparency.
			//
			DockManagerUtilities.InitializePreventAllowsTransparency(window);
		}
		#endregion //BeforeShowToolWindow 

        // AS 3/30/09 TFS16355 - WinForms Interop
        #region CheckWebBrowerPermission
        internal static bool CheckWebBrowerPermission()
        {
            try
            {
                WebBrowserPermission perm = new WebBrowserPermission(WebBrowserPermissionLevel.Unrestricted);
                perm.Demand();
                return true;
            }
            catch (SecurityException)
            {
                return false;
            }
        }
        #endregion //CheckWebBrowerPermission

        // AS 3/30/09 TFS16355 - WinForms Interop
        #region CheckUnmanagedCodePermission
        internal static bool CheckUnmanagedCodePermission()
        {
            try
            {
                SecurityPermission perm = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                perm.Demand();
                return true;
            }
            catch (SecurityException)
            {
                return false;
            }
        } 
        #endregion //CheckUnmanagedCodePermission

		#region Clone
		/// <summary>
		/// Clones the specified tab group and moves over the visible content panes to the new group.
		/// </summary>
		/// <param name="source">The tab group to clone</param>
		/// <param name="newLocation">The location where the new group will reside ultimately</param>
        /// <param name="clone">New TabGroupPane that should be updated based on the source</param>
		/// <param name="moveHelper">Optional helper object used when reparenting ContentPanes</param>
		///// <returns>A disposable object that needs to be disposed once the cloned element is able to maintain the datacontext.</returns>
        // AS 10/16/08 TFS8068
        //internal static TabGroupPane Clone(TabGroupPane source, PaneLocation newLocation)
		// AS 4/28/11 TFS73532
		//internal static IDisposable Clone(TabGroupPane source, PaneLocation newLocation, out TabGroupPane clone)
		internal static void Clone(TabGroupPane source, PaneLocation newLocation, TabGroupPane clone, MovePaneHelper moveHelper)
		{
			// AS 4/28/11 TFS73532
			//// AS 10/16/08 TFS8068
			////TabGroupPane clone = DockManagerUtilities.CreateTabGroup();
			//clone = DockManagerUtilities.CreateTabGroup(XamDockManager.GetDockManager(source));
			//
			//IDisposable replacement = DockManagerUtilities.CreateMoveReplacement(clone, source);
			Debug.Assert(null != clone);

			// copy over the relative size
			SplitPane.SetRelativeSize(clone, SplitPane.GetRelativeSize(source));

			// AS 5/2/08 BR32056 - Maintain the selected item
			object selectedItem = source.SelectedItem;

			// copy over properties...
			clone.TabStripPlacement = source.TabStripPlacement;

			List<ContentPane> panes = new List<ContentPane>(((IContentPaneContainer)source).GetVisiblePanes());

			Debug.Assert(panes.Count > 0);

			foreach (ContentPane pane in panes)
				DockManagerUtilities.MovePane(pane, clone, null, newLocation, moveHelper );

			// AS 5/2/08 BR32056 - Maintain the selected item
			clone.SelectedItem = selectedItem;

			// AS 4/28/11 TFS73532
			//// AS 10/16/08 TFS8068
			////return clone;
			//return replacement;
		}

		/// <summary>
		/// Clones the specified SplitPane including any visible nested tab groups and moves over all visible descendant content panes.
		/// </summary>
		/// <param name="source">The split pane to be cloned</param>
		/// <param name="newLocation">The location where the new split pane will ultimately reside</param>
		/// <param name="clone">New SplitPane that should be updated based on the source</param>
		/// <param name="moveHelper">Optional helper object used when reparenting ContentPanes</param>
		///// <returns>A disposable object that needs to be disposed once the cloned element is able to maintain the datacontext.</returns>
        // AS 10/16/08 TFS8068
        //internal static SplitPane Clone(SplitPane source, PaneLocation newLocation)
		// AS 4/28/11 TFS73532
		//internal static IDisposable Clone(SplitPane source, PaneLocation newLocation, out SplitPane clone)
		internal static void Clone(SplitPane source, PaneLocation newLocation, SplitPane clone, MovePaneHelper moveHelper)
		{
			// AS 4/28/11 TFS73532
			//// AS 10/16/08 TFS8068
			////SplitPane clone = DockManagerUtilities.CreateSplitPane();
			//clone = DockManagerUtilities.CreateSplitPane(XamDockManager.GetDockManager(source));
			//IDisposable replacement = DockManagerUtilities.CreateMoveReplacement(clone, source);
			Debug.Assert(null != clone);
			XamDockManager dm = XamDockManager.GetDockManager(source);

			// copy over the relative size
			SplitPane.SetRelativeSize(clone, SplitPane.GetRelativeSize(source));

			clone.SplitterOrientation = source.SplitterOrientation;
			FrameworkElement[] panes = new FrameworkElement[source.Panes.Count];
			source.Panes.CopyTo(panes, 0);

			foreach (FrameworkElement child in panes)
			{
				// skip hidden panes - e.g. if we're dragging a floating window and that
				// contains a tabgroup which has no visible children (because the panes were
				// docked)
				// AS 5/5/10 TFS30072
				// If an element has a Visibility of Hidden then the space used by that element 
				// is reserved so we should clone the element when we clone the parent.
				//
				//if (child.Visibility == Visibility.Visible)
				if (child.Visibility != Visibility.Collapsed)
				{
					if (child is TabGroupPane)
					{
						// AS 4/28/11 TFS73532
						//// AS 10/16/08 TFS8068
						////TabGroupPane tabGroup = Clone((TabGroupPane)child, newLocation);
						//TabGroupPane tabGroup;
						//using (Clone((TabGroupPane)child, newLocation, out tabGroup))
						//    clone.Panes.Add(tabGroup);
						TabGroupPane tabGroup = DockManagerUtilities.CreateTabGroup(dm);
						clone.Panes.Add(tabGroup);
						Clone(child as TabGroupPane, newLocation, tabGroup, moveHelper);
					}
					else if (child is SplitPane)
					{
						// AS 4/28/11 TFS73532
						//// AS 10/16/08 TFS8068
						////SplitPane split = Clone((SplitPane)child, newLocation);
						//SplitPane split;
						//using (Clone((SplitPane)child, newLocation, out split))
						//	clone.Panes.Add(split);
						SplitPane split = DockManagerUtilities.CreateSplitPane(dm);
						clone.Panes.Add(split);
						Clone(child as SplitPane, newLocation, split, moveHelper);
					}
					else if (child is ContentPane)
					{
						DockManagerUtilities.MovePane(child as ContentPane, clone, null, newLocation, moveHelper );
					}
				}
			}

			// AS 4/28/11 TFS73532
			//// AS 10/16/08 TFS8068
			////return clone;
			//return replacement;
		}
		#endregion //Clone

        // AS 10/16/08 TFS8068
        // The original issue reported had to do with moving a pane where the content had a validation
        // error and the validation error visual remained where it was before the move. That part was 
        // easy enough to address by putting an adorner decorated into the ContentPane template so 
        // the validation error visual was within the content pane and would move with the pane. 
        // However in testing the specific sample, you would notice that the validation error would
        // go away when the pane was moved. This happened because the validation error was on a binding
        // to the datacontext. As the element was moved, it was removed the logical/visual tree of 
        // one element and moved into that of another. When the pane was removed from the logical/visual
        // tree, the datacontext (which is inherited) was being cleared temporarily causing a change
        // in the datacontext which ultimately caused the validation error & visual to go away. In 
        // an attempt to try and preserve that, we're going to temporarily set the datacontext on 
        // the element being moved.
        //
        #region CreateMoveReplacement
		// AS 9/11/09 TFS21330
		// Changed return types to IDisposable. See comments on AddMoveReplacement for more details.
		//
		internal static IDisposable CreateMoveReplacement(FrameworkElement element)
        {
			// AS 9/11/09 TFS21330
			//return new TempValueReplacement(element, FrameworkElement.DataContextProperty);
			return CreateMoveReplacement(element, element);
        }

		internal static IDisposable CreateMoveReplacement(FrameworkElement element, FrameworkElement srcElement)
        {
            Debug.Assert(null != srcElement);
			// AS 9/11/09 TFS21330
			//return new TempValueReplacement(element, FrameworkElement.DataContextProperty, srcElement.DataContext);
			GroupTempValueReplacement group = new GroupTempValueReplacement();
			AddMoveReplacement(group, element, srcElement);
			return group;
        }

        internal static GroupTempValueReplacement CreateMoveReplacement<T>(IList<T> elements)
            where T : FrameworkElement
        {
            GroupTempValueReplacement group = new GroupTempValueReplacement();

            if (null != elements)
            {
                foreach (FrameworkElement element in elements)
                {
					// AS 9/11/09 TFS21330
					//group.Add(element, FrameworkElement.DataContextProperty);
					AddMoveReplacement(group, element);
                }
            }

            return group;
        } 
        #endregion //CreateMoveReplacement

		#region CreateStringTemplate
		/// <summary>
		/// Helper method for creating a data template that binds the text trimming/alignment/wrapping of the 
		/// textblock within a content presenter to that of the parent content control.
		/// </summary>
		/// <param name="contentControlType">The type of the templated parent for the content presenter.</param>
		/// <param name="recognizesAccessKey">True if the content presenter should create an AccessKey</param>
		public static DataTemplate CreateStringTemplate(Type contentControlType, bool recognizesAccessKey)
		{
			Type elementType = recognizesAccessKey ? typeof(AccessText) : typeof(TextBlock);
			FrameworkElementFactory fefTextBlock = new FrameworkElementFactory(elementType);

			// Text property
			Binding binding = new Binding();
			binding.Mode = BindingMode.OneWay;
			DependencyProperty textProperty = recognizesAccessKey ? AccessText.TextProperty : TextBlock.TextProperty;
			fefTextBlock.SetBinding(textProperty, binding);

			// TextAlignment
			RelativeSource rs = new RelativeSource(RelativeSourceMode.FindAncestor, contentControlType, 1);
			binding = Utilities.CreateBindingObject(TextBlock.TextAlignmentProperty, System.Windows.Data.BindingMode.OneWay, rs);

			fefTextBlock.SetBinding(TextBlock.TextAlignmentProperty, binding);

			// TextTrimmingProperty
			binding = Utilities.CreateBindingObject(TextBlock.TextTrimmingProperty, System.Windows.Data.BindingMode.OneWay, rs);
			fefTextBlock.SetBinding(TextBlock.TextTrimmingProperty, binding);

			// TextWrappingProperty
			binding = Utilities.CreateBindingObject(TextBlock.TextWrappingProperty, System.Windows.Data.BindingMode.OneWay, rs);
			fefTextBlock.SetBinding(TextBlock.TextWrappingProperty, binding);

			DataTemplate template = new DataTemplate(typeof(string));
			template.VisualTree = fefTextBlock;
			template.Seal();

			return template;
		}
		#endregion //CreateStringTemplate

		// AS 5/17/08 Reuse Group/Split
		#region CreateTabGroup
		// AS 9/24/09
		//internal static TabGroupPane CreateTabGroup()
		internal static TabGroupPane CreateTabGroup(XamDockManager dm)
		{
			// AS 9/24/09
			//TabGroupPane group = new TabGroupPane();
			//group.Name = AutoGeneratedName();
			Debug.Assert(dm != null);
			TabGroupPane group;

			if (null != dm)
				group = dm.CreateTabGroupPane();
			else
			{
				group = new TabGroupPane();
				group.Name = AutoGeneratedName();
			}

			group.SetValue(AutoGeneratedPropertyKey, KnownBoxes.TrueBox);
			return group;
		}
		#endregion // CreateTabGroup

		// AS 5/17/08 Reuse Group/Split
		#region CreateSplitPane
		// AS 9/24/09
		//internal static SplitPane CreateSplitPane()
		internal static SplitPane CreateSplitPane(XamDockManager dm)
		{
			// AS 9/24/09
			//SplitPane group = new SplitPane();
			//group.Name = AutoGeneratedName();
			Debug.Assert(dm != null);
			SplitPane group;

			if (null != dm)
				group = dm.CreateSplitPane();
			else
			{
				group = new SplitPane();
				group.Name = AutoGeneratedName();
			}

			group.SetValue(AutoGeneratedPropertyKey, KnownBoxes.TrueBox);
			return group;
		}
		#endregion // CreateSplitPane

		#region CreateVisiblePaneList
		internal static IList<ContentPane> CreateVisiblePaneList(IEnumerable enumerable)
		{
			List<ContentPane> list = new List<ContentPane>();

			foreach (object item in enumerable)
			{
				ContentPane pane = item as ContentPane;

				if (null != pane && pane.Visibility == Visibility.Visible)
					list.Add(pane);
			}

			return list;
		} 
		#endregion // CreateVisiblePaneList

		#region DumpTree
		internal static string DumpTree(IPaneContainer pane)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(pane.ToString());
			DumpTree(pane, sb, 1);

			return sb.ToString();
		} 

		private static void DumpTree(IPaneContainer container, StringBuilder sb, int indent)
		{
			PaneLocation location = XamDockManager.GetPaneLocation(container as DependencyObject);

			foreach (object item in container.Panes)
			{
				PaneLocation childLocation = XamDockManager.GetPaneLocation(item as DependencyObject);

				if (childLocation != location)
				{
					sb.Append(Environment.NewLine);
					sb.Append(' ', indent * 4);
					sb.Append(childLocation);
					sb.Append(":");
					sb.Append(Environment.NewLine);
				}

				sb.Append(' ', indent * 4);
				sb.Append(item.ToString());
				sb.Append(Environment.NewLine);

				IPaneContainer childContainer = item as IPaneContainer;

				if (null != childContainer)
					DumpTree(childContainer, sb, indent + 1);
			}
		} 
		#endregion //DumpTree

		#region FixPlaceholders
		internal static void FixPlaceholders(IList<ContentPane> panes)
		{
			if (null != panes)
			{
				foreach (ContentPane pane in panes)
					pane.PlacementInfo.RemoveReplacedPlaceholder();
			}
		}
		#endregion //FixPlaceholders

		#region GetDockedSide
		/// <summary>
		/// Returns the <see cref="Dock"/> indicating the side to which the pane location is associated. Should not be used with Center.
		/// </summary>
		/// <param name="position">The position to evaluate</param>
		/// <returns>One of the <see cref="Dock"/> values depending on the position</returns>
		public static Dock GetDockedSide(DockingIndicatorPosition position)
		{
			switch (position)
			{
				case DockingIndicatorPosition.Bottom:
					return Dock.Bottom;
				case DockingIndicatorPosition.Left:
					return Dock.Left;
				case DockingIndicatorPosition.Right:
					return Dock.Right;
				case DockingIndicatorPosition.Top:
					return Dock.Top;
				default:
					Debug.Fail("Unexpected DockingIndicatorPosition:" + position.ToString());
					return Dock.Left;
			}
		}

		/// <summary>
		/// Returns the <see cref="Dock"/> indicating the side to which the pane location is associated. Should only be used with DockedXXX enum values.
		/// </summary>
		/// <param name="location">The location to evaluate</param>
		/// <returns>One of the <see cref="Dock"/> values depending on the location</returns>
		public static Dock GetDockedSide(PaneLocation location)
		{
			switch (location)
			{
				case PaneLocation.DockedBottom:
					return Dock.Bottom;
				case PaneLocation.DockedLeft:
					return Dock.Left;
				case PaneLocation.DockedRight:
					return Dock.Right;
				case PaneLocation.DockedTop:
					return Dock.Top;
				default:
					Debug.Fail("Unexpected PaneLocation:" + location.ToString());
					return Dock.Left;
			}
		}
		#endregion //GetDockedSide

		#region GetAllPanes
		internal static List<ContentPane> GetAllPanes(UIElement rootElement, PaneFilterFlags filter)
		{
			IPaneContainer container = rootElement as IPaneContainer ?? GetParentPane(rootElement);
			List<ContentPane> panes = new List<ContentPane>();
			ContentPane pane = DockManagerUtilities.GetFirstLastPane(rootElement, true, filter);

			while (null != pane)
			{
				panes.Add(pane);
				pane = DockManagerUtilities.GetNextPreviousPane(pane, false, true, container, filter);
			}

			return panes;
		} 
		#endregion //GetAllPanes

		#region GetFirstLastPane
		/// <summary>
		/// Helper method for getting the first or last ContentPane given a TabGroupPane or SplitPane.
		/// </summary>
		/// <param name="parent">The TabGroupPane or SplitPane to start with.</param>
		/// <param name="first">True to return the first visible pane. False to return the last visible pane.</param>
		/// <returns>The first or last visible ContentPane given a visible container.</returns>
		internal static ContentPane GetFirstLastPane(UIElement parent, bool first)
		{
			return GetFirstLastPane(parent, first, PaneFilterFlags.AllVisible);
		}

		/// <summary>
		/// Helper method for getting the first or last ContentPane given a TabGroupPane or SplitPane.
		/// </summary>
		/// <param name="parent">The TabGroupPane or SplitPane to start with.</param>
		/// <param name="first">True to return the first visible pane. False to return the last visible pane.</param>
		/// <param name="filter">The criteria used to determine which panes to include</param>
		/// <returns>The first or last visible ContentPane given a visible container.</returns>
		internal static ContentPane GetFirstLastPane(UIElement parent, bool first, PaneFilterFlags filter)
		{
			if (parent == null)
				return null;

			IPaneContainer container = parent as IPaneContainer ?? GetParentPane(parent);

			if (null != container)
				return GetNextPreviousDescendantPane(container, null, first, filter);

			return null;
		} 
		#endregion //GetFirstLastPane

		#region GetNextPreviousPane
		/// <summary>
		/// Returns the next/previous content pane. If the pane is a document, then returns the next/previous document; otherwise returns the next/previous pane exluding documents.
		/// </summary>
		/// <param name="startingPane">The content pane to start with.</param>
		/// <param name="wrap">True if the first/last pane should be returned if there are no more panes in the direction being searched.</param>
		/// <param name="next">True to find the next pane and false to find the previous pane.</param>
		/// <param name="rootContainer">The root most container to consider when navigating</param>
		/// <returns></returns>
		internal static ContentPane GetNextPreviousPane(ContentPane startingPane, bool wrap, bool next, IPaneContainer rootContainer)
		{
			PaneFilterFlags filter;

			switch (XamDockManager.GetPaneLocation(startingPane))
			{
				case PaneLocation.Document:
					filter = PaneFilterFlags.Document;
					break;
				case PaneLocation.Unknown:
					return null;
				default:
					filter = PaneFilterFlags.AllVisibleExceptDocument;
					break;
			}
			return GetNextPreviousPane(startingPane, wrap, next, rootContainer, filter);
		}

		/// <summary>
		/// Returns the next/previous content pane. If the pane is a document, then returns the next/previous document; otherwise returns the next/previous pane exluding documents.
		/// </summary>
		/// <param name="startingPane">The content pane to start with.</param>
		/// <param name="wrap">True if the first/last pane should be returned if there are no more panes in the direction being searched.</param>
		/// <param name="next">True to find the next pane and false to find the previous pane.</param>
		/// <param name="rootContainer">The root most container to consider when navigating</param>
		/// <param name="filter">A set of flags indicating the location of the pane to include in the search</param>
		internal static ContentPane GetNextPreviousPane(ContentPane startingPane, bool wrap, bool next, IPaneContainer rootContainer, PaneFilterFlags filter)
		{
			// AS 5/30/08 BR33507
			if (null == startingPane)
			{
				Debug.Assert(rootContainer is UIElement);
				return GetFirstLastPane(rootContainer as UIElement, next, filter);
			}

			Debug.Assert(null != startingPane);

			// use root container
			rootContainer = rootContainer ?? XamDockManager.GetDockManager(startingPane);

			IPaneContainer parent = null;
			ContentPane nextPrevious = null;
			object child = startingPane;

			while (null != (parent = GetParentPane(child)))
			{
				// walk down the parent looking for another pane
				nextPrevious = GetNextPreviousDescendantPane(parent, child, next, filter);

				// if we found one, we're done
				if (null != nextPrevious)
					break;

				if (parent == rootContainer)
					break;

				// walk up to the parent and use this parent as the child pane
				child = parent;
				parent = GetParentPane(parent);
			}

			// if we are wrapping and we didn't find one then start with the first/last one in the dockmanager
			if (nextPrevious == null && true == wrap)
			{
				if (null != rootContainer)
					nextPrevious = GetNextPreviousDescendantPane(rootContainer, null, next, filter);
			}

			return nextPrevious;
		} 
		#endregion // GetNextPreviousPane

		#region GetNextPreviousDescendantPane
		/// <summary>
		/// Helper method for finding the next/previous content pane within a container
		/// </summary>
		/// <param name="parent">The parent to evaluate</param>
		/// <param name="child">The child to start before/after based on <paramref name="next"/> or null to start at the beginning/end.</param>
		/// <param name="next">True to find the next item in the list or false to find the previous item in the list</param>
		/// <param name="filter">A set of flags indicating which panes should be included in the search</param>
		/// <returns></returns>
		private static ContentPane GetNextPreviousDescendantPane(IPaneContainer parent, object child, bool next, PaneFilterFlags filter)
		{
			Debug.Assert(child == null || child is ContentPane || child is IPaneContainer || child is ContentPanePlaceholder);
			Debug.Assert(parent is FrameworkElement);

			FrameworkElement parentElement = parent as FrameworkElement;

			if (null == parentElement || false == MeetsCriteria(parentElement, filter))
			{
				return null;
			}

			// find out where the child is in the collection
			int parentPaneCount = parent.Panes.Count;
			int startingIndex = child != null
				? parent.Panes.IndexOf(child)
				: (next ? -1 : parentPaneCount);
			int adjustment = next ? +1 : -1;
			int end = next ? parentPaneCount : -1;

			for (int index = startingIndex + adjustment; index != end; index += adjustment)
			{
				FrameworkElement nextChild = parent.Panes[index] as FrameworkElement;

				if (nextChild != null)
				{
					ContentPane descendant = nextChild as ContentPane;

					if (descendant == null)
					{
						// note: the parent check for dockmanager isn't absolutely necessary. this is 
						// just an optimization since once we get a level deeper then we are always in
						// a specific location
						if (parent is XamDockManager && false == MeetsCriteria(nextChild, filter))
							continue;

						Debug.Assert(nextChild is IPaneContainer || nextChild is ContentPanePlaceholder);

						if (nextChild is IPaneContainer)
							descendant = GetNextPreviousDescendantPane((IPaneContainer)nextChild, null, next, filter);
					}
					else if (false == MeetsCriteria(descendant, filter))
					{
						// ignore a pane that doesn't meet the criteria
						continue;
					}

					if (null != descendant)
						return descendant;
				}
			}

			return null;
		}

		#endregion //GetNextPreviousDescendantPane

		#region GetParentPane
		/// <summary>
		/// Helper method for getting the parent of a given pane.
		/// </summary>
		/// <param name="childPane">The pane whose parent is to be returned</param>
		/// <returns></returns>
		internal static IPaneContainer GetParentPane(object childPane)
		{
			Debug.Assert(childPane is DependencyObject);

			DependencyObject dep = childPane as DependencyObject;
			IPaneContainer container = null;

			while (null != dep)
			{
				// we favor the logical parent of the visual for this
				DependencyObject parent = LogicalTreeHelper.GetParent(dep) ?? VisualTreeHelper.GetParent(dep);

				container = parent as IPaneContainer;

				// if the logical parent isn't an ipanecontainer see if the visual parent is
				if (container != null)
					break;

				dep = parent;
			}

			if (container == null)
			{
				//Debug.Assert(childPane is PaneToolWindow || childPane is XamDockManager);

				if (childPane is PaneToolWindow)
					container = XamDockManager.GetDockManager((PaneToolWindow)childPane);
			}

			return container;
		} 
		#endregion //GetParentPane

		#region GetRootSplitPane
		internal static SplitPane GetRootSplitPane(FrameworkElement element)
		{
			PaneLocation location = XamDockManager.GetPaneLocation(element);

			if (location == PaneLocation.Unknown)
				return null;

			Debug.Assert(location != PaneLocation.Document, "Not sure what the correct split pane should be for this so review this code when hit.");

			SplitPane previousSplit = element as SplitPane;
			IPaneContainer parent = previousSplit ?? GetParentPane(element);

			// AS 7/17/09 TFS18453/TFS19568
			//while (null != parent)
			// AS 9/24/09 TFS22613
			//while (null != parent && !(parent is XamDockManager))
			while (null != parent && !(parent is XamDockManager) && !(parent is DocumentContentHost))
			{
				if (parent is SplitPane)
					previousSplit = (SplitPane)parent;

				parent = GetParentPane(parent);
			}

			return previousSplit;
		} 
		#endregion //GetRootSplitPane

        // AS 10/9/08 TFS6846
        #region GetTabControlChild
        internal static DependencyObject GetTabControlChild(DependencyObject descendant, TabControl tabControl)
        {
            // find the root tab item
            while (descendant != null && LogicalTreeHelper.GetParent(descendant) != tabControl)
            {
                DependencyObject parent = null;

                if (descendant is Visual || descendant is System.Windows.Media.Media3D.Visual3D)
                    parent = VisualTreeHelper.GetParent(descendant);

                if (null == parent)
                    parent = LogicalTreeHelper.GetParent(descendant);

                descendant = parent;
            }

            return descendant;
        } 
        #endregion //GetTabControlChild

		// AS 9/24/09 TFS22599
		// The value of the Width/Height is not necessarily constrained by the 
		// min/max so we need to constrain it ourselves. I'm following the precedence 
		// that the WPF framework uses which is that minwidth overrides maxwidth.
		//
		#region GetWidth|Height
		internal static double GetExtent(FrameworkElement element, bool defaultToActual, bool isWidth)
		{
			if (isWidth)
				return GetWidth(element, defaultToActual);
			else
				return GetHeight(element, defaultToActual);
		}

		internal static double GetWidth(FrameworkElement element, bool defaultToActual)
		{
			double extent = element.Width;

			if (double.IsNaN(extent))
				return defaultToActual ? element.ActualWidth : double.NaN;

			return Math.Max(Math.Min(extent, element.MaxWidth), element.MinWidth);
		}

		internal static double GetHeight(FrameworkElement element, bool defaultToActual)
		{
			double extent = element.Height;

			if (double.IsNaN(extent))
				return defaultToActual ? element.ActualHeight : double.NaN;

			return Math.Max(Math.Min(extent, element.MaxHeight), element.MinHeight);
		} 
		#endregion //GetWidth|Height

		#region InitializePaneFloatingSize
		internal static void InitializePaneFloatingSize(FrameworkElement group, IList items, Size arrangeBounds)
		{
			// store the last size at which a pane was floating
			if (DockManagerUtilities.IsFloating(XamDockManager.GetPaneLocation(group)))
			{
				PaneToolWindow window = ToolWindow.GetToolWindow(group) as PaneToolWindow;

				// AS 1/26/11 NA 2011 Vol 1 - Min/Max/Taskbar
				if (window.WindowState != WindowState.Normal)
					return;

				// AS 4/25/08
				// There were some cases where we were removing non-client size from the
				// size in toolwindowhost but that was causing a problem whereby a window
				// could increase in size. Since that was removed then we should remove
				// this size as well. We only want to do this if the window is not using
				// the os client area since in that case the toolwindow itself will be 
				// providing the nonclientsize - i.e. part of its width/height will 
				// go towards the "non-client" area.
				//
				if (null != window && window.IsUsingOSNonClientArea == false)
					arrangeBounds = window.AddNonClientSize(arrangeBounds);

				for (int i = 0, count = items.Count; i < count; i++)
				{
					ContentPane cp = items[i] as ContentPane;

					if (null != cp)
						cp.LastFloatingSize = arrangeBounds;
				}
			}
		}
		#endregion //InitializePaneFloatingSize

		// AS 6/12/12 TFS113795
		#region IsInDisabledWindow
		internal static bool IsInDisabledWindow(Window window)
		{
			if (window == null || BrowserInteropHelper.IsBrowserHosted)
				return false;

			return IsInDisabledWindowImpl(window);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static bool IsInDisabledWindowImpl(Window window)
		{
			WindowInteropHelper wih = new WindowInteropHelper(window);

			if (wih.Handle == IntPtr.Zero)
				return false;

			// if a modal window was shown then the window is disabled
			return !NativeWindowMethods.IsWindowEnabled(wih.Handle);
		} 
		#endregion //IsInDisabledWindow

		#region IsExplicitlyHidden
		private static bool IsExplicitlyHidden(UIElement element)
		{
			object visibility = element.ReadLocalValue(UIElement.VisibilityProperty);

			if (visibility is Visibility && Visibility.Collapsed.Equals(visibility))
				return true;

			return false;
		} 
		#endregion //IsExplicitlyHidden

		#region IsGreaterThan
		internal static bool IsGreaterThan(double value, double comparison)
		{
			return value > comparison && !AreClose(value, comparison);
		} 
		#endregion //IsGreaterThan

		// AS 9/11/09 TFS21329
		#region IsMouseOver
		internal static bool IsMouseOver(FrameworkElement element)
		{
			// note, this routine specifically does not use the Mouse.GetPosition 
			// method because that will return the last mouse value when the 
			// mouse was over a wpf element and will not be updated as the mouse 
			// is moved over an hwndhost. the point of this method is to get the 
			// current actual mouse position relative to the specified element
			Point screenPt = NativeWindowMethods.GetCurrentMousePosition();

			Rect r = new Rect(element.RenderSize);
			Point clientPt = Utilities.PointFromScreenSafe(element, screenPt);

			return r.Contains(clientPt);
		}
		#endregion //IsMouseOver

		// AS 7/17/09 TFS18453/TFS19568
		#region IsValidDockManagerElement
		internal static bool IsValidDockManagerElement(XamDockManager dockManager, FrameworkElement element)
		{
			XamDockManager dmElement = XamDockManager.GetDockManager(element);

			// if the pane is getting the inherited dm property then its ok
			if (dmElement == dockManager)
				return true;

			// if it was some other dm then its not but if its null we have to 
			// check more information
			if (dmElement == null)
			{
				// get the root split pane
				SplitPane split = GetRootSplitPane(element);

				if (split != null)
				{
					dmElement = XamDockManager.GetDockManager(split);

					// if that split is associated with the dm then we're ok
					if (dmElement == dockManager)
						return true;

					if (dmElement == null)
					{
						// AS 9/24/09 TFS22613
						//if (LogicalTreeHelper.GetParent(split) == dockManager)
						DependencyObject parent = LogicalTreeHelper.GetParent(split);

						if (parent == dockManager)
							return true;

						// AS 9/24/09 TFS22613
						// It's also valid if its a child of a documentcontenthost within a dockmanager.
						//
						if (parent == dockManager.DocumentContentHost)
							return true;
					}
				}
			}

			// AS 10/16/09 TFS22613
			// To be safe we should consider any element still in the logical tree to be a valid dockamanger element.
			//
			if (Utilities.IsDescendantOf(dockManager, element, true))
				return true;

			return false;
		}
		#endregion //IsValidDockManagerElement

		#region GetTabGroupPane
		internal static TabGroupPane GetTabGroupPane(SplitPane pane)
		{
			// if for some reason the developer hides the group then skip it
			// if its just hidden because we coerced it as such (because it has
			// no visible panes) then we can keep going
			if (IsExplicitlyHidden(pane))
				return null;

			foreach (FrameworkElement child in pane.Panes)
			{
				TabGroupPane group = child as TabGroupPane;

				if (null != group && false == IsExplicitlyHidden(group))
					return group;

				SplitPane split = child as SplitPane;

				Debug.Assert(null != split);

				if (null != split)
				{
					group = GetTabGroupPane(split);

					if (null != group)
						return group;
				}
			}

			return null;
		} 
		#endregion //GetTabGroupPane

		#region GetDockedLocation
		internal static PaneLocation GetDockedLocation(Dock side)
		{
			switch (side)
			{
				default:
				case Dock.Left:
					return PaneLocation.DockedLeft;
				case Dock.Top:
					return PaneLocation.DockedTop;
				case Dock.Bottom:
					return PaneLocation.DockedBottom;
				case Dock.Right:
					return PaneLocation.DockedRight;
			}
		} 
		#endregion //GetDockedLocation

		#region GetInitialLocation
		internal static InitialPaneLocation GetInitialLocation(Dock side)
		{
			switch (side)
			{
				default:
				case Dock.Left:
					return InitialPaneLocation.DockedLeft;
				case Dock.Top:
					return InitialPaneLocation.DockedTop;
				case Dock.Bottom:
					return InitialPaneLocation.DockedBottom;
				case Dock.Right:
					return InitialPaneLocation.DockedRight;
			}
		}

		internal static InitialPaneLocation GetInitialLocation(PaneLocation location)
		{
			switch (location)
			{
				case PaneLocation.DockedBottom:
					return InitialPaneLocation.DockedBottom;
				case PaneLocation.DockedLeft:
					return InitialPaneLocation.DockedLeft;
				case PaneLocation.DockedRight:
					return InitialPaneLocation.DockedRight;
				case PaneLocation.DockedTop:
					return InitialPaneLocation.DockedTop;
				case PaneLocation.FloatingOnly:
					return InitialPaneLocation.FloatingOnly;
				case PaneLocation.Floating:
					return InitialPaneLocation.DockableFloating;
				default:
					Debug.Fail("Invalid location!");
					return InitialPaneLocation.FloatingOnly;
			}
		}
		#endregion //GetInitialLocation

		// AS 11/12/09 TFS24789 - TabItemDragBehavior
		#region GetItemContainer
		internal static DependencyObject GetItemContainer(ItemsControl itemsControl, int index, bool before, bool includeIndex)
		{
			int containerIndex;
			return GetItemContainer(itemsControl, index, before, includeIndex, out containerIndex);
		}

		internal static DependencyObject GetItemContainer(ItemsControl itemsControl, int index, bool before, bool includeIndex, out int containerIndex)
		{
			Debug.Assert(null != itemsControl);

			int count = itemsControl.Items.Count;
			int increment = before ? -1 : 1;
			int start = index + (includeIndex ? 0 : increment);
			int end = before ? -1 : count;

			if (start >= 0 && start < count)
			{
				ItemContainerGenerator generator = itemsControl.ItemContainerGenerator;

				for (int i = start; i != end; i += increment)
				{
					DependencyObject temp = generator.ContainerFromIndex(i);

					if (null != temp && true.Equals(temp.GetValue(UIElement.IsVisibleProperty)))
					{
						containerIndex = i;
						return temp;
					}
				}
			}

			containerIndex = -1;
			return null;
		}
		#endregion //GetItemContainer

		// AS 3/17/11 TFS67321
		// Refactored the DragManager's GetDragPaneContainers into a common helper routine.
		//
		#region GetPaneContainers
		internal static IList<IContentPaneContainer> GetPaneContainers(IList<ContentPane> panes)
		{
			List<IContentPaneContainer> containers = new List<IContentPaneContainer>();
			IContentPaneContainer lastContainer = null;

			if (null != panes)
			{
				foreach (ContentPane cp in panes)
				{
					if (cp == null)
						continue;

					IContentPaneContainer container = cp.PlacementInfo.CurrentContainer;

					if (lastContainer == container)
						continue;

					lastContainer = container;

					if (false == containers.Contains(container))
						containers.Add(container);
				}
			}

			return containers;
		} 
		#endregion //GetPaneContainers

		#region GetPreviewLocation
		internal static DropPreviewTabLocation GetPreviewLocation(Dock side)
		{
			switch (side)
			{
				case Dock.Left:
					return DropPreviewTabLocation.Left;
				default:
				case Dock.Top:
					return DropPreviewTabLocation.Top;
				case Dock.Right:
					return DropPreviewTabLocation.Right;
				case Dock.Bottom:
					return DropPreviewTabLocation.Bottom;
			}
		} 
		#endregion //GetPreviewLocation

		#region IndexOf
		internal static int IndexOf(IList list, ContentPane pane, bool includePlaceholders)
		{
			if (includePlaceholders == false)
				return list.IndexOf(pane);

			for (int i = 0, count = list.Count; i < count; i++)
			{
				object element = list[i];

				if (element == pane)
					return i;

				ContentPanePlaceholder placeholder = element as ContentPanePlaceholder;

				if (null != placeholder && placeholder.IsPane(pane))
					return i;
			}

			return -1;
		}
		#endregion //IndexOf

		#region InitializeCurrentContainer
		/// <summary>
		/// Helper method to set the CurrentContainer of a ContentPane's PlacementInfo
		/// </summary>
		/// <param name="item">The item to be updated</param>
		/// <param name="container">The new container</param>
		internal static void InitializeCurrentContainer(object item, IContentPaneContainer container)
		{
			ContentPane pane = item as ContentPane;

			if (null != pane)
				pane.PlacementInfo.CurrentContainer = container;
			else
			{
				ContentPanePlaceholder placeholder = item as ContentPanePlaceholder;

				if (null != placeholder)
					placeholder.Container = container;
			}
		}

		/// <summary>
		/// Helper method to set the CurrentContainer of a ContentPane's PlacementInfo
		/// </summary>
		/// <param name="list">The list whose ContentPane instances are to be updated</param>
		/// <param name="container">The new container</param>
		internal static void InitializeCurrentContainer(IList list, IContentPaneContainer container)
		{
			for (int i = 0, count = list.Count; i < count; i++)
				InitializeCurrentContainer(list[i], container);
		}

		/// <summary>
		/// Helper method to set the CurrentContainer of a ContentPane's PlacementInfo in response to a NotifyCollectionChanged event
		/// </summary>
		/// <param name="list">The list whose ContentPane instances are to be updated</param>
		/// <param name="container">The new container</param>
		/// <param name="e">The event args providing information about the change</param>
		internal static void InitializeCurrentContainer(IList list, IContentPaneContainer container, NotifyCollectionChangedEventArgs e)
		{
			switch (e.Action)
			{
				case NotifyCollectionChangedAction.Add:
					DockManagerUtilities.InitializeCurrentContainer(e.NewItems, container);
					break;
				case NotifyCollectionChangedAction.Remove:
					DockManagerUtilities.InitializeCurrentContainer(e.OldItems, null);
					break;
				case NotifyCollectionChangedAction.Move:
					break;
				case NotifyCollectionChangedAction.Replace:
					DockManagerUtilities.InitializeCurrentContainer(e.NewItems, container);
					DockManagerUtilities.InitializeCurrentContainer(e.OldItems, null);
					break;
				case NotifyCollectionChangedAction.Reset:
					DockManagerUtilities.InitializeCurrentContainer(list, container);
					break;
			}
		}
		#endregion //InitializeCurrentContainer

		#region IsDockable
		/// <summary>
		/// Returns a boolean indicating if the location is one of the dockable locations.
		/// </summary>
		/// <param name="location">The pane location to evaluate</param>
		/// <returns>True if the location is bottom, left, right, top or floating. Otherwise false is returned.</returns>
		public static bool IsDockable(PaneLocation location)
		{
			switch (location)
			{
				case PaneLocation.DockedBottom:
				case PaneLocation.DockedLeft:
				case PaneLocation.DockedRight:
				case PaneLocation.DockedTop:
				case PaneLocation.Floating:
					return true;
				default:
					return false;
			}
		}
		#endregion //IsDockable

		#region IsDocked
		/// <summary>
		/// Returns a boolean indicating if the location is one of the docked (left/right/top/bottom) locations
		/// </summary>
		/// <param name="element">The element whose pane location is to be evaluated</param>
		/// <returns>True if the location is bottom, left, right, or top. Otherwise false is returned.</returns>
		public static bool IsDocked(FrameworkElement element)
		{
			return IsDocked(XamDockManager.GetPaneLocation(element));
		}

		/// <summary>
		/// Returns a boolean indicating if the location is one of the docked (left/right/top/bottom) locations
		/// </summary>
		/// <param name="location">The pane location to evaluate</param>
		/// <returns>True if the location is bottom, left, right, or top. Otherwise false is returned.</returns>
		public static bool IsDocked(PaneLocation location)
		{
			switch (location)
			{
				case PaneLocation.DockedBottom:
				case PaneLocation.DockedLeft:
				case PaneLocation.DockedRight:
				case PaneLocation.DockedTop:
					return true;
				default:
					return false;
			}
		}
		#endregion //IsDocked

		#region IsFloating
		/// <summary>
		/// Returns a boolean indicating if the location is Floating or FloatingOnly
		/// </summary>
		/// <param name="location">The pane location to evaluate</param>
		/// <returns>True if the location is Floating or FloatingOnly. Otherwise false is returned.</returns>
		public static bool IsFloating(PaneLocation location)
		{
			switch (location)
			{
				case PaneLocation.Floating:
				case PaneLocation.FloatingOnly:
					return true;
				default:
					return false;
			}
		}
		#endregion //IsFloating

		#region LoadCursor
		/// <summary>
		/// Loads a cursor from the specified resource
		/// </summary>
		/// <param name="typeInAssembly">The type whose assembly contains the resource</param>
		/// <param name="cursorPath">The path to the cursor in the assembly</param>
		/// <returns>A cursor for the specified resource</returns>
		public static Cursor LoadCursor(Type typeInAssembly, string cursorPath)
		{
            
#region Infragistics Source Cleanup (Region)




























#endregion // Infragistics Source Cleanup (Region)

            return Utilities.LoadCursor(typeInAssembly, cursorPath);
		} 
		#endregion // LoadCursor

		#region MeetsCriteria
		/// <summary>
		/// Helper method for determining if an element meets the specified filter criteria based on its current <see cref="XamDockManager.PaneLocationProperty"/>
		/// </summary>
		/// <param name="element">The element whose PaneLocation will be evaluated</param>
		/// <param name="filter">The filter to check</param>
		/// <returns>True if the element's PaneLocation is one of the items in the filter.</returns>
		internal static bool MeetsCriteria(FrameworkElement element, PaneFilterFlags filter)
		{
			// exclude hidden panes if the flag isn't included
			if ((filter & PaneFilterFlags.Hidden) != PaneFilterFlags.Hidden)
			{
				if (element.Visibility != Visibility.Visible)
					return false;

				// AS 6/23/11 TFS73499
				// We shouldn't show/navigate to a pane that is within a hidden floating window.
				// Also, we shouldn't show the root windows if the root visual is hidden.
				//
				if ((filter & PaneFilterFlags.IgnoreFloatingWindowVisibility) != PaneFilterFlags.IgnoreFloatingWindowVisibility)
				{
					var dm = XamDockManager.GetDockManager(element);

					if (null != dm  && !dm.MeetsVisibleCriteria(element))
						return false;
				}
			}

			switch (XamDockManager.GetPaneLocation(element))
			{
				case PaneLocation.Document:
					return (filter & PaneFilterFlags.Document) == PaneFilterFlags.Document;
				case PaneLocation.Unpinned:
					return (filter & PaneFilterFlags.Unpinned) == PaneFilterFlags.Unpinned;
				case PaneLocation.FloatingOnly:
					return (filter & PaneFilterFlags.FloatingOnly) == PaneFilterFlags.FloatingOnly;
				case PaneLocation.Floating:
					return (filter & PaneFilterFlags.FloatingDockable) == PaneFilterFlags.FloatingDockable;
				case PaneLocation.Unknown:
					//Debug.Assert(element is XamDockManager);
					return true;
				default:
					return (filter & PaneFilterFlags.Docked) == PaneFilterFlags.Docked;
			}
		}
		#endregion //MeetsCriteria

		#region MoveFocus
		internal static bool MoveFocus(DependencyObject d, TraversalRequest request)
		{
			if (d is UIElement)
				return ((UIElement)d).MoveFocus(request);
			else if (d is ContentElement)
				return ((ContentElement)d).MoveFocus(request);
            // AS 9/23/08
			//else if (d is UIElement3D)
			//	return ((UIElement3D)d).MoveFocus(request);
            else if (_couldBe3D)
            {
                try
                {
                    return MoveFocusSP(d, request);
                }
                catch
                {
                    _couldBe3D = false;
                    return false;
                }
            }
            else
                return false;
		} 

        private static bool _couldBe3D = true;

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework", MessageId = "System.Windows.UIElement3D")]
        [MethodImpl(MethodImplOptions.NoInlining)]
        private static bool MoveFocusSP(DependencyObject d, TraversalRequest request)
        {
            if (d is UIElement3D)
            	return ((UIElement3D)d).MoveFocus(request);
            else
                return false;
        }
		#endregion //MoveFocus

		#region MovePane
		internal static void MovePane(ContentPane pane, IContentPaneContainer newContainer, int? newIndex, PaneLocation newLocation)
		{
			// AS 4/28/11 TFS73532
			MovePane(pane, newContainer, newIndex, newLocation, null);
		}

		// AS 4/28/11 TFS73532
		internal static void MovePane(ContentPane pane, IContentPaneContainer newContainer, int? newIndex, PaneLocation newLocation, MovePaneHelper moveHelper)
		{
			Debug.Assert(newContainer.PaneLocation == PaneLocation.Unknown || newContainer.PaneLocation == newLocation);

			IContentPaneContainer container = pane.PlacementInfo.CurrentContainer;
			PaneLocation currentLocation = pane.PaneLocation;
			bool needsPlaceholder = DockManagerUtilities.NeedsPlaceholder(currentLocation, newLocation);

			Debug.Assert(container != null);

			// AS 4/28/11 TFS73532 
			if (null != moveHelper)
				moveHelper.AddPaneToBeMoved(pane);

			// AS 1/31/11 NA 2011 Vol 1 - Min/Max/Taskbar
			// I don't think this is specific to this version but while debugging I found a 
			// case that the flyout was getting displayed while a pane was being moved during 
			// a drag operation.
			//
			XamDockManager dm = XamDockManager.GetDockManager(pane);

			if (dm != null)
				dm.SuspendShowFlyout();

			try
			{
				// AS 10/15/08 TFS8068
				// Maintain the DataContext during the move.
				//
				using (DockManagerUtilities.CreateMoveReplacement(pane))
				{
					container.RemoveContentPane(pane, needsPlaceholder);
					newContainer.InsertContentPane(newIndex, pane);
				}
			}
			finally
			{
				if (dm != null)
					dm.ResumeShowFlyout();
			}
		}
		#endregion //MovePane

        // AS 3/13/09 FloatingWindowDragMode
        // Moved here from MoveWindowAction to allow reuse.
        //
        #region MoveToolWindow
        internal static void MoveToolWindow(ToolWindow window, Point location)
        {
            Debug.Assert(null != window);

            if (null != window)
            {
				// AS 1/31/11 NA 2011 Vol 1 - Min/Max/Taskbar
				// During the drag operation the window may have been moved into a maximized 
				// state in which case we should not be adjusting the window's location.
				//
				if (window.WindowState != WindowState.Normal)
					return;

                System.Windows.Window topLevelWindow = LogicalTreeHelper.GetParent(window) as System.Windows.Window;

                if (null != topLevelWindow)
                {
                    NativeWindowMethods.MoveWindow(topLevelWindow, location);
                }
                else
                {
                    window.Top = location.Y;
                    window.Left = location.X;
                }
            }
        } 
        #endregion //MoveToolWindow

		#region NeedsPlaceholder
		internal static bool NeedsPlaceholder(PaneLocation location, PaneLocation newLocation)
		{
			switch (location)
			{
				case PaneLocation.Document:
				case PaneLocation.Unpinned:
					return false;
				default:
				{
					if (location == newLocation)
						return false;

					// if it was docked and will be docked then we don't want a placeholder
					if (DockManagerUtilities.IsDocked(location) && DockManagerUtilities.IsDocked(newLocation))
						return false;

					return true;
				}
			}
		} 
		#endregion //NeedsPlaceholder

		#region ProcessCoerceVisibility
		/// <summary>
		/// Helper method for determining if an ItemsControl or SplitPane has any visible children.
		/// </summary>
		/// <param name="parent">ItemsControl or SplitPane to evaluate</param>
		/// <param name="newVisibility">The new visibility state to use if there are visible elements</param>
		/// <returns>The <paramref name="newVisibility"/> or Collapsed if there are no visible children.</returns>
		internal static object ProcessCoerceVisibility(DependencyObject parent, object newVisibility)
		{
			// AS 10/5/09 NA 2010.1 - LayoutMode
			// Moved previous implementation into a helper routine.
			//
			object visibility = CalculateDefaultVisibility(parent, newVisibility);

			object splitterVisibility = visibility;

			// if this is the fill pane then we want to hide the splitter bar
			if (true.Equals(parent.GetValue(SplitPane.IsFillPaneProperty)))
				splitterVisibility = KnownBoxes.VisibilityCollapsedBox;

			

			// update the splitter visibility
			parent.SetValue(PaneSplitter.SplitterVisibilityPropertyKey, splitterVisibility);

			return visibility;
		}

		// AS 10/5/09 NA 2010.1 - LayoutMode
		// This was the previous implementation of the ProcessCoerceVisibility.
		//
		private static object CalculateDefaultVisibility(DependencyObject parent, object newVisibility)
		{
			if (KnownBoxes.VisibilityCollapsedBox.Equals(newVisibility))
				return newVisibility;

			// AS 4/28/11 TFS73532
			// If the element will have visible children then we can honor the visibility.
			//
			if (MovePaneHelper.GetHasVisibleChildrenPending(parent))
				return newVisibility;

			Debug.Assert(parent is SplitPane || parent is ItemsControl);

			IList list = parent is SplitPane
				? ((SplitPane)parent).Panes as IList
				: ((ItemsControl)parent).Items as IList;

			if (DesignerProperties.GetIsInDesignMode(parent) == true && list.Count == 0)
				return newVisibility;

			for (int i = 0, count = list.Count; i < count; i++)
			{
				UIElement element = list[i] as UIElement;

				if (element != null && element.Visibility != Visibility.Collapsed)
					return newVisibility;
			}

			return KnownBoxes.VisibilityCollapsedBox;
		}
		#endregion //ProcessCoerceVisibility

		#region RaiseVisibilityChanged
		internal static void RaiseVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			IInputElement inputElement = d as IInputElement;

			if (null != inputElement)
			{
				// AS 5/5/10 TFS30072
				// We need to raise this even if the visibility goes to/from hidden.
				//
				//if (KnownBoxes.VisibilityCollapsedBox.Equals(e.NewValue) ||
				//	KnownBoxes.VisibilityCollapsedBox.Equals(e.OldValue))
				{
					RoutedEventArgs args = new RoutedEventArgs(DockManagerUtilities.VisibilityChangedEvent);
					inputElement.RaiseEvent(args);
				}
			}
		} 
		#endregion //RaiseVisibilityChanged

		#region RemoveContainerIfNeeded
		internal static void RemoveContainerIfNeeded(IContentPaneContainer container)
		{
			// AS 3/17/11 TFS67321
			// Added null check just in case.
			//
			if (container == null)
				return;

			IPaneContainer paneContainer = container.ContainerElement as IPaneContainer;

			Debug.Assert(null != paneContainer);

			RemoveContainerIfNeeded(paneContainer);
		}

		internal static void RemoveContainerIfNeeded(IPaneContainer paneContainer)
		{
			
			while (null != paneContainer && paneContainer.CanBeRemoved)
			{
				IPaneContainer parent = DockManagerUtilities.GetParentPane(paneContainer);

				if (null != parent && parent.RemovePane(paneContainer))
					paneContainer = parent;
				else // stop the walk
					paneContainer = null;
			}
		}

		// AS 5/21/08
		// Added helper method we can use when processing pane dragging to ensure we remove
		// unused containers.
		//
		internal static void RemoveContainersIfNeeded(IList<IContentPaneContainer> containers)
		{
			for (int i = 0, count = containers.Count; i < count; i++)
			{
				IContentPaneContainer container = containers[i];

				if (null != container)
					RemoveContainerIfNeeded(container);
			}
		}
		#endregion //RemoveContainerIfNeeded

		// AS 1/27/11 NA 2011 Vol 1 - Min/Max/Taskbar
		// Originally I had tried to have the ToolWindow listen for the RequestBringIntoView event and automatically 
		// change its WindowState from Minimized to Maximized/Normal. This worked ok in some situations (e.g. using 
		// the pane navigator to activate a pane or toggling the state of a pane from docked to floating). However 
		// it caused the state to change in some situations that you wouldn't want it to. E.g. if the window wasn't 
		// in the taskbar and you were just dragging the minimized window. Or if it was in the taskbar and you 
		// clicked on the preview to restore it. The request bring into view came in while we were activating the 
		// window so we switched to maximized (assuming it was maximized before it was minimized) and then the 
		// WM_SYSCOMMAND for SC_RESTORE came in and so the window was then restored again from maximized to normal.
		// Rather than trying to put a bunch of flags/checks in the toolwindow I'm going to leave it like the WPF 
		// Window where it does not do this and let things using toolwindow decide when it makes sense to restore 
		// the window. So in the case of dockmanager this would be those examples I listed above.
		//
		#region RestoreMinimizedToolWindow
		/// <summary>
		/// Helper method to change the window state of a minimized toolwindow that contains the specified element.
		/// </summary>
		/// <param name="element">The element whose toolwindow windowstate should be changed.</param>
		internal static void RestoreMinimizedToolWindow(FrameworkElement element)
		{
			ToolWindow tw = element != null ? ToolWindow.GetToolWindow(element) : null;

			if (tw != null && tw.WindowState == WindowState.Minimized && tw.Owner != null && tw.IsVisible)
			{
				ToolWindow.RestoreCommand.Execute(null, tw);
			}
		} 
		#endregion //RestoreMinimizedToolWindow

		// AS 3/31/11 TFS66115
		#region RestoreMinimizedWindow
		internal static void RestoreMinimizedWindow(Window w)
		{
			if (w == null)
				return;

			// we want to avoid the invalidopexception that RootBrowserWindow would throw
			Type windowType = w.GetType();

			if (windowType.Assembly == typeof(Window).Assembly && windowType.Name == "RootBrowserWindow")
				return;

			WindowState currentState;

			try
			{
				currentState = w.WindowState;
			}
			catch (InvalidOperationException)
			{
				return;
			}

			if (currentState == WindowState.Minimized)
				w.WindowState = WindowState.Normal;
		}
		#endregion //RestoreMinimizedWindow

		// AS 2/16/12 TFS101691
		// Moved the bulk of the xamDockManager->EnsureIsFocusedElement into a helper method
		// that the PaneToolWindow could use as well.
		//
		#region SetFocusedElement
		internal static void SetFocusedElement(DependencyObject focusScope, UIElement newFocusedElement)
		{
			Utilities.SetFocusedElement(focusScope, newFocusedElement);
		} 
		#endregion //SetFocusedElement

        // AS 10/15/08 TFS6271
        #region ShowToolWindow
		internal static void ShowToolWindow(ToolWindow window, FrameworkElement owner, bool activate)
        {
			// AS 4/28/11 TFS73532
			// Moved to a helper method - BeforeShowToolWindow
			//
			//Debug.Assert(null != owner);
			//DependencyObject focusedElement = Keyboard.FocusedElement as DependencyObject;
			//XamDockManager dm = XamDockManager.GetDockManager(window);
			//Debug.Assert(null != dm);
			//
			//// When a window receives a deactivate notification, it caches the keyboard focused element
			//// as the element to which focus should be restored when it is activated again. Since the 
			//// focused element could be within the floating pane, they could end up storing an element
			//// that isn't going to be within the window. So if the window contains the focused element 
			//// then we will shift focus back to the dockmanager while we are showing the window. If 
			//// the window is being activated then we can restore the focused element as the element 
			//// with focus. I used a helper method to shift the focus since we don't want the XDM 
			//// moving focus to another pane.
			////
			//bool shiftFocus = null != focusedElement &&
			//    null != dm &&
			//    dm.IsKeyboardFocusWithin &&
			//    Utilities.IsDescendantOf(window, focusedElement);
			//
			//if (shiftFocus)
			//    dm.ForceFocus();
			//
			//Debug.Assert(window.Owner == null);
			//
			//// AS 9/11/09 TFS21330
			//// Set the property we use in a PaneToolWindow to determine what is returned from 
			//// the SupportsAllowsTransparency.
			////
			//DockManagerUtilities.InitializePreventAllowsTransparency(window);
			DependencyObject focusedElement;
			XamDockManager dm;
			BeforeShowToolWindow(window, owner, out focusedElement, out dm);

            // AS 3/30/09 TFS16355 - WinForms Interop
            //window.Show(owner, activate);
            bool usePopup = null != dm && dm.ShowToolWindowsInPopup;
            window.Show(owner, activate, usePopup);

            if (activate)
                ((IInputElement)focusedElement).Focus();
        }
        #endregion //ShowToolWindow

		// AS 5/17/08 BR32346
		#region ShouldPreventPaneRemoval
		internal static bool ShouldPreventPaneRemoval(FrameworkElement element)
		{
			return element != null
				&& false == string.IsNullOrEmpty(element.Name)
				&& false == GetAutoGenerated(element);
		}
		#endregion // ShouldPreventPaneRemoval

        #region SubtractHeight
        internal static void SubtractHeight(ref Size size, double adjustment)
        {
            Debug.Assert(size.Height > adjustment || AreClose(size.Height, adjustment));

            size.Height = Math.Max(size.Height - adjustment, 0);
        }
        #endregion // SubtractHeight

        #region SubtractWidth
        internal static void SubtractWidth(ref Size size, double adjustment)
        {
            Debug.Assert(size.Width > adjustment || AreClose(size.Width, adjustment));

            size.Width = Math.Max(size.Width - adjustment, 0);
        }
        #endregion //SubtractWidth

        #region ThrowIfXXX
        /// <summary>
		/// Helper method to throw an exception if the specified enum is not valid for the enum type.
		/// </summary>
		/// <param name="parameter">The enum to evaluate. Note, this should not be a flagged enum.</param>
		/// <param name="parameterName">The name of the parameter. This is used in the exception if the parameter is not a valid enum member.</param>
		public static void ThrowIfInvalidEnum(Enum parameter, string parameterName)
		{
			Type enumType = parameter.GetType();
			Debug.Assert(enumType.GetCustomAttributes(typeof(FlagsAttribute), false).Length == 0, "This should not be used with flagged enums");

			if (false == Enum.IsDefined(enumType, parameter))
			{
				throw new InvalidEnumArgumentException(parameterName, Convert.ToInt32(parameter), enumType);
			}
		}

		/// <summary>
		/// Helper method to throw an exception if the specified parameter is null.
		/// </summary>
		/// <param name="parameter">The parameter to evaluate</param>
		/// <param name="parameterName">The name of the parameter. This is used in the exception if the parameter is null</param>
		public static void ThrowIfNull(object parameter, string parameterName)
		{
			if (null == parameter)
				throw new ArgumentNullException(parameterName);
		} 
		/// <summary>
		/// Helper method to throw an exception if the specified parameter is null.
		/// </summary>
		/// <param name="parameter">The parameter to evaluate</param>
		/// <param name="parameterName">The name of the parameter. This is used in the exception if the parameter is null</param>
		public static void ThrowIfNullOrEmpty(string parameter, string parameterName)
		{
			if (string.IsNullOrEmpty(parameter))
				throw new ArgumentNullException(parameterName);
		}
		#endregion //ThrowIfXXX

		#region ToPaneLocation
		public static PaneLocation ToPaneLocation(InitialPaneLocation initialLocation)
		{
			PaneLocation location;

			switch (initialLocation)
			{
				case InitialPaneLocation.DockableFloating:
					location = PaneLocation.Floating;
					break;
				case InitialPaneLocation.DockedBottom:
					location = PaneLocation.DockedBottom;
					break;
				case InitialPaneLocation.DockedLeft:
					location = PaneLocation.DockedLeft;
					break;
				case InitialPaneLocation.DockedRight:
					location = PaneLocation.DockedRight;
					break;
				case InitialPaneLocation.DockedTop:
					location = PaneLocation.DockedTop;
					break;
				case InitialPaneLocation.FloatingOnly:
					location = PaneLocation.FloatingOnly;
					break;
				default:
					Debug.Fail("Unexpected initial location:" + initialLocation.ToString());
					location = PaneLocation.Unknown;
					break;
			}

			return location;
		}
		#endregion //ToPaneLocation

		#region VerifyOwningToolWindow
		internal static void VerifyOwningToolWindow(FrameworkElement element)
		{
			if (element.IsInitialized == false)
				return;

			// if the visibility has changed and its within a toolwindow then we 
			// may need to change the toolwindow - e.g. change to/from showing
			// the primary pane's title
			PaneToolWindow toolWindow = ToolWindow.GetToolWindow(element) as PaneToolWindow;

			if (null != toolWindow)
				toolWindow.RefreshToolWindowState();
		}
		#endregion //VerifyOwningToolWindow

		#endregion //Methods

		#region Events

		#region VisibilityChanged

		/// <summary>
		/// Routed event raised when the element's Visibility has changed.
		/// </summary>
		internal static RoutedEvent VisibilityChangedEvent = EventManager.RegisterRoutedEvent("VisibilityChanged",
			RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(DockManagerUtilities));

		#endregion //VisibilityChanged

		#endregion //Events

		#region MethodInvoker delegate

		internal delegate void MethodInvoker();

		internal delegate void PaneMethodInvoker(ContentPane pane);

		#endregion //MethodInvoker delegate
	}

	// AS 9/16/09 TFS22219
	#region LogicalContainer class
	internal class LogicalContainer : FrameworkElement
	{
		private IList<object> _children;

		internal LogicalContainer()
		{
			_children = new List<object>();
		}

		protected override IEnumerator LogicalChildren
		{
			get
			{
				return _children.GetEnumerator();
			}
		}

		internal void AddLogicalChildInternal(object child)
		{
			if (null != child)
			{
				Debug.Assert(child is DependencyObject == false || LogicalTreeHelper.GetParent(child as DependencyObject) == null, "Already a logical child of something else");

				_children.Add(child);
				this.AddLogicalChild(child);
			}
		}

		internal void RemoveLogicalChildInternal(object child)
		{
			if (null != child)
			{
				Debug.Assert(child is DependencyObject == false || LogicalTreeHelper.GetParent(child as DependencyObject) == this, "Not a logical child of this container");

				_children.Remove(child);
				this.RemoveLogicalChild(child);
			}
		}
	}
	#endregion //LogicalContainer class

	// AS 8/3/10
	// This class is only needed to avoid directly referencing the BrushHelper class 
	// from xaml. That is only a problem when mixing versions - e.g. using an older 
	// version of 9.1 that doesn't contain a definition of BrushHelper so it seems 
	// like there is a bug in the wpf framework with regards to uri mappings. There 
	// were 2 ways to get around the problem - change the xmlns mapping for windows 
	// to use the clr-namespace=xxx;assembly=yyy pattern but that means hard coding 
	// a version number in the xaml. The other option that we decided to take was to 
	// create a derived BrushHelper class in this assembly and reference the class 
	// that way so we're not using the uri mapping to igWindows.
	//
	#region DockManagerBrushHelper class
	/// <summary>
	/// Provides static brush properties from the base <see cref="BrushHelper"/>
	/// </summary>
	public class DockManagerBrushHelper : BrushHelper
	{
		private DockManagerBrushHelper()
		{
		}
	}
	#endregion //DockManagerBrushHelper class

	// AS 4/28/11 TFS73532
	#region MovePaneHelper class
	internal class MovePaneHelper : DependencyObject, IDisposable
	{
		#region Member Variables

		private XamDockManager _dockManager;
		private IContentPaneContainer _newContainer;
		private FrameworkElement _newContainerElement;
		private Dictionary<ContentPane, object> _panes;
		private PaneToolWindow _toolWindow;

		#endregion //Member Variables

		#region Constructor
		internal MovePaneHelper(XamDockManager dockManager, IContentPaneContainer newContainer, params ContentPane[] panes)
		{
			Utilities.ValidateNotNull(newContainer);

			FrameworkElement containerElement = newContainer.ContainerElement;

			_newContainer = newContainer;
			_newContainerElement = newContainer.ContainerElement;
			_dockManager = dockManager;
			_panes = new Dictionary<ContentPane, object>();

			// AS 7/5/11 TFS80666
			// Moved this down so we suspend the show before coercing the visibility 
			// which could cause the associated toolwindow to be shown too early.
			//
			//foreach (ContentPane pane in panes)
			//    this.AddPaneToBeMoved(pane);

			if (_dockManager != null && _newContainerElement != null)
			{
				// bind to the toolwindow of the container. we want it to wait to show its 
				// children if it tries to show in the interim. we need to do this because we 
				// want to put all the children in the pane first but we need it to have its 
				// hosting element (e.g. WPF Window) created and containing it so the element 
				// tree is established. otherwise the wpf framework will traverse invalidating 
				// as the toolwindow is parented into the containing host
				BindingOperations.SetBinding(this, ToolWindowProperty, Utilities.CreateBindingObject(ToolWindow.ToolWindowProperty, BindingMode.OneWay, _newContainerElement));
			}

			// AS 7/5/11 TFS80666
			// Moved down from above.
			//
			foreach (ContentPane pane in panes)
				this.AddPaneToBeMoved(pane);
		}
		#endregion //Constructor

		#region Properties

		#region HasVisibleChildrenPending

		private static readonly DependencyProperty HasVisibleChildrenPendingProperty =
			DependencyProperty.RegisterAttached("HasVisibleChildrenPending", typeof(bool), typeof(MovePaneHelper),
				new FrameworkPropertyMetadata(KnownBoxes.FalseBox, new PropertyChangedCallback(OnHasVisibleChildrenPendingChanged)));

		private static void OnHasVisibleChildrenPendingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			d.CoerceValue(UIElement.VisibilityProperty);
		}

		public static bool GetHasVisibleChildrenPending(DependencyObject d)
		{
			return (bool)d.GetValue(HasVisibleChildrenPendingProperty);
		}

		private static void SetHasVisibleChildrenPending(DependencyObject d, bool value)
		{
			d.SetValue(HasVisibleChildrenPendingProperty, value);
		}

		#endregion //HasVisibleChildrenPending

		#region ToolWindow

		public static readonly DependencyProperty ToolWindowProperty = DependencyProperty.Register("ToolWindow",
			typeof(ToolWindow), typeof(MovePaneHelper), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(OnToolWindowChanged)));

		private static void OnToolWindowChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
		{
			MovePaneHelper instance = d as MovePaneHelper;
			PaneToolWindow tw = e.NewValue as PaneToolWindow;

			if (e.OldValue != e.NewValue)
			{
				if (tw == null || XamDockManager.GetDockManager(tw) == instance._dockManager)
				{
					instance.OnToolWindowChanged(instance._toolWindow, tw);
				}
			}
		}

		private void OnToolWindowChanged(PaneToolWindow oldWindow, PaneToolWindow newWindow)
		{
			_toolWindow = newWindow;

			if (oldWindow != null)
				oldWindow.ResumeSyncShow();

			if (newWindow != null)
				newWindow.SuspendSyncShow();
		}

		private ToolWindow ToolWindow
		{
			get
			{
				return (ToolWindow)this.GetValue(MovePaneHelper.ToolWindowProperty);
			}
			set
			{
				this.SetValue(MovePaneHelper.ToolWindowProperty, value);
			}
		}

		#endregion //ToolWindow

		#endregion //Properties

		#region Methods

		#region AddPaneToBeMoved
		internal void AddPaneToBeMoved(ContentPane pane)
		{
			if (!_panes.ContainsKey(pane))
			{
				_panes[pane] = null;

				// if the pane is visible then the new container will have at 
				// least one visible child so set a property on the container
				// that will force the coersion of the visibility property so 
				// the containing toolwindow will be displayed
				if (pane.Visibility != Visibility.Collapsed && _newContainerElement != null && _dockManager != null)
					_newContainerElement.SetValue(HasVisibleChildrenPendingProperty, KnownBoxes.TrueBox);
			}
		}
		#endregion //AddPaneToBeMoved

		#endregion //Methods

		#region IDisposable Members
		void IDisposable.Dispose()
		{
			if (_dockManager != null)
			{
				// clear this so we don't get in here again.
				_dockManager = null;

				// clear the flag that forced the pane to be visible. assuming it 
				// has any visible children then the visibility won't change
				_newContainerElement.ClearValue(HasVisibleChildrenPendingProperty);

				// then clear the toolwindow property which should cause us to call 
				// its resumesyncshow actually showing the window.
				BindingOperations.ClearBinding(this, ToolWindowProperty);
			}
		}
		#endregion //IDisposable Members
	} 
	#endregion //MovePaneHelper class
}

#region Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved
/* ---------------------------------------------------------------------*
*                           Infragistics, Inc.                          *
*              Copyright (c) 2001-2012 All Rights reserved               *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* THE SOURCE CODE CONTAINED HEREIN AND IN RELATED FILES IS PROVIDED     *
* TO THE REGISTERED DEVELOPER FOR THE PURPOSES OF EDUCATION AND         *
* TROUBLESHOOTING. UNDER NO CIRCUMSTANCES MAY ANY PORTION OF THE SOURCE *
* CODE BE DISTRIBUTED, DISCLOSED OR OTHERWISE MADE AVAILABLE TO ANY     *
* THIRD PARTY WITHOUT THE EXPRESS WRITTEN CONSENT OF INFRAGISTICS, INC. *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY INFRAGISTICS PRODUCT.    *
*                                                                       *
* THE REGISTERED DEVELOPER ACKNOWLEDGES THAT THIS SOURCE CODE           *
* CONTAINS VALUABLE AND PROPRIETARY TRADE SECRETS OF INFRAGISTICS,      *
* INC.  THE REGISTERED DEVELOPER AGREES TO EXPEND EVERY EFFORT TO       *
* INSURE ITS CONFIDENTIALITY.                                           *
*                                                                       *
* THE END USER LICENSE AGREEMENT (EULA) ACCOMPANYING THE PRODUCT        *
* PERMITS THE REGISTERED DEVELOPER TO REDISTRIBUTE THE PRODUCT IN       *
* EXECUTABLE FORM ONLY IN SUPPORT OF APPLICATIONS WRITTEN USING         *
* THE PRODUCT.  IT DOES NOT PROVIDE ANY RIGHTS REGARDING THE            *
* SOURCE CODE CONTAINED HEREIN.                                         *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* --------------------------------------------------------------------- *
*/
#endregion Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved