<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CalculateFunctionInputText" xml:space="preserve">
    <value>The Calculate Service works like the function box in Microsoft Excel (fn). Type the equation using good maths practices and put a variable from the Data List into the Result field. You can use the full Excel library of functions eg. AVG([[Employee().Age]])</value>
  </data>
  <data name="CalculateFunctionResultText" xml:space="preserve">
    <value>The variable you would like to contain the result once the calculation has completed.</value>
  </data>
  <data name="CommentInputText" xml:space="preserve">
    <value>The comment entered here will not effect the workflow. This text will be visible in the debug output if this comment is included as a step in the workflow.</value>
  </data>
  <data name="CountRecordsetFromRecordsetHelpText" xml:space="preserve">
    <value>Simply enter the name of the recordset that you want to count in. eg
[[MyRecordset()]]</value>
  </data>
  <data name="CountRecordsResultHelpText" xml:space="preserve">
    <value>Only variables in [[Scalar]] or [[Recordset(*).Field]] format. If you use a recordset and do not specify an index/row number, a new record will be added.</value>
  </data>
  <data name="DateTimeAddTimeHelpText" xml:space="preserve">
    <value>Put a positive or negative number here to add or subtract from the input date time.
Leave this field blank if you do not want to change the date time.</value>
  </data>
  <data name="DateTimeInputFormatHelpText" xml:space="preserve">
    <value>Describe the format of the date time you are entering. e.g. 23-July 1978 would be described as dd-MM yyyy.
Leaving this field blank will assume the system date time format.</value>
  </data>
  <data name="DateTimeInputHelpText" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To format a date time, or to add/subtract from a date time, put it in here.
Leaving this field blank will give you the system date time.</value>
  </data>
  <data name="DateTimeOutputFormatHelpText" xml:space="preserve">
    <value>Describe the format you would like the date time to be returned in.
Leaving this field blank will assume the same as the Input Format.</value>
  </data>
  <data name="DateTimeResultHelpText" xml:space="preserve">
    <value>Only variables go in here.
Returns the formatted  and/or added/subtracted date time.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="FindRecordsFieldsToSearchHelpText" xml:space="preserve">
    <value>To find the indexes/rows that match certain criteria, put the comma separated list of fields to search in here. e.g. [[Customer().Name]], [[Customer().Prename]], [[Customer().Surname]]</value>
  </data>
  <data name="FindRecordsSearchTypeHelpText" xml:space="preserve">
    <value>Select the type of information you want to match on.</value>
  </data>
  <data name="ForEachRangeHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every number in the range provided and execute it once for each of those numbers. eg. Range of 1-5, will execute [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(2).ID]]
[[Customers(3).ID]]
[[Customers(4).ID]]
[[Customers(5).ID]]</value>
  </data>
  <data name="ForEachCsvHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every number in the comma seperated list provided and execute it once for each of those numbers. eg. CSV of 1,3,4,5,9 will execute [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(3).ID]]
[[Customers(4).ID]]
[[Customers(5).ID]]
[[Customers(9).ID]]</value>
  </data>
  <data name="ForEachNumberHelpText" xml:space="preserve">
    <value>This will execute the activity a given number of times.</value>
  </data>
  <data name="ForEachRecordHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every index number in the Recordset provided. If the Recordset provided has 3 records, then there will be 3 executions eg [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(2).ID]]
[[Customers(3).ID]]</value>
  </data>
  <data name="ForEachTypeHelpText" xml:space="preserve">
    <value>Types of loop.</value>
  </data>
  <data name="FindRecordsMatchHelpText" xml:space="preserve">
    <value>Select the match data to find.</value>
  </data>
  <data name="FindRecordsResultHelpText" xml:space="preserve">
    <value>Only variables go in here.
Returns the indexes of the successful matches.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.
If there are multiple results and a scalar is used, then each result will be separated with a comma.</value>
  </data>
  <data name="MultiAssignNewValueHelpText" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To assign a value to a variable, put the value in here.
If you put an = as the first character, it will turn into a calculation e.g. =[[qty]]*[[price]]</value>
  </data>
  <data name="MultiAssignVariableHelpText" xml:space="preserve">
    <value>Only variables go in here.
To assign a value to a variable, put the variable here.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="DataSplitDirectionHelpText" xml:space="preserve">
    <value>You can reverse the direction that the string is split by selecting Backward. By Default, the processing direction is Forward.</value>
  </data>
  <data name="DataSplitIncludeHelpText" xml:space="preserve">
    <value>If you want to include the item you  are splitting on in the result, make sure the checkbox is selected. The defaults for these are to not include unless its an index.</value>
  </data>
  <data name="DataSplitResultHelpText" xml:space="preserve">
    <value>At least one result must be present. You can use [[Scalar]] or [[Recordset().Fields]] notation.
If you use a recordset the split pattern will be repeated untill the end of the file, putting each row into a new record. If you dont want a piece of the data being split, leave that result blank.</value>
  </data>
  <data name="DataSplitSplitAtHelpText" xml:space="preserve">
    <value>Select the criteria for the split. This will be the pattern used to repeat against the String input untill no more splits can occur or, you use END.
Char will split on the characters you specify, like comma or | &lt;/.
Index will split on the numeric index from the previouse split.
New Line will split on carriage return.
Space will split on blank space. (You can use this to trim data)
Tab splits on a tab character.
End splits at the end of the string.</value>
  </data>
  <data name="DataSplitStringToSplitHelpText" xml:space="preserve">
    <value>Required field. Use any variable or data or combination of the two that you want to split. For file processing consider splitting first into headers, body and footers, then resplitting each of those independantly.</value>
  </data>
  <data name="BaseConvertResultHelpText" xml:space="preserve">
    <value>The variable where the result will be output to.</value>
  </data>
  <data name="BaseConvertInputHelpText" xml:space="preserve">
    <value>This data must be in the format specified in the 'Convert From' category. This data will be converted to the format specified in the 'Convert To' column.</value>
  </data>
  <data name="QuickVariableAppendHelpText" xml:space="preserve">
    <value>Append will add the variables onto the list of variables already in the input grid. The values of the last row will be repeated for all of these additional values.</value>
  </data>
  <data name="QuickVariablePrefixWithHelpText" xml:space="preserve">
    <value>To append something onto the front of the variables in your list, type it in here.
For recordsets, type  recordsetname(). Dont forget the "." after the "()"
You do not need to put the "[[" in.</value>
  </data>
  <data name="QuickVariableSplitAndAtHelpText" xml:space="preserve">
    <value>Select the criteria to split the variables in the list. This will be the pattern used to repeat against the Variable List box.
Char will split on the characters you specify, like comma or | &lt;/.
Index will split on the numeric index from the previouse split.
New Line will split on carriage return.
Space will split on blank space.
Tab splits on a tab character.</value>
  </data>
  <data name="QuickVariableSplitListOnHelpText" xml:space="preserve">
    <value>Simply enter the name of the recordset that you want to count in. eg
[[MyRecordset()]]</value>
  </data>
  <data name="QuickVariableSuffixWithHelpText" xml:space="preserve">
    <value>To append something onto the end of the variables in your list, type it in here.
You do not need to put the "]]" in.</value>
  </data>
  <data name="QuickVariableVariableListHelpText" xml:space="preserve">
    <value>Type or paste all the variables you want to use in here. You can paste in any format. If you are adding variables into a grid with a drop down or other input, the values from the last row will be repeated, so set them before adding these variables.</value>
  </data>
  <data name="QuickVariableReplaceHelpText" xml:space="preserve">
    <value>Replace will replace the current list of variables with this list. The values of the first row will be repeated for all of these new values.</value>
  </data>
  <data name="PreviewInputHelpText" xml:space="preserve">
    <value>Preview (recordset field)
This is a variable from an input field. Use comma-separated values for each index eg [[Trip(*).Distance]] = 45, 32, 12, 5
 
Preview (scalar field - including indexed recordsets and ())
This is a variable from an input field. Put some test info in and click the Preview button to test your result.</value>
  </data>
  <data name="WebRequestHeaderHelpText" xml:space="preserve">
    <value>To supply additional header information in your get request, put the header info in here.</value>
  </data>
  <data name="WebRequestResultHelpText" xml:space="preserve">
    <value>Only a single variable goes in here.
Returnes the response text of the web get request.</value>
  </data>
  <data name="WebRequestURIHelpText" xml:space="preserve">
    <value>Any data or variable can go in here.
To traverse an retrieve the raw response from a webpage, enter it in here.</value>
  </data>
  <data name="DateTimeAddTimeTypeHelpText" xml:space="preserve">
    <value>Select the unit of time to add or subtract. This is ignored if the unit is blank or 0.</value>
  </data>
  <data name="SqlBulkInsertHelpInputColumn" xml:space="preserve">
    <value>To bulk insert data into a table, put the data to insert in here.
Using recordset (*) notation will put the entire recordset in and is the normal usage scenario for large data inserts to SQL.
A single Recordset will yield the best performance. Do not mix, scalars and/or different recordsets for optimum performance.
To quickly change the input data, press the Quick Variable Input button and ammend the mappings as necessary.</value>
  </data>
  <data name="SqlBulkInsertHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns Success or the record numbers with errors.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="SqlBulkInsertHelpBatchSize" xml:space="preserve">
    <value>The number of rows you would like to insert at a time.
The default is 0 which will do everything in 1 batch.
If you specify 50, then 50 rows will be bulk inserted at a time.</value>
  </data>
  <data name="SqlBulkInsertHelpCheckConstraints" xml:space="preserve">
    <value>Check constraints while data is being inserted. By default, constraints are not checked.</value>
  </data>
  <data name="SqlBulkInsertHelpDatabase" xml:space="preserve">
    <value>Select a preconfigured database source or "New Database Source..." to add a new one.</value>
  </data>
  <data name="SqlBulkInsertHelpFireTriggers" xml:space="preserve">
    <value>When specified, cause the server to fire the insert triggers for the rows being inserted into the database.</value>
  </data>
  <data name="SqlBulkInsertHelpKeepIdentity" xml:space="preserve">
    <value>Preserve source identity values. When not specified, identity values are assigned by the destination.</value>
  </data>
  <data name="SqlBulkInsertHelpKeepTableLock" xml:space="preserve">
    <value>Obtain a bulk update lock for the duration of the bulk copy operation. When not specified, row locks are used.</value>
  </data>
  <data name="SqlBulkInsertHelpTableName" xml:space="preserve">
    <value>Select a table to perform the bulk insert into.
If the table schema has changed or recently added to the source, click the refresh button.</value>
  </data>
  <data name="SqlBulkInsertHelpTimeout" xml:space="preserve">
    <value>The number of seconds you would like the operation to complete in.
All batches in total must complete within this time period.
The default is 0 which will be no time constraint.
If you specify 30, then 30 seconds will be allowed for the entire operation to complete before timing out.
Note, the timeout is purely for the actual SQL connection and not the preparation of the data to be inserted.</value>
  </data>
  <data name="SqlBulkInsertHelpUseInternalTransaction" xml:space="preserve">
    <value>When specified, each batch of the bulk-copy operation will occur within a transaction.</value>
  </data>
  <data name="SqlBulkInsertToolTipBatchSize" xml:space="preserve">
    <value>Number
[[Scalar]]   
[[Recordset(n).Field]]      
[[Recordset().Field]]</value>
  </data>
  <data name="SqlBulkInsertToolTipCheckConstraints" xml:space="preserve">
    <value>Check constraints while data is being inserted.</value>
  </data>
  <data name="SqlBulkInsertToolTipDatabase" xml:space="preserve">
    <value>Select a preconfigured database source or "New Database Source..." to add a new one.</value>
  </data>
  <data name="SqlBulkInsertToolTipFireTriggers" xml:space="preserve">
    <value>When specified, cause the server to fire the insert triggers for the rows being inserted into the database.</value>
  </data>
  <data name="SqlBulkInsertToolTipInputColumn" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="SqlBulkInsertToolTipKeepIdentity" xml:space="preserve">
    <value>Preserve source identity values.</value>
  </data>
  <data name="SqlBulkInsertToolTipKeepTableLock" xml:space="preserve">
    <value>Obtain a bulk update lock for the duration of the bulk copy operation.</value>
  </data>
  <data name="SqlBulkInsertToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="SqlBulkInsertToolTipTableName" xml:space="preserve">
    <value>Select a table to perform the bulk insert into.</value>
  </data>
  <data name="SqlBulkInsertToolTipTimeout" xml:space="preserve">
    <value>Number
[[Scalar]]   
[[Recordset(n).Field]]      
[[Recordset().Field]]</value>
  </data>
  <data name="SqlBulkInsertToolTipUseInternalTransaction" xml:space="preserve">
    <value>When specified, each batch of the bulk-copy operation will occur within a transaction.</value>
  </data>
  <data name="String" xml:space="preserve">
    <value>To bulk insert data into a table, put the data to insert in here.</value>
  </data>
  <data name="String1" xml:space="preserve">
    <value>Using recordset (*) notation will put the entire recordset in and is the normal usage scenario for large data inserts to SQL.</value>
  </data>
  <data name="String2" xml:space="preserve">
    <value>NOTE: A single Recordset will yield the best performance. Do not mix, scalars and/or different recordsets for optimum performance.</value>
  </data>
  <data name="OnErrorHelpIsEnded" xml:space="preserve">
    <value>To end the workflow if an error has occurred at this point, make sure the checkbox is selected. 
If you have also called a web service / Warewolf workflow, that will finish executing first.
If the workflow is nested, the calling workflow will resume.</value>
  </data>
  <data name="OnErrorHelpVariable" xml:space="preserve">
    <value>If an error occurs the error message will be placed into this variable as well the result variable.
If left empty the result will still be placed in the result variable.</value>
  </data>
  <data name="OnErrorHelpWorkflow" xml:space="preserve">
    <value>If an error occurs you can execute a web service / Warewolf workflow to log the error that occurred.
E.g. http://ServerName:77/Services/LogErrors?Severity=1&amp;Error=[[ErrorMsg]]</value>
  </data>
  <data name="OnErrorToolTipIsEnded" xml:space="preserve">
    <value>Ends the executing workflow at this point</value>
  </data>
  <data name="OnErrorToolTipVariable" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="OnErrorToolTipWorkflow" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="SortRecordsHelpSortField" xml:space="preserve">
    <value>To Sort a recordset enter the field in the recordset you would like to sort on.
To sort on more than one field, perform the sort action for each field you would like to sort on, ending with the priority sort.</value>
  </data>
  <data name="SortRecordsHelpSortOrderType" xml:space="preserve">
    <value>Select the order of the sorting.
Forward will go 1-9 then a-Z.
Backward will go Z-a then 9-1.</value>
  </data>
  <data name="SortRecordsToolTipSortField" xml:space="preserve">
    <value>[[Recordset().Field]]</value>
  </data>
  <data name="BaseConversionHelpBaseInput" xml:space="preserve">
    <value>Any variable and data goes in here.
To convert Text, Hex, Binary and Base64, put the data to be converted in here.</value>
  </data>
  <data name="BaseConversionHelpFromType" xml:space="preserve">
    <value>Select the type of data you are converting from.
e.g. If the data is Binary and you would like Text, then select Binary here.</value>
  </data>
  <data name="BaseConversionHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the converted data into a separate variable.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="BaseConversionHelpToType" xml:space="preserve">
    <value>Select the type of data you are converting to.
e.g. If the data is Binary and you would like Text, then select Text here.</value>
  </data>
  <data name="BaseConversionToolTipBaseInput" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="BaseConversionToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CaseConversionHelpConvertToCaseType" xml:space="preserve">
    <value>Select the type of conversion you would like to make.</value>
  </data>
  <data name="CaseConversionHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the converted data.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="CaseConversionHelpTextInput" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To convert the case of some text, put the variable containing the text here.</value>
  </data>
  <data name="CaseConversionToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CaseConversionToolTipTextInput" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CopyHelpDestination" xml:space="preserve">
    <value>Any variable and/or data goes in here.
Put the full path of the destination you are copying to here.
You can use File System, URI, FTP or FTPS format.</value>
  </data>
  <data name="CopyHelpFileFolder" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To copy a file or folder, put the full path and file or folder name here.
You can use File System, URI, FTP or FTPS format.</value>
  </data>
  <data name="CopyHelpPassword" xml:space="preserve">
    <value>For protected resources, specify the Password of an account with permission to perform this action. By default the account running Warewolf Server.exe service will be used.</value>
  </data>
  <data name="CopyHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns Success or will be blank depending on the success of the Copy action.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="CopyHelpUsername" xml:space="preserve">
    <value>For protected resources, specify the Username of an account with permission to perform this action. By default the account running Warewolf Server.exe service will be used.</value>
  </data>
  <data name="CopyToolHelpForceOverwrite" xml:space="preserve">
    <value>If the file or folder already exists, you can force a new one to overwrite the old one.</value>
  </data>
  <data name="CopyToolTipDestination" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CopyToolTipFileFolder" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CopyToolTipForceOverwrite" xml:space="preserve">
    <value>If it exists already, force an overwrite</value>
  </data>
  <data name="CopyToolTipPassword" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CopyToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CopyToolTipUsername" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CreateHelpFileFolder" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To create a file or folder, put the full path and file or folder name here.
You can use File System, URI, FTP or FTPS format.</value>
  </data>
  <data name="CreateHelpForceOverWrite" xml:space="preserve">
    <value>If the file or folder already exists, you can force a new one to overwrite the old one.</value>
  </data>
  <data name="CreateHelpPassword" xml:space="preserve">
    <value>For protected resources, specify the Password of an account with permission to perform this action. By default the account running Warewolf Server.exe service will be used.</value>
  </data>
  <data name="CreateHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns Success or will be blank depending on the success of the Create action.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="CreateHelpUsername" xml:space="preserve">
    <value>For protected resources, specify the Username of an account with permission to perform this action. By default the account running Warewolf Server.exe service will be used.</value>
  </data>
  <data name="CreateToolTipFileFolder" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CreateToolTipForceOverWrite" xml:space="preserve">
    <value>If it exists already, force an overwrite</value>
  </data>
  <data name="CreateToolTipPassword" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CreateToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CreateToolTipUsername" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataMergeHelpAlignType" xml:space="preserve">
    <value>For Index you can specify if your data is aligned to the right or left.
E.g. Text is normally left and numbers normally right.</value>
  </data>
  <data name="DataMergeHelpInput" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To join two or more pieces of data together list them in the order you would like them joined. If you use recordset (*) notation, the list will be repeated for every record.</value>
  </data>
  <data name="DataMergeHelpPadding" xml:space="preserve">
    <value>If Index is being used and there is extra space between the data supplied and the number of index characters, you can specify what makes up the padding e.g. 0 for numbers or blank space for text.</value>
  </data>
  <data name="DataMergeHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the merged string.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="DataMergeHelpUsing" xml:space="preserve">
    <value>For Index use the number of characters that this merge will use. It will either trim if too little, or pad if too much.
For Char put any characters or combination of characters you would like.
Not applicable to New Line or Tab</value>
  </data>
  <data name="DataMergeHelpWithType" xml:space="preserve">
    <value>Select the type of merge you would like between each piece of merged data, if any.</value>
  </data>
  <data name="DataMergeToolTipInput" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataMergeToolTipPadding" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataMergeToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataMergeToolTipUsing" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataSplitHelpEscape" xml:space="preserve">
    <value>If there is an occurrence or an item being split on, that should not be split on, it will be preceded with this character. e.g., a comma separated file might have a comma in a name, so don’t split on it if it is preceded by / or some other characters.</value>
  </data>
  <data name="DataSplitHelpInclude" xml:space="preserve">
    <value>If you would like the data or item you are splitting on to be included in the result data, select this checkbox.</value>
  </data>
  <data name="DataSplitHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the split data in the pattern as described by the results.
The variable pattern will be repeated until the end of the input data.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="DataSplitHelpString" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To split a value into one or more variables, put the value in here.
You can process entire file content or just trim the white space from a variable.</value>
  </data>
  <data name="DataSplitHelpUsing" xml:space="preserve">
    <value>For Index use the number of characters that this split will use. 
For Char put any characters or combination of characters you would like.
Not applicable to New Line, Tab or End</value>
  </data>
  <data name="DataSplitHelpWithType" xml:space="preserve">
    <value>Select where you would like to split the data.</value>
  </data>
  <data name="DataSplitToolTipEscape" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataSplitToolTipInclude" xml:space="preserve">
    <value>Include the information you are splitting on?</value>
  </data>
  <data name="DataSplitToolTipResult" xml:space="preserve">
    <value>[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataSplitToolTipString" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="DataSplitToolTipUsing" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="FindIndexHelpCharacters" xml:space="preserve">
    <value>Any variable and/or data goes in here.
Put  the index of the string you are looking for in here.</value>
  </data>
  <data name="FindIndexHelpDirectiontype" xml:space="preserve">
    <value>Select the direction to search in.</value>
  </data>
  <data name="FindIndexHelpIndexType" xml:space="preserve">
    <value>Select which index(es) you would like found.</value>
  </data>
  <data name="FindIndexHelpInField" xml:space="preserve">
    <value>Any variable and/or data goes in here.
To find the character index(es) of a string inside another string, put the string to be searched here.</value>
  </data>
  <data name="FindIndexHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the index(es) of the found string.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record. If you are finding All Occurrences and using a scalar, the results will be comma separated.</value>
  </data>
  <data name="FindIndexToolTipCharacters" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="FindIndexToolTipInField" xml:space="preserve">
    <value>[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="FindIndexToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="ReplaceHelpFind" xml:space="preserve">
    <value>Put the information you are looking for in here.</value>
  </data>
  <data name="ReplaceHelpInField" xml:space="preserve">
    <value>Only variables go in here.
To search and replace a string, put the variable containing the string to search in here.</value>
  </data>
  <data name="ReplaceHelpReplaceWith" xml:space="preserve">
    <value>Put the replacement information in here.</value>
  </data>
  <data name="ReplaceHelpResult" xml:space="preserve">
    <value>Only variables go in here.
Returns the count of the number of replacements.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="ReplaceToolTipFind" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="ReplaceToolTipInField" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="ReplaceToolTipReplaceWith" xml:space="preserve">
    <value>Data   
[[Scalar]]   
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="ReplaceToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
  <data name="CountRecordsHelpRecordset" xml:space="preserve">
    <value>To Count the number of records/indexes in a recordset, put the recordset name in here. E.g. [[Customer()]]</value>
  </data>
  <data name="CountRecordsHelpResult" xml:space="preserve">
    <value>Only variables go in here. Returns a number specifying how many records/indexes are in the recordset.
You can use [[Scalar]] as well as [[Recordset().Fields]].
Using recordset () will add a new record and (*) will assign every record.</value>
  </data>
  <data name="CountRecordsToolTipRecordset" xml:space="preserve">
    <value>[[Recordset()]]</value>
  </data>
  <data name="CountRecordsToolTipResult" xml:space="preserve">
    <value>[[Scalar]]  
[[Recordset(n).Field]]   
[[Recordset(*).Field]]   
[[Recordset().Field]]</value>
  </data>
</root>