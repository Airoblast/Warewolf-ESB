<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CalculateFunctionInputText" xml:space="preserve">
    <value>The Calculate Service works like the function box in Microsoft Excel (fn). Type the equation using good maths practices and put a variable from the Data List into the Result field. You can use the full Excel library of functions eg. AVG([[Employee().Age]])</value>
  </data>
  <data name="CalculateFunctionResultText" xml:space="preserve">
    <value>The variable you would like to contain the result once the calculation has completed.</value>
  </data>
  <data name="CommentInputText" xml:space="preserve">
    <value>The comment entered here will not effect the workflow. This text will be visible in the debug output if this comment is included as a step in the workflow.</value>
  </data>
  <data name="CountRecordsetFromRecordsetHelpText" xml:space="preserve">
    <value>Simply enter the name of the recordset that you want to count in. eg
[[MyRecordset()]]</value>
  </data>
  <data name="CountRecordsResultHelpText" xml:space="preserve">
    <value>Only variables in [[Scalar]] or [[Recordset(*).Field]] format. If you use a recordset and do not specify an index/row number, a new record will be added.</value>
  </data>
  <data name="DateTimeAddTimeHelpText" xml:space="preserve">
    <value>A positive or negative number that will add or subtract a portion of time from the Input. The drop down will dictate the unit of time. Level the field blank if you are not adding or subtracting time.</value>
  </data>
  <data name="DateTimeInputFormatHelpText" xml:space="preserve">
    <value>Describe the dates format here using the short hand from the intellisense. eg. a date 23-July-1978 would be described dd-MM-yyyy. If you leave this field blank, it will use the system date time format - very handy when generating the date from the system.</value>
  </data>
  <data name="DateTimeInputHelpText" xml:space="preserve">
    <value>Put the date you want to reformat or add/subtract from in here. You can use both variables and data eg [[Day]] July 1978, as the input if you want to hard code that part of the date. If you leave the Input blank, then the server time will be used by default. Using a * for recordset (eg. [[Recordset(*).Field]]) will process every record without needing to use a for each. Make sure you put a recordset field in the Result.</value>
  </data>
  <data name="DateTimeOutputFormatHelpText" xml:space="preserve">
    <value>Describe the dates output format here using the short hand from the intellisense. eg. a date 23-July-1978 would be described dd-MM-yyyy. If you leave this field blank, it will use the same format as the Input Format.</value>
  </data>
  <data name="DateTimeResultHelpText" xml:space="preserve">
    <value>Required Field.
Only variables in [[Scalar]] or [[Recordset(*).Field]] format. If you use a recordset and do not specify an index/row number, a new record will be added.</value>
  </data>
  <data name="FindRecordsFieldsToSearchHelpText" xml:space="preserve">
    <value>This must the a recordset field. eg: "[[Recordset().Field]]"</value>
  </data>
  <data name="FindRecordsSearchTypeHelpText" xml:space="preserve">
    <value>The type of the search.</value>
  </data>
  <data name="ForEachRangeHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every number in the range provided and execute it once for each of those numbers. eg. Range of 1-5, will execute [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(2).ID]]
[[Customers(3).ID]]
[[Customers(4).ID]]
[[Customers(5).ID]]</value>
  </data>
  <data name="ForEachCsvHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every number in the comma seperated list provided and execute it once for each of those numbers. eg. CSV of 1,3,4,5,9 will execute [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(3).ID]]
[[Customers(4).ID]]
[[Customers(5).ID]]
[[Customers(9).ID]]</value>
  </data>
  <data name="ForEachNumberHelpText" xml:space="preserve">
    <value>This will execute the activity a given number of times.</value>
  </data>
  <data name="ForEachRecordHelpText" xml:space="preserve">
    <value>This will replace the * in the activity with every index number in the Recordset provided. If the Recordset provided has 3 records, then there will be 3 executions eg [[Customers(*).ID]] as
[[Customers(1).ID]]
[[Customers(2).ID]]
[[Customers(3).ID]]</value>
  </data>
  <data name="ForEachTypeHelpText" xml:space="preserve">
    <value>Types of loop.</value>
  </data>
  <data name="FindRecordsMatchHelpText" xml:space="preserve">
    <value>The data to compare to.</value>
  </data>
  <data name="FindRecordsResultHelpText" xml:space="preserve">
    <value>The name of the variable to output the comma seperated list of indices to. eg: "[[RowWithResult]]"</value>
  </data>
  <data name="MultiAssignNewVariableHelpText" xml:space="preserve">
    <value>Other variables and data can go in here.
If you want to assign a value to a variable, then put the value in here.
If you put an = as the first character, it will turn into a calculation eg. =[[qty]]*[[price]] or =sum([[rec(*).volume]])</value>
  </data>
  <data name="MultiAssignVariableHelpText" xml:space="preserve">
    <value>Only variables can go in here.
If you want to assign a value to a variable, then put the variable here.
You can use [[scalars]] as well as [[Recordset().Fields]].
If you use [[Recordset(*).Fields]] then every record in that field will have the value you give it in the New Value field.</value>
  </data>
  <data name="DataSplitDirectionHelpText" xml:space="preserve">
    <value>You can reverse the direction that the string is split by selecting Backward. By Default, the processing direction is Forward.</value>
  </data>
  <data name="DataSplitIncludeHelpText" xml:space="preserve">
    <value>If you want to include the item you  are splitting on in the result, make sure the checkbox is selected. The defaults for these are to not include unless its an index.</value>
  </data>
  <data name="DataSplitResultHelpText" xml:space="preserve">
    <value>At least one result must be present. You can use [[Scalar]] or [[Recordset().Fields]] notation.
If you use a recordset the split pattern will be repeated untill the end of the file, putting each row into a new record. If you dont want a piece of the data being split, leave that result blank.</value>
  </data>
  <data name="DataSplitSplitAtHelpText" xml:space="preserve">
    <value>Select the criteria for the split. This will be the pattern used to repeat against the String input untill no more splits can occur or, you use END.
Char will split on the characters you specify, like comma or | &lt;/.
Index will split on the numeric index from the previouse split.
New Line will split on carriage return.
Space will split on blank space. (You can use this to trim data)
Tab splits on a tab character.
End splits at the end of the string.</value>
  </data>
  <data name="DataSplitStringToSplitHelpText" xml:space="preserve">
    <value>Required field. Use any variable or data or combination of the two that you want to split. For file processing consider splitting first into headers, body and footers, then resplitting each of those independantly.</value>
  </data>
  <data name="BaseConvertResultHelpText" xml:space="preserve">
    <value>The variable where the result will be output to.</value>
  </data>
  <data name="BaseConvertInputHelpText" xml:space="preserve">
    <value>This data must be in the format specified in the 'Convert From' category. This data will be converted to the format specified in the 'Convert To' column.</value>
  </data>
</root>